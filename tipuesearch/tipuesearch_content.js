var tipuesearch = {"pages":[{"title":" FLAP ","text":"FLAP FLAP FLAP, Fortran command Line Arguments Parser for poor people A KISS pure Fortran Library for building powerful, easy-to-use, elegant command line interfaces FLAP is a pure Fortran (KISS) library for building easily nice Command Line Interfaces (CLI) for modern Fortran projects; FLAP is Fortran 2003+ standard compliant; FLAP is OOP designed; FLAP is a Free, Open Source Project. Issues Compiler Support | What is FLAP? | Main features | Copyrights | Documentation | Install | What is FLAP? Modern Fortran standards (2003+) have introduced support for Command Line Arguments (CLA), thus it is possible to construct nice and effective Command Line Interfaces (CLI). FLAP is a small library designed to simplify the (repetitive) construction of complicated CLI in pure Fortran (standard 2003+). FLAP has been inspired by the python module argparse trying to mimic it. Once you have defined the arguments that are required by means of a user-friendly method of the CLI, FLAP will parse the CLAs for you. It is worthy of note that FLAP, as argparse , also automatically generates help and usage messages and issues errors when users give the program invalid arguments. Go to Top Main features FLAP is inspired by the python great module argparse , thus many features are taken from it. Here the main features are listed. [x] User-friendly methods for building flexible and effective Command Line Interfaces (CLI); [x] comprehensive Command Line Arguments (CLA) support: [x] support optional and non optional CLA; [x] support boolean CLA; [x] support positional CLA; [x] support list of allowable values for defined CLA with automatic consistency check; [x] support multiple valued (list of values, aka list-valued) CLA: [x] compiletime sized list, e.g. nargs='3' ; [x] runtime sized list with at least 1 value, e.g. nargs='+' ; [x] runtime sized list with any size, even empty, e.g. nargs='*' ; [x] support mutually exclusive CLAs; [x] self-consistency-check of CLA definition; [x] support fake CLAs input from a string; [x] support fake CLAs input from environment variables; [x] comprehensive command (group of CLAs) support: [x] support nested subcommands; [x] support mutually exclusive commands; [x] self-consistency-check of command definition; [x] automatic generation of help and usage messages; [x] consistency-check of whole CLI definition; [x] errors trapping for invalid CLI usage; [x] POSIX style compliant; [x] automatic generation of MAN PAGE using your CLI definition!; [x] replicate all the useful features of argparse ; [ ] implement docopt features. [ ] implement click features. Any feature request is welcome. Go to Top Copyrights FLAP is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FLAP is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FLAP documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of FLAP A minimal plate : program minimal type ( command_line_interface ) :: cli ! Command Line Interface (CLI). character ( 99 ) :: string ! String value. integer :: error ! Error trapping flag. call cli % init ( description = 'minimal FLAP example' ) call cli % add ( switch = '--string' , & switch_ab = '-s' , & help = 'a string' , & required = . true ., & act = 'store' , & error = error ) if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = string , error = error ) if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String = ' // trim ( adjustl ( string )) endprogram minimal That built and run provides: → ./minimal\n./minimal: error: named option \"--string\" is required!\n\nusage:  ./exe/test_minimal --string value [ --help ] [ --version ] minimal FLAP example\n\nRequired switches:\n   --string value, -s value\n    a string\n\nOptional switches:\n   --help, -h\n    Print this help message\n   --version, -v\n    Print version A nice automatic help-message, right? Executed correctly gives. → ./minimal --string 'hello world' ./exe/minimal has been called with the following argument: String = hello world For more details, see the provided tests . Nested (sub)commands FLAP fully supports nested (sub)commands or groups of command line arguments. For example a fake git toy remake can be coded as ! initializing Command Line Interface call cli % init ( progname = 'test_nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' ,& examples = [ 'test_nested                      ' ,& 'test_nested -h                   ' ,& 'test_nested init                 ' ,& 'test_nested commit -m \"fix bug-1\"' ,& 'test_nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! using Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif that when invoked without arguments prompts: cowardly you are doing nothing... try at least \"-h\" option! and invoked with -h option gives: usage: test_nested [ --authors ] [ --help ] [ --version ] { init,commit,tag } ...\n\nToy program for testing FLAP with nested commands\n\nOptional switches:\n   --authors, -a\n          default value .false.\n          Print authors names\n   --help, -h\n          Print this help message\n   --version, -v\n          Print version\n\nCommands:\n  init\n          fake init versioning\n  commit\n          fake commit changes to current branch\n  tag\n          fake tag current commit\n\nFor more detailed commands help try:\n  test_nested init -h,--help\n  test_nested commit -h,--help\n  test_nested tag -h,--help\n\nExamples:\n   test_nested\n   test_nested -h\n   test_nested init\n   test_nested commit -m \"fix bug-1\" test_nested tag -a \"v2.1.5\" For more details, see the provided example . Go to Top Install FLAP is a Fortran library composed by several modules. Before download and compile the library you must check the requirements . To download and build the project two main ways are available: exploit the install script that can be downloaded here manually download and build : download build install script FLAP ships a bash script (downloadable from here ) that is able to automatize the download and build steps. The script install.sh has the following usage: → ./install.sh\nInstall script of FLAP\nUsage:\n\ninstall.sh --help | -?\n    Print this usage output and exit install.sh --download | -d <arg> [ --verbose | -v ] Download the project\n\n    --download | -d [ arg ] Download the project, arg = git | wget to download with git or wget respectively\n    --verbose | -v         Output verbose mode activation\n\ninstall.sh --build | -b <arg> [ --verbose | -v ] Build the project\n\n    --build | -b [ arg ] Build the project, arg = fobis | make | cmake to build with FoBiS.py, GNU Make or CMake respectively\n    --verbose | -v      Output verbose mode activation\n\nExamples:\n\ninstall.sh --download git\ninstall.sh --build make\ninstall.sh --download wget --build cmake The script does not cover all possibilities. The script operation modes are 2 ( collapsible into one-single-mode): download a new fresh-clone of the latest master-release by means of: git ; wget (also curl is necessary); build a fresh-clone project as static-linked library by means of: FoBiS.py ; GNU Make ; CMake ; Fortran Package Manager ; you can mix any of the above combinations accordingly to the tools available. Typical usages are: # download and prepare the project by means of git and build with GNU Make install.sh --dowload git --build make # download and prepare the project by means of wget (curl) and build with CMake install.sh --dowload wget --build cmake # download and prepare the project by means of git and build with FoBiS.py install.sh --dowload git --build fobis manually download and build download To download all the available releases and utilities (fobos, license, readme, etc…), it can be convenient to clone whole the project: git clone https://github.com/szaghi/FLAP cd FLAP\ngit submodule update --init Alternatively, you can directly download a release from GitHub server, see the ChangeLog . build The most easy way to compile FLAP is to use FoBiS.py within the provided fobos file. Consequently, it is strongly encouraged to install FoBiS.py . | Build by means of FoBiS | Build by means of GNU Make | Build by means of CMake | build by means of FoBiS FoBiS.py is a KISS tool for automatic building of modern Fortran projects. Providing very few options, FoBiS.py is able to build almost automatically complex Fortran projects with cumbersome inter-modules dependency. This removes the necessity to write complex makefile. Moreover, providing a very simple options file (in the FoBiS.py nomenclature indicated as fobos file) FoBiS.py can substitute the (ab)use of makefile for other project stuffs (build documentations, make project archive, etc…). FLAP is shipped with a fobos file that can build the library in both static and shared forms and also build the Test_Driver program. The provided fobos file has several building modes. listing fobos building modes Typing: FoBiS.py build -lmodes the following message should be printed: The fobos file defines the following modes:\n - \"shared-gnu\" - \"static-gnu\" - \"test-driver-gnu\" - \"shared-gnu-debug\" - \"static-gnu-debug\" - \"test-driver-gnu-debug\" - \"shared-intel\" - \"static-intel\" - \"test-driver-intel\" - \"shared-intel-debug\" - \"static-intel-debug\" - \"test-driver-intel-debug\" The modes should be self-explicative: shared , static and test-driver are the modes for building (in release, optimized form) the shared and static versions of the library and the Test Driver program, respectively. The other 3 modes are the same, but in debug form instead of release one. -gnu use the GNU gfortran compiler while -intel the Intel one. building the library The shared or static directories are created accordingly to the form of the library built. The compiled objects and mod files are placed inside this directory, as well as the linked library. release shared library FoBiS.py build -mode shared-gnu release static library FoBiS.py build -mode static-gnu debug shared library FoBiS.py build -mode shared-gnu-debug debug static library FoBiS.py build -mode static-gnu-debug building the Test Driver program The Test_Driver directory is created. The compiled objects and mod files are placed inside this directory, as well as the linked program. release test driver program FoBiS.py build -mode test-driver-gnu debug test driver program FoBiS.py build -mode test-driver-gnu-debug listing fobos rules Typing: FoBiS.py rule -ls the following message should be printed: The fobos file defines the following rules:\n  - \"makedoc\" Rule for building documentation from source files Command = > rm -rf doc/html/* Command = > ford doc/main_page.md Command = > cp -r doc/html/publish/* doc/html/\n  - \"deldoc\" Rule for deleting documentation Command = > rm -rf doc/html/*\n  - \"maketar\" Rule for making tar archive of the project Command = > tar -czf FLAP.tar.gz *\n  - \"makecoverage\" Rule for performing coverage analysis Command = > FoBiS.py clean -mode test-driver-gnu Command = > FoBiS.py build -mode test-driver-gnu -coverage Command = > ./Test_Driver/Test_Driver Command = > ./Test_Driver/Test_Driver -v Command = > ./Test_Driver/Test_Driver -s 'Hello FLAP' -i 2 Command = > ./Test_Driver/Test_Driver 33 .0 -s 'Hello FLAP' --integer_list 10 -3 87 -i 3 -r 64 .123d0  --boolean --boolean_val .false.\n  - \"coverage-analysis\" Rule for performing coverage analysis and saving reports in markdown Command = > FoBiS.py clean -mode test-driver-gnu Command = > FoBiS.py build -mode test-driver-gnu -coverage Command = > ./Test_Driver/Test_Driver Command = > ./Test_Driver/Test_Driver -v Command = > ./Test_Driver/Test_Driver -s 'Hello FLAP' -i 2 Command = > ./Test_Driver/Test_Driver 33 .0 -s 'Hello FLAP' --integer_list 10 -3 87 -i 3 -r 64 .123d0  --boolean --boolean_val .false. Command = > gcov -o Test_Driver/obj/ src/* Command = > FoBiS.py rule -gcov_analyzer wiki/ Coverage-Analysis Command = > rm -f *.gcov The rules should be self-explicative. build by means of GNU Make Bad choice :-) However, a makefile (generated by FoBiS.py…) to be used with a compatible GNU Make tool is provided . It is convenient to clone the whole FLAP repository and run a standard make: git clone https://github.com/szaghi/FLAP cd FLAP\nmake -j 1 This commands build all tests (executables are in exe/ directory). To build only the library (statically linked) type: git clone https://github.com/szaghi/FLAP cd FLAP\nmake -j 1 STATIC = yes Build by means of CMake Bad choice :-) However, a CMake setup (kindly developed by victorsndvg ) is provided. It is convenient to clone the whole FLAP repository and run a standard CMake configure/build commands: git clone https://github.com/szaghi/FLAP $YOUR_FLAP_PATH mkdir build cd build\ncmake $YOUR_FLAP_PATH cmake --build . If you want to run the tests suite type: git clone https://github.com/szaghi/FLAP $YOUR_FLAP_PATH mkdir build cd build\ncmake -DFLAP_ENABLE_TESTS = ON $YOUR_FLAP_PATH cmake --build .\nctest Build by means of FPM A Fortran Package Manager manifest file is also included, so that the library and test cases can be compiled with FPM. For example: fpm build --profile release\nfpm test --profile release To use FLAP within your fpm project, add the following to your fpm.toml file: [dependencies] FLAP = { git = \"https://github.com/szaghi/FLAP.git\" } Or, to use a specific revision: [dependencies] FLAP = { git = \"https://github.com/szaghi/FLAP.git\" , rev = \"11cb276228d678c1d9ce755badf0ce82094b0852\" } Note that, when compiling with FPM, the git submodules in the src/third_party directory are not used, but FPM will download these separately, based on the versions specified in the fpm.toml file. Go to Top Developer Info Stefano Zaghi","tags":"home","loc":"index.html"},{"title":"tester_t – FLAP ","text":"type, public :: tester_t The main tester class. Contents Variables n_errors n_tests tolerance32 tolerance64 Type-Bound Procedures init print assert_equal assert_equal_i8 assert_equal_i16 assert_equal_i32 assert_equal_i64 assert_equal_r32 assert_equal_r64 assert_equal_c32 assert_equal_c64 assert_equal_l assert_equal_i8_1 assert_equal_i16_1 assert_equal_i32_1 assert_equal_i64_1 assert_equal_r32_1 assert_equal_r64_1 assert_equal_c32_1 assert_equal_c64_1 assert_equal_l_1 assert_positive assert_positive_i8 assert_positive_i16 assert_positive_i32 assert_positive_i64 assert_positive_r32 assert_positive_r64 assert_positive_i8_1 assert_positive_i16_1 assert_positive_i32_1 assert_positive_i64_1 assert_positive_r32_1 assert_positive_r64_1 assert_close assert_close_r32 assert_close_r64 assert_close_c32 assert_close_c64 assert_close_r32_1 assert_close_r64_1 assert_close_c32_1 assert_close_c64_1 Source Code tester_t Components Type Visibility Attributes Name Initial integer(kind=int32), private :: n_errors = 0_int32 Number of errors. integer(kind=int32), private :: n_tests = 0_int32 Number of tests. real(kind=real32), private :: tolerance32 = 2._real32*epsilon(1._real32) Real tolerance, 32 bits. real(kind=real64), private :: tolerance64 = 2._real64*epsilon(1._real64) Real tolerance, 64 bits. Type-Bound Procedures procedure, public :: init Initialize the tester. private subroutine init (this, tolerance32, tolerance64) Initialize the tester. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(out) :: this The tester. real(kind=real32), intent(in), optional :: tolerance32 Real tolerance, 32 bits. real(kind=real64), intent(in), optional :: tolerance64 Real tolerance, 64 bits. procedure, public :: print Print tests results. private subroutine print (this, errorstop) Print tests results. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(in) :: this The tester. logical, intent(in), optional :: errorstop Flag to activate error stop if one test fails. generic, public :: assert_equal => assert_equal_i8 , assert_equal_i16 , assert_equal_i32 , assert_equal_i64 , assert_equal_r32 , assert_equal_r64 , assert_equal_c32 , assert_equal_c64 , assert_equal_l , assert_equal_i8_1 , assert_equal_i16_1 , assert_equal_i32_1 , assert_equal_i64_1 , assert_equal_r32_1 , assert_equal_r64_1 , assert_equal_c32_1 , assert_equal_c64_1 , assert_equal_l_1 Check if two values (integer, real, complex or logical) are equal. private subroutine assert_equal_i8 (this, i1, i2) Check if two integers (8 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i1 Value to compare. integer(kind=int8), intent(in) :: i2 Value to compare. private subroutine assert_equal_i16 (this, i1, i2) Check if two integers (16 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i1 Value to compare. integer(kind=int16), intent(in) :: i2 Value to compare. private subroutine assert_equal_i32 (this, i1, i2) Check if two integers (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i1 Value to compare. integer(kind=int32), intent(in) :: i2 Value to compare. private subroutine assert_equal_i64 (this, i1, i2) Check if two integers (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i1 Value to compare. integer(kind=int64), intent(in) :: i2 Value to compare. private subroutine assert_equal_r32 (this, r1, r2) Check if two reals (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Value to compare. real(kind=real32), intent(in) :: r2 Value to compare. private subroutine assert_equal_r64 (this, r1, r2) Check if two reals (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Value to compare. real(kind=real64), intent(in) :: r2 Value to compare. private subroutine assert_equal_c32 (this, c1, c2) Check if two complex numbers (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in) :: c1 Value to compare. complex(kind=real32), intent(in) :: c2 Value to compare. private subroutine assert_equal_c64 (this, c1, c2) Check if two complex numbers (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in) :: c1 Value to compare. complex(kind=real64), intent(in) :: c2 Value to compare. private subroutine assert_equal_l (this, l1, l2) Check if two logicals are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in) :: l1 Value to compare. logical, intent(in) :: l2 Value to compare. private subroutine assert_equal_i8_1 (this, i1, i2) Check if two integer (8 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int8), intent(in), dimension(:) :: i2 Value to compare. private subroutine assert_equal_i16_1 (this, i1, i2) Check if two integer (16 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int16), intent(in), dimension(:) :: i2 Value to compare. private subroutine assert_equal_i32_1 (this, i1, i2) Check if two integer (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int32), intent(in), dimension(:) :: i2 Value to compare. private subroutine assert_equal_i64_1 (this, i1, i2) Check if two integer (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int64), intent(in), dimension(:) :: i2 Value to compare. private subroutine assert_equal_r32_1 (this, r1, r2) Check if two real (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Value to compare. real(kind=real32), intent(in), dimension(:) :: r2 Value to compare. private subroutine assert_equal_r64_1 (this, r1, r2) Check if two real (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Value to compare. real(kind=real64), intent(in), dimension(:) :: r2 Value to compare. private subroutine assert_equal_c32_1 (this, c1, c2) Check if two complex (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real32), intent(in), dimension(:) :: c2 Value to compare. private subroutine assert_equal_c64_1 (this, c1, c2) Check if two complex (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real64), intent(in), dimension(:) :: c2 Value to compare. private subroutine assert_equal_l_1 (this, l1, l2) Check if two logical arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in), dimension(:) :: l1 Value to compare. logical, intent(in), dimension(:) :: l2 Value to compare. procedure, private :: assert_equal_i8 Check if two integers (8  bits) are equal. private subroutine assert_equal_i8 (this, i1, i2) Check if two integers (8 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i1 Value to compare. integer(kind=int8), intent(in) :: i2 Value to compare. procedure, private :: assert_equal_i16 Check if two integers (16 bits) are equal. private subroutine assert_equal_i16 (this, i1, i2) Check if two integers (16 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i1 Value to compare. integer(kind=int16), intent(in) :: i2 Value to compare. procedure, private :: assert_equal_i32 Check if two integers (32 bits) are equal. private subroutine assert_equal_i32 (this, i1, i2) Check if two integers (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i1 Value to compare. integer(kind=int32), intent(in) :: i2 Value to compare. procedure, private :: assert_equal_i64 Check if two integers (64 bits) are equal. private subroutine assert_equal_i64 (this, i1, i2) Check if two integers (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i1 Value to compare. integer(kind=int64), intent(in) :: i2 Value to compare. procedure, private :: assert_equal_r32 Check if two reals (32 bits) are equal. private subroutine assert_equal_r32 (this, r1, r2) Check if two reals (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Value to compare. real(kind=real32), intent(in) :: r2 Value to compare. procedure, private :: assert_equal_r64 Check if two reals (64 bits) are equal. private subroutine assert_equal_r64 (this, r1, r2) Check if two reals (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Value to compare. real(kind=real64), intent(in) :: r2 Value to compare. procedure, private :: assert_equal_c32 Check if two complex numbers (32 bits) are equal. private subroutine assert_equal_c32 (this, c1, c2) Check if two complex numbers (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in) :: c1 Value to compare. complex(kind=real32), intent(in) :: c2 Value to compare. procedure, private :: assert_equal_c64 Check if two complex numbers (64 bits) are equal. private subroutine assert_equal_c64 (this, c1, c2) Check if two complex numbers (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in) :: c1 Value to compare. complex(kind=real64), intent(in) :: c2 Value to compare. procedure, private :: assert_equal_l Check if two logicals are equal. private subroutine assert_equal_l (this, l1, l2) Check if two logicals are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in) :: l1 Value to compare. logical, intent(in) :: l2 Value to compare. procedure, private :: assert_equal_i8_1 Check if two integer (8  bits) arrays (rank 1) are equal. private subroutine assert_equal_i8_1 (this, i1, i2) Check if two integer (8 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int8), intent(in), dimension(:) :: i2 Value to compare. procedure, private :: assert_equal_i16_1 Check if two integer (16 bits) arrays (rank 1) are equal. private subroutine assert_equal_i16_1 (this, i1, i2) Check if two integer (16 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int16), intent(in), dimension(:) :: i2 Value to compare. procedure, private :: assert_equal_i32_1 Check if two integer (32 bits) arrays (rank 1) are equal. private subroutine assert_equal_i32_1 (this, i1, i2) Check if two integer (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int32), intent(in), dimension(:) :: i2 Value to compare. procedure, private :: assert_equal_i64_1 Check if two integer (64 bits) arrays (rank 1) are equal. private subroutine assert_equal_i64_1 (this, i1, i2) Check if two integer (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int64), intent(in), dimension(:) :: i2 Value to compare. procedure, private :: assert_equal_r32_1 Check if two real (32 bits) arrays (rank 1) are equal. private subroutine assert_equal_r32_1 (this, r1, r2) Check if two real (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Value to compare. real(kind=real32), intent(in), dimension(:) :: r2 Value to compare. procedure, private :: assert_equal_r64_1 Check if two real (64 bits) arrays (rank 1) are equal. private subroutine assert_equal_r64_1 (this, r1, r2) Check if two real (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Value to compare. real(kind=real64), intent(in), dimension(:) :: r2 Value to compare. procedure, private :: assert_equal_c32_1 Check if two complex (32 bits) arrays (rank 1) are equal. private subroutine assert_equal_c32_1 (this, c1, c2) Check if two complex (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real32), intent(in), dimension(:) :: c2 Value to compare. procedure, private :: assert_equal_c64_1 Check if two complex (64 bits) arrays (rank 1) are equal. private subroutine assert_equal_c64_1 (this, c1, c2) Check if two complex (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real64), intent(in), dimension(:) :: c2 Value to compare. procedure, private :: assert_equal_l_1 Check if two logical arrays (rank 1) are equal. private subroutine assert_equal_l_1 (this, l1, l2) Check if two logical arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in), dimension(:) :: l1 Value to compare. logical, intent(in), dimension(:) :: l2 Value to compare. generic, public :: assert_positive => assert_positive_i8 , assert_positive_i16 , assert_positive_i32 , assert_positive_i64 , assert_positive_r32 , assert_positive_r64 , assert_positive_i8_1 , assert_positive_i16_1 , assert_positive_i32_1 , assert_positive_i64_1 , assert_positive_r32_1 , assert_positive_r64_1 Check if a number (integer or real) is positive. private subroutine assert_positive_i8 (this, i) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i Value to check. private subroutine assert_positive_i16 (this, i) Check if a integer (16 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i Value to check. private subroutine assert_positive_i32 (this, i) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i Value to check. private subroutine assert_positive_i64 (this, i) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i Value to check. private subroutine assert_positive_r32 (this, r) Check if a real (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r Value to check. private subroutine assert_positive_r64 (this, r) Check if a real (64 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r Value to check. private subroutine assert_positive_i8_1 (this, i) Check if a integer (8 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i Value to check. private subroutine assert_positive_i16_1 (this, i) Check if a integer (16 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i Value to check. private subroutine assert_positive_i32_1 (this, i) Check if a integer (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i Value to check. private subroutine assert_positive_i64_1 (this, i) Check if a integer (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i Value to check. private subroutine assert_positive_r32_1 (this, r) Check if a real (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r Value to check. private subroutine assert_positive_r64_1 (this, r) Check if a real (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r Value to check. procedure, private :: assert_positive_i8 Check if a integer (8  bits) is positive. private subroutine assert_positive_i8 (this, i) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i Value to check. procedure, private :: assert_positive_i16 Check if a integer (16 bits) is positive. private subroutine assert_positive_i16 (this, i) Check if a integer (16 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i Value to check. procedure, private :: assert_positive_i32 Check if a integer (32 bits) is positive. private subroutine assert_positive_i32 (this, i) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i Value to check. procedure, private :: assert_positive_i64 Check if a integer (64 bits) is positive. private subroutine assert_positive_i64 (this, i) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i Value to check. procedure, private :: assert_positive_r32 Check if a real (32 bits) is positive. private subroutine assert_positive_r32 (this, r) Check if a real (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r Value to check. procedure, private :: assert_positive_r64 Check if a real (64 bits) is positive. private subroutine assert_positive_r64 (this, r) Check if a real (64 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r Value to check. procedure, private :: assert_positive_i8_1 Check if a integer (8  bits) array (rank 1) is positive. private subroutine assert_positive_i8_1 (this, i) Check if a integer (8 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i Value to check. procedure, private :: assert_positive_i16_1 Check if a integer (16 bits) array (rank 1) is positive. private subroutine assert_positive_i16_1 (this, i) Check if a integer (16 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i Value to check. procedure, private :: assert_positive_i32_1 Check if a integer (32 bits) array (rank 1) is positive. private subroutine assert_positive_i32_1 (this, i) Check if a integer (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i Value to check. procedure, private :: assert_positive_i64_1 Check if a integer (64 bits) array (rank 1) is positive. private subroutine assert_positive_i64_1 (this, i) Check if a integer (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i Value to check. procedure, private :: assert_positive_r32_1 Check if a real (32 bits) array (rank 1) is positive. private subroutine assert_positive_r32_1 (this, r) Check if a real (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r Value to check. procedure, private :: assert_positive_r64_1 Check if a real (64 bits) array (rank 1) is positive. private subroutine assert_positive_r64_1 (this, r) Check if a real (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r Value to check. generic, public :: assert_close => assert_close_r32 , assert_close_r64 , assert_close_c32 , assert_close_c64 , assert_close_r32_1 , assert_close_r64_1 , assert_close_c32_1 , assert_close_c64_1 Check if two values (real or complex) are close with respect a tolerance. private subroutine assert_close_r32 (this, r1, r2) Check if two reals (32 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Value to compare. real(kind=real32), intent(in) :: r2 Value to compare. private subroutine assert_close_r64 (this, r1, r2) Check if two reals (64 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Value to compare. real(kind=real64), intent(in) :: r2 Value to compare. private subroutine assert_close_c32 (this, c1, c2) Check if two complex numbers (32 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in) :: c1 Value to compare. complex(kind=real32), intent(in) :: c2 Value to compare. private subroutine assert_close_c64 (this, r1, c2) Check if two complex numbers (64 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in) :: r1 Value to compare. complex(kind=real64), intent(in) :: c2 Value to compare. private subroutine assert_close_r32_1 (this, r1, r2) Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Value to compare. real(kind=real32), intent(in), dimension(:) :: r2 Value to compare. private subroutine assert_close_r64_1 (this, r1, r2) Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Value to compare. real(kind=real64), intent(in), dimension(:) :: r2 Value to compare. private subroutine assert_close_c32_1 (this, c1, c2) Check if two complex (32 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real32), intent(in), dimension(:) :: c2 Value to compare. private subroutine assert_close_c64_1 (this, c1, c2) Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real64), intent(in), dimension(:) :: c2 Value to compare. procedure, private :: assert_close_r32 Check if two reals (32 bits) are close with respect a tolerance. private subroutine assert_close_r32 (this, r1, r2) Check if two reals (32 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Value to compare. real(kind=real32), intent(in) :: r2 Value to compare. procedure, private :: assert_close_r64 Check if two reals (64 bits) are close with respect a tolerance. private subroutine assert_close_r64 (this, r1, r2) Check if two reals (64 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Value to compare. real(kind=real64), intent(in) :: r2 Value to compare. procedure, private :: assert_close_c32 Check if two complex numbers (32 bits) are close with respect a tolerance. private subroutine assert_close_c32 (this, c1, c2) Check if two complex numbers (32 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in) :: c1 Value to compare. complex(kind=real32), intent(in) :: c2 Value to compare. procedure, private :: assert_close_c64 Check if two complex numbers (64 bits) are close with respect a tolerance. private subroutine assert_close_c64 (this, r1, c2) Check if two complex numbers (64 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in) :: r1 Value to compare. complex(kind=real64), intent(in) :: c2 Value to compare. procedure, private :: assert_close_r32_1 Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. private subroutine assert_close_r32_1 (this, r1, r2) Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Value to compare. real(kind=real32), intent(in), dimension(:) :: r2 Value to compare. procedure, private :: assert_close_r64_1 Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. private subroutine assert_close_r64_1 (this, r1, r2) Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Value to compare. real(kind=real64), intent(in), dimension(:) :: r2 Value to compare. procedure, private :: assert_close_c32_1 Check if two complex (32 bits) arrays (rank 1) are close with respect a tolerance. private subroutine assert_close_c32_1 (this, c1, c2) Check if two complex (32 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real32), intent(in), dimension(:) :: c2 Value to compare. procedure, private :: assert_close_c64_1 Check if two complex (64 bits) arrays (rank 1) are close with respect a tolerance. private subroutine assert_close_c64_1 (this, c1, c2) Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real64), intent(in), dimension(:) :: c2 Value to compare. Source Code type :: tester_t integer ( int32 ) :: n_errors = 0_int32 !< Number of errors. integer ( int32 ) :: n_tests = 0_int32 !< Number of tests. real ( real32 ) :: tolerance32 = 2._real32 * epsilon ( 1._real32 ) !< Real tolerance, 32 bits. real ( real64 ) :: tolerance64 = 2._real64 * epsilon ( 1._real64 ) !< Real tolerance, 64 bits. contains procedure :: init !< Initialize the tester. procedure :: print !< Print tests results. generic , public :: assert_equal => & assert_equal_i8 , & assert_equal_i16 , & assert_equal_i32 , & assert_equal_i64 , & assert_equal_r32 , & assert_equal_r64 , & assert_equal_c32 , & assert_equal_c64 , & assert_equal_l , & assert_equal_i8_1 , & assert_equal_i16_1 , & assert_equal_i32_1 , & assert_equal_i64_1 , & assert_equal_r32_1 , & assert_equal_r64_1 , & assert_equal_c32_1 , & assert_equal_c64_1 , & assert_equal_l_1 !< Check if two values (integer, real, complex or logical) are equal. procedure , private :: assert_equal_i8 !< Check if two integers (8  bits) are equal. procedure , private :: assert_equal_i16 !< Check if two integers (16 bits) are equal. procedure , private :: assert_equal_i32 !< Check if two integers (32 bits) are equal. procedure , private :: assert_equal_i64 !< Check if two integers (64 bits) are equal. procedure , private :: assert_equal_r32 !< Check if two reals (32 bits) are equal. procedure , private :: assert_equal_r64 !< Check if two reals (64 bits) are equal. procedure , private :: assert_equal_c32 !< Check if two complex numbers (32 bits) are equal. procedure , private :: assert_equal_c64 !< Check if two complex numbers (64 bits) are equal. procedure , private :: assert_equal_l !< Check if two logicals are equal. procedure , private :: assert_equal_i8_1 !< Check if two integer (8  bits) arrays (rank 1) are equal. procedure , private :: assert_equal_i16_1 !< Check if two integer (16 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_i32_1 !< Check if two integer (32 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_i64_1 !< Check if two integer (64 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_r32_1 !< Check if two real (32 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_r64_1 !< Check if two real (64 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_c32_1 !< Check if two complex (32 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_c64_1 !< Check if two complex (64 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_l_1 !< Check if two logical arrays (rank 1) are equal. generic , public :: assert_positive => & assert_positive_i8 , & assert_positive_i16 , & assert_positive_i32 , & assert_positive_i64 , & assert_positive_r32 , & assert_positive_r64 , & assert_positive_i8_1 , & assert_positive_i16_1 , & assert_positive_i32_1 , & assert_positive_i64_1 , & assert_positive_r32_1 , & assert_positive_r64_1 !< Check if a number (integer or real) is positive. procedure , private :: assert_positive_i8 !< Check if a integer (8  bits) is positive. procedure , private :: assert_positive_i16 !< Check if a integer (16 bits) is positive. procedure , private :: assert_positive_i32 !< Check if a integer (32 bits) is positive. procedure , private :: assert_positive_i64 !< Check if a integer (64 bits) is positive. procedure , private :: assert_positive_r32 !< Check if a real (32 bits) is positive. procedure , private :: assert_positive_r64 !< Check if a real (64 bits) is positive. procedure , private :: assert_positive_i8_1 !< Check if a integer (8  bits) array (rank 1) is positive. procedure , private :: assert_positive_i16_1 !< Check if a integer (16 bits) array (rank 1) is positive. procedure , private :: assert_positive_i32_1 !< Check if a integer (32 bits) array (rank 1) is positive. procedure , private :: assert_positive_i64_1 !< Check if a integer (64 bits) array (rank 1) is positive. procedure , private :: assert_positive_r32_1 !< Check if a real (32 bits) array (rank 1) is positive. procedure , private :: assert_positive_r64_1 !< Check if a real (64 bits) array (rank 1) is positive. generic , public :: assert_close => & assert_close_r32 , & assert_close_r64 , & assert_close_c32 , & assert_close_c64 , & assert_close_r32_1 , & assert_close_r64_1 , & assert_close_c32_1 , & assert_close_c64_1 !< Check if two values (real or complex) are close with respect a tolerance. procedure , private :: assert_close_r32 !< Check if two reals (32 bits) are close with respect a tolerance. procedure , private :: assert_close_r64 !< Check if two reals (64 bits) are close with respect a tolerance. procedure , private :: assert_close_c32 !< Check if two complex numbers (32 bits) are close with respect a tolerance. procedure , private :: assert_close_c64 !< Check if two complex numbers (64 bits) are close with respect a tolerance. procedure , private :: assert_close_r32_1 !< Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. procedure , private :: assert_close_r64_1 !< Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. procedure , private :: assert_close_c32_1 !< Check if two complex (32 bits) arrays (rank 1) are close with respect a tolerance. procedure , private :: assert_close_c64_1 !< Check if two complex (64 bits) arrays (rank 1) are close with respect a tolerance. end type tester_t","tags":"","loc":"type/tester_t.html"},{"title":"object – FLAP ","text":"type, public, abstract :: object Base (abstract) class upon which FLAP’s concrete classes are built. Inherited by type~~object~~InheritedByGraph type~object object type~command_line_arguments_group command_line_arguments_group type~command_line_arguments_group->type~object type~command_line_argument command_line_argument type~command_line_arguments_group->type~command_line_argument cla type~command_line_argument->type~object type~command_line_interface command_line_interface type~command_line_interface->type~object type~command_line_interface->type~command_line_arguments_group clasg Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables progname version help help_color help_style help_markdown description license authors epilog m_exclude error_message error_color error_style examples error usage_lun version_lun error_lun Type-Bound Procedures free_object print_version print_error_message set_examples assign_object Source Code object Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_style ANSI style of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_color ANSI color of error messages. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=512), public, allocatable :: examples (:) Examples of correct usage. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages Type-Bound Procedures procedure, public, pass(self) :: free_object Free dynamic memory. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. procedure, public, pass(self) :: print_version Print version. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character, intent(in), optional :: pref Prefixing string. procedure, public, pass(self) :: print_error_message Print meaningful error message. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. procedure, public, pass(self) :: set_examples Set examples of correct usage. private subroutine set_examples (self, examples) Set examples of correct usage. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. character, intent(in), optional :: examples (1:) Examples of correct usage. procedure, public, pass(lhs ) :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. Source Code type , abstract , public :: object !< Base (abstract) class upon which FLAP's concrete classes are built. character ( len = :), allocatable :: progname !< Program name. character ( len = :), allocatable :: version !< Program version. character ( len = :), allocatable :: help !< Help message. character ( len = :), allocatable :: help_color !< ANSI color of help messages. character ( len = :), allocatable :: help_style !< ANSI style of help messages. character ( len = :), allocatable :: help_markdown !< Longer help message, markdown formatted. character ( len = :), allocatable :: description !< Detailed description. character ( len = :), allocatable :: license !< License description. character ( len = :), allocatable :: authors !< Authors list. character ( len = :), allocatable :: epilog !< Epilogue message. character ( len = :), allocatable :: m_exclude !< Mutually exclude other CLA(s group). character ( len = :), allocatable :: error_message !< Meaningful error message to standard-error. character ( len = :), allocatable :: error_color !< ANSI color of error messages. character ( len = :), allocatable :: error_style !< ANSI style of error messages. #ifdef __GFORTRAN__ character ( 512 ), allocatable :: examples (:) !< Examples of correct usage. #else character ( len = :), allocatable :: examples (:) !< Examples of correct usage. #endif integer ( I4P ) :: error = 0_I4P !< Error trapping flag. integer ( I4P ) :: usage_lun = stderr !< Output unit to print help/usage messages integer ( I4P ) :: version_lun = stdout !< Output unit to print version message integer ( I4P ) :: error_lun = stderr !< Error unit to print error messages contains ! public methods procedure , pass ( self ) :: free_object !< Free dynamic memory. procedure , pass ( self ) :: print_version !< Print version. procedure , pass ( self ) :: print_error_message !< Print meaningful error message. procedure , pass ( self ) :: set_examples !< Set examples of correct usage. procedure , pass ( lhs ) :: assign_object !< Assignment overloading. endtype object","tags":"","loc":"type/object.html"},{"title":"command_line_arguments_group – FLAP ","text":"type, public, extends( object ) :: command_line_arguments_group Command Line Arguments Group (CLAsG) class. CLAsG are useful for building nested commands. Inherits type~~command_line_arguments_group~~InheritsGraph type~command_line_arguments_group command_line_arguments_group type~command_line_argument command_line_argument type~command_line_arguments_group->type~command_line_argument cla type~object object type~command_line_arguments_group->type~object type~command_line_argument->type~object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~command_line_arguments_group~~InheritedByGraph type~command_line_arguments_group command_line_arguments_group type~command_line_interface command_line_interface type~command_line_interface->type~command_line_arguments_group clasg Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables progname version help help_color help_style help_markdown description license authors epilog m_exclude error_message error_color error_style examples error usage_lun version_lun error_lun group Na Na_required Na_optional cla is_called Finalization Procedures finalize Type-Bound Procedures free_object print_version print_error_message set_examples assign_object free check is_required_passed is_passed is_defined raise_error_m_exclude add parse usage signature sanitize_defaults errored check_m_exclusive clasg_assign_clasg assignment(=) Source Code command_line_arguments_group Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_style ANSI style of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_color ANSI color of error messages. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=512), public, allocatable :: examples (:) Examples of correct usage. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: group Group name (command). integer(kind=I4P), public :: Na = 0_I4P Number of CLA. integer(kind=I4P), private :: Na_required = 0_I4P Number of required command line arguments. integer(kind=I4P), private :: Na_optional = 0_I4P Number of optional command line arguments. type( command_line_argument ), public, allocatable :: cla (:) CLA list [1:Na]. logical, public :: is_called = .false. Flag for checking if CLAs group has been passed to CLI. Finalization Procedures final :: finalize Free dynamic memory when finalizing. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_arguments_group ), intent(inout) :: self CLAsG data. Type-Bound Procedures procedure, public, pass(self) :: free_object Free dynamic memory. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. procedure, public, pass(self) :: print_version Print version. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character, intent(in), optional :: pref Prefixing string. procedure, public, pass(self) :: print_error_message Print meaningful error message. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. procedure, public, pass(self) :: set_examples Set examples of correct usage. private subroutine set_examples (self, examples) Set examples of correct usage. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. character, intent(in), optional :: examples (1:) Examples of correct usage. procedure, public, pass(lhs ) :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. procedure, public :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. procedure, public :: check Check data consistency. private subroutine check (self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. procedure, public :: is_required_passed Check if required CLAs are passed. private subroutine is_required_passed (self, pref) Check if required CLAs are passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. procedure, public :: is_passed Check if a CLA has been passed. private pure function is_passed (self, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. procedure, public :: is_defined Check if a CLA has been defined. private function is_defined (self, switch, pos) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character, intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. procedure, public :: raise_error_m_exclude Raise error mutually exclusive CLAs passed. private subroutine raise_error_m_exclude (self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. procedure, public :: add Add CLA to CLAsG. private subroutine add (self, pref, cla) Add CLA to CLAs list. Read more… Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. type( command_line_argument ), intent(in) :: cla CLA data. procedure, public :: parse Parse CLAsG arguments. private subroutine parse (self, args, ignore_unknown_clas, pref, error_unknown_clas) Parse CLAsG arguments. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in) :: args (:) Command line arguments. logical, intent(in) :: ignore_unknown_clas Disable errors-raising for passed unknown CLAs. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out) :: error_unknown_clas Error flag for passed unknown CLAs. procedure, public :: usage Get correct CLAsG usage. private function usage (self, pref, no_header, markdown) Get correct CLAsG usage. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: markdown Format things form markdown. Return Value character(len=:),allocatable Usage string. procedure, public :: signature Get CLAsG signature. private function signature (self, bash_completion, plain) Get CLAsG signature. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. logical, intent(in), optional :: bash_completion Return the signature for bash completion. logical, intent(in), optional :: plain Return the signature as plain switches list. Return Value character(len=:),allocatable Signature. procedure, public :: sanitize_defaults Sanitize default values. private subroutine sanitize_defaults (self) Sanitize defaults values. Read more… Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. procedure, private :: errored Trig error occurrence and print meaningful message. private subroutine errored (self, error, pref, a1, a2) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. integer(kind=I4P), intent(in) :: error Error occurred. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(in), optional :: a1 First index CLAs group inconsistent. integer(kind=I4P), intent(in), optional :: a2 Second index CLAs group inconsistent. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs have been passed. private subroutine check_m_exclusive (self, pref) Check if two mutually exclusive CLAs have been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. procedure, private :: clasg_assign_clasg Assignment operator. private elemental subroutine clasg_assign_clasg (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: lhs Left hand side. type( command_line_arguments_group ), intent(in) :: rhs Right hand side. generic, private :: assignment(=) => clasg_assign_clasg Assignment operator overloading. private elemental subroutine clasg_assign_clasg (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: lhs Left hand side. type( command_line_arguments_group ), intent(in) :: rhs Right hand side. Source Code type , extends ( object ) :: command_line_arguments_group !< Command Line Arguments Group (CLAsG) class. !< !< CLAsG are useful for building nested commands. private character ( len = :), allocatable , public :: group !< Group name (command). integer ( I4P ), public :: Na = 0_I4P !< Number of CLA. integer ( I4P ) :: Na_required = 0_I4P !< Number of required command line arguments. integer ( I4P ) :: Na_optional = 0_I4P !< Number of optional command line arguments. type ( command_line_argument ), allocatable , public :: cla (:) !< CLA list [1:Na]. logical , public :: is_called = . false . !< Flag for checking if CLAs group has been passed to CLI. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: check !< Check data consistency. procedure , public :: is_required_passed !< Check if required CLAs are passed. procedure , public :: is_passed !< Check if a CLA has been passed. procedure , public :: is_defined !< Check if a CLA has been defined. procedure , public :: raise_error_m_exclude !< Raise error mutually exclusive CLAs passed. procedure , public :: add !< Add CLA to CLAsG. procedure , public :: parse !< Parse CLAsG arguments. procedure , public :: usage !< Get correct CLAsG usage. procedure , public :: signature !< Get CLAsG signature. procedure , public :: sanitize_defaults !< Sanitize default values. ! private methods procedure , private :: errored !< Trig error occurrence and print meaningful message. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs have been passed. procedure , private :: clasg_assign_clasg !< Assignment operator. generic , private :: assignment ( = ) => clasg_assign_clasg !< Assignment operator overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_arguments_group","tags":"","loc":"type/command_line_arguments_group.html"},{"title":"command_line_interface – FLAP ","text":"type, public, extends( object ) :: command_line_interface Command Line Interface (CLI) class. Inherits type~~command_line_interface~~InheritsGraph type~command_line_interface command_line_interface type~command_line_arguments_group command_line_arguments_group type~command_line_interface->type~command_line_arguments_group clasg type~object object type~command_line_interface->type~object type~command_line_arguments_group->type~object type~command_line_argument command_line_argument type~command_line_arguments_group->type~command_line_argument cla type~command_line_argument->type~object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables progname version help help_color help_style help_markdown description license authors epilog m_exclude error_message error_color error_style examples error usage_lun version_lun error_lun clasg args disable_hv is_parsed_ ignore_unknown_clas error_unknown_clas Finalization Procedures finalize Type-Bound Procedures free_object print_version print_error_message set_examples assign_object free init add_group add is_passed is_defined_group is_defined is_parsed set_mutually_exclusive_groups run_command parse get get_varying usage signature print_usage save_bash_completion save_man_page save_usage_to_markdown errored check check_m_exclusive get_clasg_indexes get_args get_args_from_string get_args_from_invocation get_cla get_cla_list get_cla_list_varying_R16P get_cla_list_varying_R8P get_cla_list_varying_R4P get_cla_list_varying_I8P get_cla_list_varying_I4P get_cla_list_varying_I2P get_cla_list_varying_I1P get_cla_list_varying_logical get_cla_list_varying_char cli_assign_cli assignment(=) Source Code command_line_interface Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_style ANSI style of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_color ANSI color of error messages. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=512), public, allocatable :: examples (:) Examples of correct usage. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages type( command_line_arguments_group ), public, allocatable :: clasg (:) CLA list [1:Na]. character(len=512), public, allocatable :: args (:) Actually passed command line arguments. logical, public :: disable_hv = .false. Disable automatic ‘help’ and ‘version’ CLAs. logical, public :: is_parsed_ = .false. Parse status. logical, public :: ignore_unknown_clas = .false. Disable errors-raising for passed unknown CLAs. integer(kind=I4P), public :: error_unknown_clas = 0_I4P Error trapping flag for unknown CLAs. Finalization Procedures final :: finalize Free dynamic memory when finalizing. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_interface ), intent(inout) :: self CLI data. Type-Bound Procedures procedure, public, pass(self) :: free_object Free dynamic memory. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. procedure, public, pass(self) :: print_version Print version. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character, intent(in), optional :: pref Prefixing string. procedure, public, pass(self) :: print_error_message Print meaningful error message. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. procedure, public, pass(self) :: set_examples Set examples of correct usage. private subroutine set_examples (self, examples) Set examples of correct usage. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. character, intent(in), optional :: examples (1:) Examples of correct usage. procedure, public, pass(lhs ) :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. procedure, public :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. procedure, public :: init Initialize CLI. private subroutine init (self, progname, version, help, description, license, authors, examples, epilog, disable_hv, usage_lun, error_lun, version_lun, error_color, error_style, ignore_unknown_clas) Initialize CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: progname Program name. character, intent(in), optional :: version Program version. character, intent(in), optional :: help Help message introducing the CLI usage. character, intent(in), optional :: description Detailed description message introducing the program. character, intent(in), optional :: license License description. character, intent(in), optional :: authors Authors list. character, intent(in), optional :: examples (1:) Examples of correct usage. character, intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of ‘help’ and ‘version’ CLAs. integer(kind=I4P), intent(in), optional :: usage_lun Unit number to print usage/help. integer(kind=I4P), intent(in), optional :: error_lun Unit number to print error info. integer(kind=I4P), intent(in), optional :: version_lun Unit number to print version/license info. character, intent(in), optional :: error_color ANSI color of error messages. character, intent(in), optional :: error_style ANSI style of error messages. logical, intent(in), optional :: ignore_unknown_clas Disable errors-raising for passed unknown CLAs. procedure, public :: add_group Add CLAs group CLI. private subroutine add_group (self, help, description, exclude, examples, group) Add CLAs group to CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: help Help message. character, intent(in), optional :: description Detailed description. character, intent(in), optional :: exclude Group name of the mutually exclusive group. character, intent(in), optional :: examples (1:) Examples of correct usage of the group. character, intent(in) :: group Name of the grouped CLAs. procedure, public :: add Add CLA to CLI. private subroutine add (self, pref, group, group_index, switch, switch_ab, help, help_markdown, help_color, help_style, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Add CLA to CLI. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character, intent(in), optional :: switch Switch name. character, intent(in), optional :: switch_ab Abbreviated switch name. character, intent(in), optional :: help Help message describing the CLA. character, intent(in), optional :: help_markdown Longer help message, markdown formatted. character, intent(in), optional :: help_color ANSI color of help messages. character, intent(in), optional :: help_style ANSI style of help messages. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character, intent(in), optional :: act CLA value action. character, intent(in), optional :: def Default value. character, intent(in), optional :: nargs Number of arguments consumed by CLA. character, intent(in), optional :: choices List of allowable values for the argument. character, intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character, intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, public :: is_passed Check if a CLA has been passed. private function is_passed (self, group, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. procedure, public :: is_defined_group Check if a CLAs group has been defined. private function is_defined_group (self, group, g) result(defined) Check if a CLAs group has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. procedure, public :: is_defined Check if a CLA has been defined. private function is_defined (self, switch, group) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: switch Switch name. character, intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. procedure, public :: is_parsed Check if CLI has been parsed. private elemental function is_parsed (self) Check if CLI has been parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value logical Parsed status. procedure, public :: set_mutually_exclusive_groups Set two CLAs group as mutually exclusive. private subroutine set_mutually_exclusive_groups (self, group1, group2) Set two CLAs group ad mutually exclusive. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in) :: group1 Name of the first grouped CLAs. character, intent(in) :: group2 Name of the second grouped CLAs. procedure, public :: run_command => is_called_group Check if a CLAs group has been run. private function is_called_group (self, group) result(called) Check if a CLAs group has been run. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. procedure, public :: parse Parse Command Line Interfaces. private subroutine parse (self, pref, args, error) Parse Command Line Interfaces by means of a previously initialized CLAs groups list. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. generic, public :: get => get_cla , get_cla_list Get CLA value(s) from CLAs list parsed. private subroutine get_cla (self, val, pref, args, group, switch, position, error) Get CLA (single) value from CLAs list parsed. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val CLA value. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val (1:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. generic, public :: get_varying => get_cla_list_varying_R8P , get_cla_list_varying_R4P , get_cla_list_varying_I8P , get_cla_list_varying_I4P , get_cla_list_varying_I2P , get_cla_list_varying_I1P , get_cla_list_varying_logical , get_cla_list_varying_char Get CLA value(s) from CLAs list parsed, varying size list. private subroutine get_cla_list_varying_R8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_R4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I2P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I1P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_logical (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, logical. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. logical, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_char (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, character. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, public :: usage Get CLI usage. private function usage (self, g, pref, no_header, no_examples, no_epilog, markdown) result(usaged) Print correct usage of CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. integer(kind=I4P), intent(in) :: g Group index. character, intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. logical, intent(in), optional :: markdown Format things with markdown Return Value character(len=:),allocatable Usage string. procedure, public :: signature Get CLI signature. private function signature (self, bash_completion) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. logical, intent(in), optional :: bash_completion Return the signature for bash completion. Return Value character(len=:),allocatable Signature. procedure, public :: print_usage Print correct usage of CLI. private subroutine print_usage (self, pref) Print correct usage. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in), optional :: pref Prefixing string. procedure, public :: save_bash_completion Save bash completion script (for named CLAs only). private subroutine save_bash_completion (self, bash_file, error) Save bash completion script (for named CLAs only). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: bash_file Output file name of bash completion script. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, public :: save_man_page Save CLI usage as man page. private subroutine save_man_page (self, man_file, error) Save CLI usage as man page. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, public :: save_usage_to_markdown Save CLI usage as markdown. private subroutine save_usage_to_markdown (self, markdown_file, error) Save CLI usage as markdown. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: markdown_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: errored Trig error occurence and print meaningful message. private subroutine errored (self, error, pref, group, switch) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self Object data. integer(kind=I4P), intent(in) :: error Error occurred. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: group Group name. character, intent(in), optional :: switch CLA switch name. procedure, private :: check Check data consistency. private subroutine check (self, pref, error) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs group have been called. private subroutine check_m_exclusive (self, pref) Check if two mutually exclusive CLAs group have been called. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: pref Prefixing string. procedure, private :: get_clasg_indexes Get CLAs groups indexes. private subroutine get_clasg_indexes (self, ai) Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. generic, private :: get_args => get_args_from_string , get_args_from_invocation Get CLAs. private subroutine get_args_from_string (self, args, ai) Get CLAs from string. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. private subroutine get_args_from_invocation (self, ai) Get CLAs from CLI invocation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. procedure, private :: get_args_from_string Get CLAs from string. private subroutine get_args_from_string (self, args, ai) Get CLAs from string. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. procedure, private :: get_args_from_invocation Get CLAs from CLI invocation. private subroutine get_args_from_invocation (self, ai) Get CLAs from CLI invocation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. procedure, private :: get_cla Get CLA (single) value from CLAs list parsed. private subroutine get_cla (self, val, pref, args, group, switch, position, error) Get CLA (single) value from CLAs list parsed. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val CLA value. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list Get CLA multiple values from CLAs list parsed. private subroutine get_cla_list (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val (1:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_R16P Get CLA multiple values from CLAs list parsed, varying size, R16P. private subroutine get_cla_list_varying_R16P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values from CLAs list parsed, varying size, R8P. private subroutine get_cla_list_varying_R8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_R4P Get CLA multiple values from CLAs list parsed, varying size, R4P. private subroutine get_cla_list_varying_R4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_I8P Get CLA multiple values from CLAs list parsed, varying size, I8P. private subroutine get_cla_list_varying_I8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_I4P Get CLA multiple values from CLAs list parsed, varying size, I4P. private subroutine get_cla_list_varying_I4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_I2P Get CLA multiple values from CLAs list parsed, varying size, I2P. private subroutine get_cla_list_varying_I2P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_I1P Get CLA multiple values from CLAs list parsed, varying size, I1P. private subroutine get_cla_list_varying_I1P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_logical Get CLA multiple values from CLAs list parsed, varying size, bool. private subroutine get_cla_list_varying_logical (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, logical. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. logical, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_char Get CLA multiple values from CLAs list parsed, varying size, char. private subroutine get_cla_list_varying_char (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, character. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: cli_assign_cli CLI assignment overloading. private elemental subroutine cli_assign_cli (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: lhs Left hand side. type( command_line_interface ), intent(in) :: rhs Right hand side. generic, private :: assignment(=) => cli_assign_cli CLI assignment overloading. private elemental subroutine cli_assign_cli (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: lhs Left hand side. type( command_line_interface ), intent(in) :: rhs Right hand side. Source Code type , extends ( object ), public :: command_line_interface !< Command Line Interface (CLI) class. private type ( command_line_arguments_group ), allocatable :: clasg (:) !< CLA list [1:Na]. #ifdef __GFORTRAN__ character ( 512 ), allocatable :: args (:) !< Actually passed command line arguments. #else character ( len = :), allocatable :: args (:) !< Actually passed command line arguments. #endif logical :: disable_hv = . false . !< Disable automatic 'help' and 'version' CLAs. logical :: is_parsed_ = . false . !< Parse status. logical :: ignore_unknown_clas = . false . !< Disable errors-raising for passed unknown CLAs. integer ( I4P ) :: error_unknown_clas = 0_I4P !< Error trapping flag for unknown CLAs. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: init !< Initialize CLI. procedure , public :: add_group !< Add CLAs group CLI. procedure , public :: add !< Add CLA to CLI. procedure , public :: is_passed !< Check if a CLA has been passed. procedure , public :: is_defined_group !< Check if a CLAs group has been defined. procedure , public :: is_defined !< Check if a CLA has been defined. procedure , public :: is_parsed !< Check if CLI has been parsed. procedure , public :: set_mutually_exclusive_groups !< Set two CLAs group as mutually exclusive. procedure , public :: run_command => is_called_group !< Check if a CLAs group has been run. procedure , public :: parse !< Parse Command Line Interfaces. generic , public :: get => & get_cla , & get_cla_list !< Get CLA value(s) from CLAs list parsed. generic , public :: get_varying => & #if defined _R16P get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char !< Get CLA value(s) from CLAs list parsed, varying size list. procedure , public :: usage !< Get CLI usage. procedure , public :: signature !< Get CLI signature. procedure , public :: print_usage !< Print correct usage of CLI. procedure , public :: save_bash_completion !< Save bash completion script (for named CLAs only). procedure , public :: save_man_page !< Save CLI usage as man page. procedure , public :: save_usage_to_markdown !< Save CLI usage as markdown. ! private methods procedure , private :: errored !< Trig error occurence and print meaningful message. procedure , private :: check !< Check data consistency. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs group have been called. procedure , private :: get_clasg_indexes !< Get CLAs groups indexes. generic , private :: get_args => & get_args_from_string , & get_args_from_invocation !< Get CLAs. procedure , private :: get_args_from_string !< Get CLAs from string. procedure , private :: get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_cla !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R16P !< Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: cli_assign_cli !< CLI assignment overloading. generic , private :: assignment ( = ) => cli_assign_cli !< CLI assignment overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_interface","tags":"","loc":"type/command_line_interface.html"},{"title":"command_line_argument – FLAP ","text":"type, public, extends( object ) :: command_line_argument Command Line Argument (CLA) class. Note If not otherwise declared the action on CLA value is set to “store” a value. Inherits type~~command_line_argument~~InheritsGraph type~command_line_argument command_line_argument type~object object type~command_line_argument->type~object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~command_line_argument~~InheritedByGraph type~command_line_argument command_line_argument type~command_line_arguments_group command_line_arguments_group type~command_line_arguments_group->type~command_line_argument cla type~command_line_interface command_line_interface type~command_line_interface->type~command_line_arguments_group clasg Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables progname version help help_color help_style help_markdown description license authors epilog m_exclude error_message error_color error_style examples error usage_lun version_lun error_lun switch switch_ab is_required is_positional position is_passed is_hidden act def nargs choices val envvar Finalization Procedures finalize Type-Bound Procedures free_object print_version print_error_message set_examples assign_object free check is_required_passed raise_error_m_exclude raise_error_nargs_insufficient raise_error_value_missing raise_error_switch_unknown raise_error_duplicated_clas get get_varying has_choices sanitize_defaults signature usage errored check_envvar_consistency check_action_consistency check_optional_consistency check_m_exclude_consistency check_named_consistency check_positional_consistency check_choices check_list_size get_cla get_cla_from_buffer get_cla_list get_cla_list_from_buffer get_cla_list_varying_R16P get_cla_list_varying_R8P get_cla_list_varying_R4P get_cla_list_varying_I8P get_cla_list_varying_I4P get_cla_list_varying_I2P get_cla_list_varying_I1P get_cla_list_varying_logical get_cla_list_varying_char cla_assign_cla assignment(=) Source Code command_line_argument Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_style ANSI style of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_color ANSI color of error messages. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=512), public, allocatable :: examples (:) Examples of correct usage. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: switch Switch name. character(len=:), public, allocatable :: switch_ab Abbreviated switch name. logical, public :: is_required = .false. Flag for set required argument. logical, public :: is_positional = .false. Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), public :: position = 0_I4P Position of positional CLA. logical, public :: is_passed = .false. Flag for checking if CLA has been passed to CLI. logical, public :: is_hidden = .false. Flag for hiding CLA, thus it does not compare into help. character(len=:), public, allocatable :: act CLA value action. character(len=:), public, allocatable :: def Default value. character(len=:), public, allocatable :: nargs Number of arguments consumed by CLA. character(len=:), public, allocatable :: choices List (comma separated) of allowable values for the argument. character(len=:), public, allocatable :: val CLA value. character(len=:), public, allocatable :: envvar Environment variable from which take value. Finalization Procedures final :: finalize Free dynamic memory when finalizing. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_argument ), intent(inout) :: self CLA data. Type-Bound Procedures procedure, public, pass(self) :: free_object Free dynamic memory. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. procedure, public, pass(self) :: print_version Print version. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character, intent(in), optional :: pref Prefixing string. procedure, public, pass(self) :: print_error_message Print meaningful error message. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. procedure, public, pass(self) :: set_examples Set examples of correct usage. private subroutine set_examples (self, examples) Set examples of correct usage. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. character, intent(in), optional :: examples (1:) Examples of correct usage. procedure, public, pass(lhs ) :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. procedure, public :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. procedure, public :: check Check data consistency. private subroutine check (self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. procedure, public :: is_required_passed Check if required CLA is passed. private function is_required_passed (self, pref) result(is_ok) Check if required CLA is passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Return Value logical Check result. procedure, public :: raise_error_m_exclude Raise error mutually exclusive CLAs passed. private subroutine raise_error_m_exclude (self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. procedure, public :: raise_error_nargs_insufficient Raise error insufficient number of argument values passed. private subroutine raise_error_nargs_insufficient (self, pref) Raise error insufficient number of argument values passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. procedure, public :: raise_error_value_missing Raise error missing value. private subroutine raise_error_value_missing (self, pref) Raise error missing value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. procedure, public :: raise_error_switch_unknown Raise error switch_unknown. private subroutine raise_error_switch_unknown (self, switch, pref) Raise error switch_unknown. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: switch CLA switch name. character, intent(in), optional :: pref Prefixing string. procedure, public :: raise_error_duplicated_clas Raise error duplicated CLAs passed. private subroutine raise_error_duplicated_clas (self, switch, pref) Raise error duplicated CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: switch CLA switch name. character, intent(in), optional :: pref Prefixing string. generic, public :: get => get_cla , get_cla_list Get CLA value(s). private subroutine get_cla (self, val, pref) Get CLA (single) value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(inout) :: val CLA value. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list (self, pref, val) Get CLA multiple values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. generic, public :: get_varying => get_cla_list_varying_R8P , get_cla_list_varying_R4P , get_cla_list_varying_I8P , get_cla_list_varying_I4P , get_cla_list_varying_I2P , get_cla_list_varying_I1P , get_cla_list_varying_logical , get_cla_list_varying_char Get CLA value(s) from varying size list. private subroutine get_cla_list_varying_R8P (self, val, pref) Get CLA (multiple) value with varying size, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_R4P (self, val, pref) Get CLA (multiple) value with varying size, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I8P (self, val, pref) Get CLA (multiple) value with varying size, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I4P (self, val, pref) Get CLA (multiple) value with varying size, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I2P (self, val, pref) Get CLA (multiple) value with varying size, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I1P (self, val, pref) Get CLA (multiple) value with varying size, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_logical (self, val, pref) Get CLA (multiple) value with varying size, logical. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. logical, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_char (self, val, pref) Get CLA (multiple) value with varying size, character. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. procedure, public :: has_choices Return true if CLA has defined choices. private pure function has_choices (self) Return true if CLA has choices. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLA data. Return Value logical Check result. procedure, public :: sanitize_defaults Sanitize default values. private subroutine sanitize_defaults (self) Sanitize defaults values. Read more… Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLAsG data. procedure, public :: signature Get signature. private function signature (self, bash_completion, plain) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLA data. logical, intent(in), optional :: bash_completion Return the signature for bash completion. logical, intent(in), optional :: plain Return the signature as plain switches list. Return Value character(len=:),allocatable Signature. procedure, public :: usage Get correct usage. private function usage (self, pref, markdown) Get correct usage. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLAs group data. character, intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: markdown Format for markdown Return Value character(len=:),allocatable Usage string. procedure, private :: errored Trig error occurence and print meaningful message. private subroutine errored (self, error, pref, switch, val_str, log_value) Trig error occurence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: error Error occurred. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: switch CLA switch name. character, intent(in), optional :: val_str Value string. character, intent(in), optional :: log_value Logical value to be casted. procedure, private :: check_envvar_consistency Check data consistency for envvar CLA. private subroutine check_envvar_consistency (self, pref) Check data consistency for envvar CLA. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. procedure, private :: check_action_consistency Check CLA action consistency. private subroutine check_action_consistency (self, pref) Check CLA action consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. procedure, private :: check_optional_consistency Check optional CLA consistency. private subroutine check_optional_consistency (self, pref) Check optional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. procedure, private :: check_m_exclude_consistency Check mutually exclusion consistency. private subroutine check_m_exclude_consistency (self, pref) Check mutually exclusion consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. procedure, private :: check_named_consistency Check named CLA consistency. private subroutine check_named_consistency (self, pref) Check named CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. procedure, private :: check_positional_consistency Check positional CLA consistency. private subroutine check_positional_consistency (self, pref) Check positional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. procedure, private :: check_choices Check if CLA value is in allowed choices. private subroutine check_choices (self, val, pref) Check if CLA value is in allowed choices. Read more… Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(in) :: val CLA value. character, intent(in), optional :: pref Prefixing string. procedure, private :: check_list_size Check CLA multiple values list size consistency. private function check_list_size (self, Nv, val, pref) result(is_ok) Check CLA multiple values list size consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character, intent(in) :: val First value. character, intent(in), optional :: pref Prefixing string. Return Value logical Check result. procedure, private :: get_cla Get CLA (single) value. private subroutine get_cla (self, val, pref) Get CLA (single) value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(inout) :: val CLA value. character, intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_from_buffer Get CLA (single) value from a buffer. private subroutine get_cla_from_buffer (self, buffer, val, pref) Get CLA (single) value from parsed value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val CLA value. character, intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list Get CLA multiple values. private subroutine get_cla_list (self, pref, val) Get CLA multiple values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. procedure, private :: get_cla_list_from_buffer Get CLA (single) value from a buffer. private subroutine get_cla_list_from_buffer (self, buffer, val, pref) Get CLA multiple values from a buffer. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val (1:) CLA value. character, intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_R16P Get CLA multiple values, varying size, R16P. private subroutine get_cla_list_varying_R16P (self, val, pref) Get CLA (multiple) value with varying size, real(R16P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values, varying size, R8P. private subroutine get_cla_list_varying_R8P (self, val, pref) Get CLA (multiple) value with varying size, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_R4P Get CLA multiple values, varying size, R4P. private subroutine get_cla_list_varying_R4P (self, val, pref) Get CLA (multiple) value with varying size, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_I8P Get CLA multiple values, varying size, I8P. private subroutine get_cla_list_varying_I8P (self, val, pref) Get CLA (multiple) value with varying size, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_I4P Get CLA multiple values, varying size, I4P. private subroutine get_cla_list_varying_I4P (self, val, pref) Get CLA (multiple) value with varying size, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_I2P Get CLA multiple values, varying size, I2P. private subroutine get_cla_list_varying_I2P (self, val, pref) Get CLA (multiple) value with varying size, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_I1P Get CLA multiple values, varying size, I1P. private subroutine get_cla_list_varying_I1P (self, val, pref) Get CLA (multiple) value with varying size, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_logical Get CLA multiple values, varying size, bool. private subroutine get_cla_list_varying_logical (self, val, pref) Get CLA (multiple) value with varying size, logical. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. logical, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_char Get CLA multiple values, varying size, char. private subroutine get_cla_list_varying_char (self, val, pref) Get CLA (multiple) value with varying size, character. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. procedure, private :: cla_assign_cla Assignment operator. private elemental subroutine cla_assign_cla (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: lhs Left hand side. type( command_line_argument ), intent(in) :: rhs Rigth hand side. generic, private :: assignment(=) => cla_assign_cla Assignment operator overloading. private elemental subroutine cla_assign_cla (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: lhs Left hand side. type( command_line_argument ), intent(in) :: rhs Rigth hand side. Source Code type , extends ( object ) :: command_line_argument !< Command Line Argument (CLA) class. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value. private character ( len = :), allocatable , public :: switch !< Switch name. character ( len = :), allocatable , public :: switch_ab !< Abbreviated switch name. logical , public :: is_required = . false . !< Flag for set required argument. logical , public :: is_positional = . false . !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), public :: position = 0_I4P !< Position of positional CLA. logical , public :: is_passed = . false . !< Flag for checking if CLA has been passed to CLI. logical , public :: is_hidden = . false . !< Flag for hiding CLA, thus it does not compare into help. character ( len = :), allocatable , public :: act !< CLA value action. character ( len = :), allocatable , public :: def !< Default value. character ( len = :), allocatable , public :: nargs !< Number of arguments consumed by CLA. character ( len = :), allocatable , public :: choices !< List (comma separated) of allowable values for the argument. character ( len = :), allocatable , public :: val !< CLA value. character ( len = :), allocatable , public :: envvar !< Environment variable from which take value. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: check !< Check data consistency. procedure , public :: is_required_passed !< Check if required CLA is passed. procedure , public :: raise_error_m_exclude !< Raise error mutually exclusive CLAs passed. procedure , public :: raise_error_nargs_insufficient !< Raise error insufficient number of argument values passed. procedure , public :: raise_error_value_missing !< Raise error missing value. procedure , public :: raise_error_switch_unknown !< Raise error switch_unknown. procedure , public :: raise_error_duplicated_clas !< Raise error duplicated CLAs passed. generic , public :: get => & get_cla , & get_cla_list !< Get CLA value(s). generic , public :: get_varying => & #if defined _R16P get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char !< Get CLA value(s) from varying size list. procedure , public :: has_choices !< Return true if CLA has defined choices. procedure , public :: sanitize_defaults !< Sanitize default values. procedure , public :: signature !< Get signature. procedure , public :: usage !< Get correct usage. ! private methods procedure , private :: errored !< Trig error occurence and print meaningful message. procedure , private :: check_envvar_consistency !< Check data consistency for envvar CLA. procedure , private :: check_action_consistency !< Check CLA action consistency. procedure , private :: check_optional_consistency !< Check optional CLA consistency. procedure , private :: check_m_exclude_consistency !< Check mutually exclusion consistency. procedure , private :: check_named_consistency !< Check named CLA consistency. procedure , private :: check_positional_consistency !< Check positional CLA consistency. procedure , private :: check_choices !< Check if CLA value is in allowed choices. procedure , private :: check_list_size !< Check CLA multiple values list size consistency. procedure , private :: get_cla !< Get CLA (single) value. procedure , private :: get_cla_from_buffer !< Get CLA (single) value from a buffer. procedure , private :: get_cla_list !< Get CLA multiple values. procedure , private :: get_cla_list_from_buffer !< Get CLA (single) value from a buffer. procedure , private :: get_cla_list_varying_R16P !< Get CLA multiple values, varying size, R16P. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values, varying size, char. procedure , private :: cla_assign_cla !< Assignment operator. generic , private :: assignment ( = ) => cla_assign_cla !< Assignment operator overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_argument","tags":"","loc":"type/command_line_argument.html"},{"title":"colorize_ascii – FLAP","text":"private pure function colorize_ascii(string, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, ASCII kind. Arguments Type Intent Optional Attributes Name character(kind=ASCII,len=*), intent(in) :: string Input string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(kind=ASCII,len=:),allocatable Colorized string. Calls proc~~colorize_ascii~~CallsGraph proc~colorize_ascii colorize_ascii proc~color_index color_index proc~colorize_ascii->proc~color_index proc~upper upper proc~colorize_ascii->proc~upper proc~style_index style_index proc~colorize_ascii->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code colorize_ascii Source Code pure function colorize_ascii ( string , color_fg , color_bg , style ) result ( colorized ) !< Colorize and stylize strings, ASCII kind. character ( len =* , kind = ASCII ), intent ( in ) :: string !< Input string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :, kind = ASCII ), allocatable :: colorized !< Colorized string. character ( len = :, kind = ASCII ), allocatable :: buffer !< Temporary buffer. integer ( int32 ) :: i !< Counter. colorized = string if ( present ( color_fg )) then i = color_index ( upper ( color_fg )) if ( i > 0 ) then buffer = CODE_START // trim ( COLORS_FG ( 2 , i )) // CODE_END colorized = buffer // colorized buffer = CODE_CLEAR colorized = colorized // buffer endif endif if ( present ( color_bg )) then i = color_index ( upper ( color_bg )) if ( i > 0 ) then buffer = CODE_START // trim ( COLORS_BG ( 2 , i )) // CODE_END colorized = buffer // colorized buffer = CODE_CLEAR colorized = colorized // buffer endif endif if ( present ( style )) then i = style_index ( upper ( style )) if ( i > 0 ) then buffer = CODE_START // trim ( STYLES ( 2 , i )) // CODE_END colorized = buffer // colorized buffer = CODE_CLEAR colorized = colorized // buffer endif endif endfunction colorize_ascii","tags":"","loc":"proc/colorize_ascii.html"},{"title":"colorize_default – FLAP","text":"private pure function colorize_default(string, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, DEFAULT kind. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:),allocatable Colorized string. Calls proc~~colorize_default~~CallsGraph proc~colorize_default colorize_default proc~color_index color_index proc~colorize_default->proc~color_index proc~upper upper proc~colorize_default->proc~upper proc~style_index style_index proc~colorize_default->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~colorize_default~~CalledByGraph proc~colorize_default colorize_default interface~colorize colorize interface~colorize->proc~colorize_default proc~colors_samples colors_samples proc~colors_samples->interface~colorize program~face_test_colors face_test_colors program~face_test_colors->interface~colorize proc~errored~2 errored proc~errored~2->interface~colorize proc~usage~3 usage proc~usage~3->interface~colorize proc~errored errored proc~errored->interface~colorize proc~styles_samples styles_samples proc~styles_samples->interface~colorize proc~errored~3 errored proc~errored~3->interface~colorize program~face_test_styles face_test_styles program~face_test_styles->interface~colorize program~face_test_basic face_test_basic program~face_test_basic->proc~colors_samples program~face_test_basic->proc~styles_samples Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code colorize_default Source Code pure function colorize_default ( string , color_fg , color_bg , style ) result ( colorized ) !< Colorize and stylize strings, DEFAULT kind. character ( len =* ), intent ( in ) :: string !< Input string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :), allocatable :: colorized !< Colorized string. integer ( int32 ) :: i !< Counter. colorized = string if ( present ( color_fg )) then i = color_index ( upper ( color_fg )) if ( i > 0 ) colorized = CODE_START // trim ( COLORS_FG ( 2 , i )) // CODE_END // colorized // CODE_CLEAR endif if ( present ( color_bg )) then i = color_index ( upper ( color_bg )) if ( i > 0 ) colorized = CODE_START // trim ( COLORS_BG ( 2 , i )) // CODE_END // colorized // CODE_CLEAR endif if ( present ( style )) then i = style_index ( upper ( style )) if ( i > 0 ) colorized = CODE_START // trim ( STYLES ( 2 , i )) // CODE_END // colorized // CODE_CLEAR endif endfunction colorize_default","tags":"","loc":"proc/colorize_default.html"},{"title":"colorize_ucs4 – FLAP","text":"private pure function colorize_ucs4(string, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, UCS4 kind. Arguments Type Intent Optional Attributes Name character(kind=UCS4,len=*), intent(in) :: string Input string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(kind=UCS4,len=:),allocatable Colorized string. Calls proc~~colorize_ucs4~~CallsGraph proc~colorize_ucs4 colorize_ucs4 proc~color_index color_index proc~colorize_ucs4->proc~color_index proc~upper upper proc~colorize_ucs4->proc~upper proc~style_index style_index proc~colorize_ucs4->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code colorize_ucs4 Source Code pure function colorize_ucs4 ( string , color_fg , color_bg , style ) result ( colorized ) !< Colorize and stylize strings, UCS4 kind. character ( len =* , kind = UCS4 ), intent ( in ) :: string !< Input string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :, kind = UCS4 ), allocatable :: colorized !< Colorized string. character ( len = :, kind = UCS4 ), allocatable :: buffer !< Temporary buffer. integer ( int32 ) :: i !< Counter. colorized = string if ( present ( color_fg )) then i = color_index ( upper ( color_fg )) if ( i > 0 ) then buffer = CODE_START // trim ( COLORS_FG ( 2 , i )) // CODE_END colorized = buffer // colorized buffer = CODE_CLEAR colorized = colorized // buffer endif endif if ( present ( color_bg )) then i = color_index ( upper ( color_bg )) if ( i > 0 ) then buffer = CODE_START // trim ( COLORS_BG ( 2 , i )) // CODE_END colorized = buffer // colorized buffer = CODE_CLEAR colorized = colorized // buffer endif endif if ( present ( style )) then i = style_index ( upper ( style )) if ( i > 0 ) then buffer = CODE_START // trim ( STYLES ( 2 , i )) // CODE_END colorized = buffer // colorized buffer = CODE_CLEAR colorized = colorized // buffer endif endif endfunction colorize_ucs4","tags":"","loc":"proc/colorize_ucs4.html"},{"title":"color_index – FLAP","text":"private elemental function color_index(color) Return the array-index corresponding to the queried color. Note Because Foreground and backround colors lists share the same name, no matter what array is used to find the color index.\nThus, the foreground array is used. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: color Color definition. Return Value integer(kind=int32) Index into the colors arrays. Called by proc~~color_index~~CalledByGraph proc~color_index color_index proc~colorize_ascii colorize_ascii proc~colorize_ascii->proc~color_index proc~colorize_default colorize_default proc~colorize_default->proc~color_index proc~colorize_ucs4 colorize_ucs4 proc~colorize_ucs4->proc~color_index interface~colorize colorize interface~colorize->proc~colorize_default proc~colors_samples colors_samples proc~colors_samples->interface~colorize program~face_test_colors face_test_colors program~face_test_colors->interface~colorize proc~errored~2 errored proc~errored~2->interface~colorize proc~usage~3 usage proc~usage~3->interface~colorize proc~errored errored proc~errored->interface~colorize proc~styles_samples styles_samples proc~styles_samples->interface~colorize proc~errored~3 errored proc~errored~3->interface~colorize program~face_test_styles face_test_styles program~face_test_styles->interface~colorize program~face_test_basic face_test_basic program~face_test_basic->proc~colors_samples program~face_test_basic->proc~styles_samples Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code color_index Source Code elemental function color_index ( color ) !< Return the array-index corresponding to the queried color. !< !< @note Because Foreground and backround colors lists share the same name, no matter what array is used to find the color index. !< Thus, the foreground array is used. character ( len =* ), intent ( in ) :: color !< Color definition. integer ( int32 ) :: color_index !< Index into the colors arrays. integer ( int32 ) :: c !< Counter. color_index = 0 do c = 1 , size ( COLORS_FG , dim = 2 ) if ( trim ( COLORS_FG ( 1 , c )) == trim ( adjustl ( color ))) then color_index = c exit endif enddo endfunction color_index","tags":"","loc":"proc/color_index.html"},{"title":"style_index – FLAP","text":"private elemental function style_index(style) Return the array-index corresponding to the queried style. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: style Style definition. Return Value integer(kind=int32) Index into the styles array. Called by proc~~style_index~~CalledByGraph proc~style_index style_index proc~colorize_ascii colorize_ascii proc~colorize_ascii->proc~style_index proc~colorize_default colorize_default proc~colorize_default->proc~style_index proc~colorize_ucs4 colorize_ucs4 proc~colorize_ucs4->proc~style_index interface~colorize colorize interface~colorize->proc~colorize_default proc~colors_samples colors_samples proc~colors_samples->interface~colorize program~face_test_colors face_test_colors program~face_test_colors->interface~colorize proc~errored~2 errored proc~errored~2->interface~colorize proc~usage~3 usage proc~usage~3->interface~colorize proc~errored errored proc~errored->interface~colorize proc~styles_samples styles_samples proc~styles_samples->interface~colorize proc~errored~3 errored proc~errored~3->interface~colorize program~face_test_styles face_test_styles program~face_test_styles->interface~colorize program~face_test_basic face_test_basic program~face_test_basic->proc~colors_samples program~face_test_basic->proc~styles_samples Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code style_index Source Code elemental function style_index ( style ) !< Return the array-index corresponding to the queried style. character ( len =* ), intent ( in ) :: style !< Style definition. integer ( int32 ) :: style_index !< Index into the styles array. integer ( int32 ) :: s !< Counter. style_index = 0 do s = 1 , size ( STYLES , dim = 2 ) if ( trim ( STYLES ( 1 , s )) == trim ( adjustl ( style ))) then style_index = s exit endif enddo endfunction style_index","tags":"","loc":"proc/style_index.html"},{"title":"upper – FLAP","text":"private elemental function upper(string) Return a string with all uppercase characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input string. Return Value character(len=len) Upper case string. Called by proc~~upper~~CalledByGraph proc~upper upper proc~colorize_ascii colorize_ascii proc~colorize_ascii->proc~upper proc~colorize_default colorize_default proc~colorize_default->proc~upper proc~colorize_ucs4 colorize_ucs4 proc~colorize_ucs4->proc~upper interface~colorize colorize interface~colorize->proc~colorize_default proc~colors_samples colors_samples proc~colors_samples->interface~colorize program~face_test_colors face_test_colors program~face_test_colors->interface~colorize proc~errored~2 errored proc~errored~2->interface~colorize proc~usage~3 usage proc~usage~3->interface~colorize proc~errored errored proc~errored->interface~colorize proc~styles_samples styles_samples proc~styles_samples->interface~colorize proc~errored~3 errored proc~errored~3->interface~colorize program~face_test_styles face_test_styles program~face_test_styles->interface~colorize program~face_test_basic face_test_basic program~face_test_basic->proc~colors_samples program~face_test_basic->proc~styles_samples Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code upper Source Code elemental function upper ( string ) !< Return a string with all uppercase characters. character ( len =* ), intent ( in ) :: string !< Input string. character ( len = len ( string )) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. upper = string do n1 = 1 , len ( string ) n2 = index ( LOWER_ALPHABET , string ( n1 : n1 )) if ( n2 > 0 ) upper ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endfunction upper","tags":"","loc":"proc/upper.html"},{"title":"colors_samples – FLAP","text":"public subroutine colors_samples() Print to standard output all colors samples. Arguments None Calls proc~~colors_samples~~CallsGraph proc~colors_samples colors_samples interface~colorize colorize proc~colors_samples->interface~colorize proc~colorize_default colorize_default interface~colorize->proc~colorize_default proc~color_index color_index proc~colorize_default->proc~color_index proc~upper upper proc~colorize_default->proc~upper proc~style_index style_index proc~colorize_default->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~colors_samples~~CalledByGraph proc~colors_samples colors_samples program~face_test_basic face_test_basic program~face_test_basic->proc~colors_samples Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code colors_samples Source Code subroutine colors_samples () !< Print to standard output all colors samples. integer ( int32 ) :: c !< Counter. print '(A)' , colorize ( 'Foreground colors samples' , color_fg = 'red_intense' ) do c = 1 , size ( COLORS_FG , dim = 2 ) print '(A)' , '  colorize(\"' // COLORS_FG ( 1 , c ) // '\", color_fg=\"' // COLORS_FG ( 1 , c ) // '\") => ' // & colorize ( COLORS_FG ( 1 , c ), color_fg = COLORS_FG ( 1 , c )) // & ' code: ' // colorize ( trim ( COLORS_FG ( 2 , c )), color_fg = COLORS_FG ( 1 , c ), style = 'inverse_on' ) enddo print '(A)' , colorize ( 'Background colors samples' , color_fg = 'red_intense' ) do c = 1 , size ( COLORS_BG , dim = 2 ) print '(A)' , '  colorize(\"' // COLORS_BG ( 1 , c ) // '\", color_bg=\"' // COLORS_BG ( 1 , c ) // '\") => ' // & colorize ( COLORS_BG ( 1 , c ), color_bg = COLORS_BG ( 1 , c )) // & ' code: ' // colorize ( trim ( COLORS_BG ( 2 , c )), color_bg = COLORS_BG ( 1 , c ), style = 'inverse_on' ) enddo endsubroutine colors_samples","tags":"","loc":"proc/colors_samples.html"},{"title":"styles_samples – FLAP","text":"public subroutine styles_samples() Print to standard output all styles samples. Arguments None Calls proc~~styles_samples~~CallsGraph proc~styles_samples styles_samples interface~colorize colorize proc~styles_samples->interface~colorize proc~colorize_default colorize_default interface~colorize->proc~colorize_default proc~color_index color_index proc~colorize_default->proc~color_index proc~upper upper proc~colorize_default->proc~upper proc~style_index style_index proc~colorize_default->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~styles_samples~~CalledByGraph proc~styles_samples styles_samples program~face_test_basic face_test_basic program~face_test_basic->proc~styles_samples Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code styles_samples Source Code subroutine styles_samples () !< Print to standard output all styles samples. integer ( int32 ) :: s !< Counter. print '(A)' , colorize ( 'Styles samples' , color_fg = 'red_intense' ) do s = 1 , size ( STYLES , dim = 2 ) print '(A)' , '  colorize(\"' // STYLES ( 1 , s ) // '\", style=\"' // STYLES ( 1 , s ) // '\") => ' // & colorize ( STYLES ( 1 , s ), style = STYLES ( 1 , s )) // & ' code: ' // colorize ( trim ( STYLES ( 2 , s )), color_fg = 'magenta' , style = 'inverse_on' ) enddo endsubroutine styles_samples","tags":"","loc":"proc/styles_samples.html"},{"title":"colorize – FLAP","text":"public interface colorize Calls interface~~colorize~~CallsGraph interface~colorize colorize proc~colorize_default colorize_default interface~colorize->proc~colorize_default proc~color_index color_index proc~colorize_default->proc~color_index proc~upper upper proc~colorize_default->proc~upper proc~style_index style_index proc~colorize_default->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~colorize~~CalledByGraph interface~colorize colorize proc~colors_samples colors_samples proc~colors_samples->interface~colorize program~face_test_colors face_test_colors program~face_test_colors->interface~colorize proc~errored~2 errored proc~errored~2->interface~colorize proc~usage~3 usage proc~usage~3->interface~colorize proc~errored errored proc~errored->interface~colorize proc~styles_samples styles_samples proc~styles_samples->interface~colorize proc~errored~3 errored proc~errored~3->interface~colorize program~face_test_styles face_test_styles program~face_test_styles->interface~colorize program~face_test_basic face_test_basic program~face_test_basic->proc~colors_samples program~face_test_basic->proc~styles_samples Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures colorize_default Module Procedures private pure function colorize_default (string, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, DEFAULT kind. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:),allocatable Colorized string.","tags":"","loc":"interface/colorize.html"},{"title":"init – FLAP","text":"private subroutine init(this, tolerance32, tolerance64) Initialize the tester. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(out) :: this The tester. real(kind=real32), intent(in), optional :: tolerance32 Real tolerance, 32 bits. real(kind=real64), intent(in), optional :: tolerance64 Real tolerance, 64 bits. Contents Source Code init Source Code subroutine init ( this , tolerance32 , tolerance64 ) class ( tester_t ), intent ( out ) :: this !< The tester. real ( real32 ), intent ( in ), optional :: tolerance32 !< Real tolerance, 32 bits. real ( real64 ), intent ( in ), optional :: tolerance64 !< Real tolerance, 64 bits. this % n_errors = 0 this % n_tests = 0 if ( present ( tolerance64 )) then this % tolerance64 = tolerance64 else this % tolerance64 = 2._real64 * epsilon ( 1._real64 ) end if if ( present ( tolerance32 )) then this % tolerance32 = tolerance32 else this % tolerance32 = 2._real32 * epsilon ( 1._real32 ) end if end subroutine init","tags":"","loc":"proc/init.html"},{"title":"print – FLAP","text":"private subroutine print(this, errorstop) Print tests results. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(in) :: this The tester. logical, intent(in), optional :: errorstop Flag to activate error stop if one test fails. Contents Source Code print Source Code subroutine print ( this , errorstop ) class ( tester_t ), intent ( in ) :: this !< The tester. logical , intent ( in ), optional :: errorstop !< Flag to activate error stop if one test fails. logical :: do_errorstop if ( present ( errorstop )) then do_errorstop = errorstop else do_errorstop = . true . end if write ( * , * ) 'fortran_tester:' , this % n_errors , ' error(s) for' , this % n_tests , 'test(s)' if ( this % n_errors == 0 ) then write ( * , * ) 'fortran_tester: all tests succeeded' else write ( * , * ) 'fortran_tester: tests failed' if ( do_errorstop ) then stop 1 end if end if end subroutine print","tags":"","loc":"proc/print.html"},{"title":"assert_equal_i8 – FLAP","text":"private subroutine assert_equal_i8(this, i1, i2) Check if two integers (8 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i1 Value to compare. integer(kind=int8), intent(in) :: i2 Value to compare. Contents Source Code assert_equal_i8 Source Code subroutine assert_equal_i8 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), intent ( in ) :: i1 !< Value to compare. integer ( int8 ), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_i8","tags":"","loc":"proc/assert_equal_i8.html"},{"title":"assert_equal_i16 – FLAP","text":"private subroutine assert_equal_i16(this, i1, i2) Check if two integers (16 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i1 Value to compare. integer(kind=int16), intent(in) :: i2 Value to compare. Contents Source Code assert_equal_i16 Source Code subroutine assert_equal_i16 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), intent ( in ) :: i1 !< Value to compare. integer ( int16 ), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_i16","tags":"","loc":"proc/assert_equal_i16.html"},{"title":"assert_equal_i32 – FLAP","text":"private subroutine assert_equal_i32(this, i1, i2) Check if two integers (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i1 Value to compare. integer(kind=int32), intent(in) :: i2 Value to compare. Contents Source Code assert_equal_i32 Source Code subroutine assert_equal_i32 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), intent ( in ) :: i1 !< Value to compare. integer ( int32 ), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_i32","tags":"","loc":"proc/assert_equal_i32.html"},{"title":"assert_equal_i64 – FLAP","text":"private subroutine assert_equal_i64(this, i1, i2) Check if two integers (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i1 Value to compare. integer(kind=int64), intent(in) :: i2 Value to compare. Contents Source Code assert_equal_i64 Source Code subroutine assert_equal_i64 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), intent ( in ) :: i1 !< Value to compare. integer ( int64 ), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_i64","tags":"","loc":"proc/assert_equal_i64.html"},{"title":"assert_equal_r32 – FLAP","text":"private subroutine assert_equal_r32(this, r1, r2) Check if two reals (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Value to compare. real(kind=real32), intent(in) :: r2 Value to compare. Contents Source Code assert_equal_r32 Source Code subroutine assert_equal_r32 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ) :: r1 !< Value to compare. real ( real32 ), intent ( in ) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( r1 . ne . r2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_r32","tags":"","loc":"proc/assert_equal_r32.html"},{"title":"assert_equal_r64 – FLAP","text":"private subroutine assert_equal_r64(this, r1, r2) Check if two reals (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Value to compare. real(kind=real64), intent(in) :: r2 Value to compare. Contents Source Code assert_equal_r64 Source Code subroutine assert_equal_r64 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ) :: r1 !< Value to compare. real ( real64 ), intent ( in ) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( r1 . ne . r2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_r64","tags":"","loc":"proc/assert_equal_r64.html"},{"title":"assert_equal_c32 – FLAP","text":"private subroutine assert_equal_c32(this, c1, c2) Check if two complex numbers (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in) :: c1 Value to compare. complex(kind=real32), intent(in) :: c2 Value to compare. Contents Source Code assert_equal_c32 Source Code subroutine assert_equal_c32 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real32 ), intent ( in ) :: c1 !< Value to compare. complex ( real32 ), intent ( in ) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( c1 . ne . c2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_c32","tags":"","loc":"proc/assert_equal_c32.html"},{"title":"assert_equal_c64 – FLAP","text":"private subroutine assert_equal_c64(this, c1, c2) Check if two complex numbers (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in) :: c1 Value to compare. complex(kind=real64), intent(in) :: c2 Value to compare. Contents Source Code assert_equal_c64 Source Code subroutine assert_equal_c64 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real64 ), intent ( in ) :: c1 !< Value to compare. complex ( real64 ), intent ( in ) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( c1 . ne . c2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_c64","tags":"","loc":"proc/assert_equal_c64.html"},{"title":"assert_equal_l – FLAP","text":"private subroutine assert_equal_l(this, l1, l2) Check if two logicals are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in) :: l1 Value to compare. logical, intent(in) :: l2 Value to compare. Contents Source Code assert_equal_l Source Code subroutine assert_equal_l ( this , l1 , l2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. logical , intent ( in ) :: l1 !< Value to compare. logical , intent ( in ) :: l2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( l1 . neqv . l2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_l","tags":"","loc":"proc/assert_equal_l.html"},{"title":"assert_equal_i8_1 – FLAP","text":"private subroutine assert_equal_i8_1(this, i1, i2) Check if two integer (8 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int8), intent(in), dimension(:) :: i2 Value to compare. Contents Source Code assert_equal_i8_1 Source Code subroutine assert_equal_i8_1 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), dimension (:), intent ( in ) :: i1 !< Value to compare. integer ( int8 ), dimension (:), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( i1 - i2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i8_1","tags":"","loc":"proc/assert_equal_i8_1.html"},{"title":"assert_equal_i16_1 – FLAP","text":"private subroutine assert_equal_i16_1(this, i1, i2) Check if two integer (16 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int16), intent(in), dimension(:) :: i2 Value to compare. Contents Source Code assert_equal_i16_1 Source Code subroutine assert_equal_i16_1 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), dimension (:), intent ( in ) :: i1 !< Value to compare. integer ( int16 ), dimension (:), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( i1 - i2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i16_1","tags":"","loc":"proc/assert_equal_i16_1.html"},{"title":"assert_equal_i32_1 – FLAP","text":"private subroutine assert_equal_i32_1(this, i1, i2) Check if two integer (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int32), intent(in), dimension(:) :: i2 Value to compare. Contents Source Code assert_equal_i32_1 Source Code subroutine assert_equal_i32_1 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), dimension (:), intent ( in ) :: i1 !< Value to compare. integer ( int32 ), dimension (:), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( i1 - i2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i32_1","tags":"","loc":"proc/assert_equal_i32_1.html"},{"title":"assert_equal_i64_1 – FLAP","text":"private subroutine assert_equal_i64_1(this, i1, i2) Check if two integer (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int64), intent(in), dimension(:) :: i2 Value to compare. Contents Source Code assert_equal_i64_1 Source Code subroutine assert_equal_i64_1 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), dimension (:), intent ( in ) :: i1 !< Value to compare. integer ( int64 ), dimension (:), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( i1 - i2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i64_1","tags":"","loc":"proc/assert_equal_i64_1.html"},{"title":"assert_equal_r32_1 – FLAP","text":"private subroutine assert_equal_r32_1(this, r1, r2) Check if two real (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Value to compare. real(kind=real32), intent(in), dimension(:) :: r2 Value to compare. Contents Source Code assert_equal_r32_1 Source Code subroutine assert_equal_r32_1 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), dimension (:), intent ( in ) :: r1 !< Value to compare. real ( real32 ), dimension (:), intent ( in ) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( r1 - r2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_r32_1","tags":"","loc":"proc/assert_equal_r32_1.html"},{"title":"assert_equal_r64_1 – FLAP","text":"private subroutine assert_equal_r64_1(this, r1, r2) Check if two real (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Value to compare. real(kind=real64), intent(in), dimension(:) :: r2 Value to compare. Contents Source Code assert_equal_r64_1 Source Code subroutine assert_equal_r64_1 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), dimension (:), intent ( in ) :: r1 !< Value to compare. real ( real64 ), dimension (:), intent ( in ) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( r1 - r2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_r64_1","tags":"","loc":"proc/assert_equal_r64_1.html"},{"title":"assert_equal_c32_1 – FLAP","text":"private subroutine assert_equal_c32_1(this, c1, c2) Check if two complex (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real32), intent(in), dimension(:) :: c2 Value to compare. Contents Source Code assert_equal_c32_1 Source Code subroutine assert_equal_c32_1 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real32 ), dimension (:), intent ( in ) :: c1 !< Value to compare. complex ( real32 ), dimension (:), intent ( in ) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( c1 ) . ne . size ( c2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( c1 - c2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_c32_1","tags":"","loc":"proc/assert_equal_c32_1.html"},{"title":"assert_equal_c64_1 – FLAP","text":"private subroutine assert_equal_c64_1(this, c1, c2) Check if two complex (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real64), intent(in), dimension(:) :: c2 Value to compare. Contents Source Code assert_equal_c64_1 Source Code subroutine assert_equal_c64_1 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real64 ), dimension (:), intent ( in ) :: c1 !< Value to compare. complex ( real64 ), dimension (:), intent ( in ) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( c1 ) . ne . size ( c2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( c1 - c2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_c64_1","tags":"","loc":"proc/assert_equal_c64_1.html"},{"title":"assert_equal_l_1 – FLAP","text":"private subroutine assert_equal_l_1(this, l1, l2) Check if two logical arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in), dimension(:) :: l1 Value to compare. logical, intent(in), dimension(:) :: l2 Value to compare. Contents Source Code assert_equal_l_1 Source Code subroutine assert_equal_l_1 ( this , l1 , l2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. logical , intent ( in ), dimension (:) :: l1 !< Value to compare. logical , intent ( in ), dimension (:) :: l2 !< Value to compare. integer :: k this % n_tests = this % n_tests + 1 if ( size ( l1 ) . ne . size ( l2 ) ) then this % n_errors = this % n_errors + 1 else do k = 1 , size ( l1 ) if ( l1 ( k ) . neqv . l2 ( k )) then this % n_errors = this % n_errors + 1 exit end if end do end if end subroutine assert_equal_l_1","tags":"","loc":"proc/assert_equal_l_1.html"},{"title":"assert_positive_i8 – FLAP","text":"private subroutine assert_positive_i8(this, i) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i Value to check. Contents Source Code assert_positive_i8 Source Code subroutine assert_positive_i8 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( i < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i8","tags":"","loc":"proc/assert_positive_i8.html"},{"title":"assert_positive_i16 – FLAP","text":"private subroutine assert_positive_i16(this, i) Check if a integer (16 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i Value to check. Contents Source Code assert_positive_i16 Source Code subroutine assert_positive_i16 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( i < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i16","tags":"","loc":"proc/assert_positive_i16.html"},{"title":"assert_positive_i32 – FLAP","text":"private subroutine assert_positive_i32(this, i) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i Value to check. Contents Source Code assert_positive_i32 Source Code subroutine assert_positive_i32 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( i < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i32","tags":"","loc":"proc/assert_positive_i32.html"},{"title":"assert_positive_i64 – FLAP","text":"private subroutine assert_positive_i64(this, i) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i Value to check. Contents Source Code assert_positive_i64 Source Code subroutine assert_positive_i64 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( i < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i64","tags":"","loc":"proc/assert_positive_i64.html"},{"title":"assert_positive_r32 – FLAP","text":"private subroutine assert_positive_r32(this, r) Check if a real (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r Value to check. Contents Source Code assert_positive_r32 Source Code subroutine assert_positive_r32 ( this , r ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ) :: r !< Value to check. this % n_tests = this % n_tests + 1 if ( r < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_r32","tags":"","loc":"proc/assert_positive_r32.html"},{"title":"assert_positive_r64 – FLAP","text":"private subroutine assert_positive_r64(this, r) Check if a real (64 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r Value to check. Contents Source Code assert_positive_r64 Source Code subroutine assert_positive_r64 ( this , r ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ) :: r !< Value to check. this % n_tests = this % n_tests + 1 if ( r < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_r64","tags":"","loc":"proc/assert_positive_r64.html"},{"title":"assert_positive_i8_1 – FLAP","text":"private subroutine assert_positive_i8_1(this, i) Check if a integer (8 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i Value to check. Contents Source Code assert_positive_i8_1 Source Code subroutine assert_positive_i8_1 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), dimension (:), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i8_1","tags":"","loc":"proc/assert_positive_i8_1.html"},{"title":"assert_positive_i16_1 – FLAP","text":"private subroutine assert_positive_i16_1(this, i) Check if a integer (16 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i Value to check. Contents Source Code assert_positive_i16_1 Source Code subroutine assert_positive_i16_1 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), dimension (:), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i16_1","tags":"","loc":"proc/assert_positive_i16_1.html"},{"title":"assert_positive_i32_1 – FLAP","text":"private subroutine assert_positive_i32_1(this, i) Check if a integer (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i Value to check. Contents Source Code assert_positive_i32_1 Source Code subroutine assert_positive_i32_1 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), dimension (:), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i32_1","tags":"","loc":"proc/assert_positive_i32_1.html"},{"title":"assert_positive_i64_1 – FLAP","text":"private subroutine assert_positive_i64_1(this, i) Check if a integer (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i Value to check. Contents Source Code assert_positive_i64_1 Source Code subroutine assert_positive_i64_1 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), dimension (:), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i64_1","tags":"","loc":"proc/assert_positive_i64_1.html"},{"title":"assert_positive_r32_1 – FLAP","text":"private subroutine assert_positive_r32_1(this, r) Check if a real (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r Value to check. Contents Source Code assert_positive_r32_1 Source Code subroutine assert_positive_r32_1 ( this , r ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), dimension (:), intent ( in ) :: r !< Value to check. this % n_tests = this % n_tests + 1 if ( minval ( r ) < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_r32_1","tags":"","loc":"proc/assert_positive_r32_1.html"},{"title":"assert_positive_r64_1 – FLAP","text":"private subroutine assert_positive_r64_1(this, r) Check if a real (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r Value to check. Contents Source Code assert_positive_r64_1 Source Code subroutine assert_positive_r64_1 ( this , r ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), dimension (:), intent ( in ) :: r !< Value to check. this % n_tests = this % n_tests + 1 if ( minval ( r ) < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_r64_1","tags":"","loc":"proc/assert_positive_r64_1.html"},{"title":"assert_close_r32 – FLAP","text":"private subroutine assert_close_r32(this, r1, r2) Check if two reals (32 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Value to compare. real(kind=real32), intent(in) :: r2 Value to compare. Contents Source Code assert_close_r32 Source Code subroutine assert_close_r32 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ) :: r1 !< Value to compare. real ( real32 ), intent ( in ) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( abs ( r1 - r2 ) > this % tolerance32 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_close_r32","tags":"","loc":"proc/assert_close_r32.html"},{"title":"assert_close_r64 – FLAP","text":"private subroutine assert_close_r64(this, r1, r2) Check if two reals (64 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Value to compare. real(kind=real64), intent(in) :: r2 Value to compare. Contents Source Code assert_close_r64 Source Code subroutine assert_close_r64 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ) :: r1 !< Value to compare. real ( real64 ), intent ( in ) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( abs ( r1 - r2 ) > this % tolerance64 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_close_r64","tags":"","loc":"proc/assert_close_r64.html"},{"title":"assert_close_r32_1 – FLAP","text":"private subroutine assert_close_r32_1(this, r1, r2) Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Value to compare. real(kind=real32), intent(in), dimension(:) :: r2 Value to compare. Contents Source Code assert_close_r32_1 Source Code subroutine assert_close_r32_1 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ), dimension (:) :: r1 !< Value to compare. real ( real32 ), intent ( in ), dimension (:) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( r1 - r2 )) > this % tolerance32 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_close_r32_1","tags":"","loc":"proc/assert_close_r32_1.html"},{"title":"assert_close_r64_1 – FLAP","text":"private subroutine assert_close_r64_1(this, r1, r2) Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Value to compare. real(kind=real64), intent(in), dimension(:) :: r2 Value to compare. Contents Source Code assert_close_r64_1 Source Code subroutine assert_close_r64_1 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ), dimension (:) :: r1 !< Value to compare. real ( real64 ), intent ( in ), dimension (:) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( r1 - r2 )) > this % tolerance64 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_close_r64_1","tags":"","loc":"proc/assert_close_r64_1.html"},{"title":"assert_close_c32 – FLAP","text":"private subroutine assert_close_c32(this, c1, c2) Check if two complex numbers (32 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in) :: c1 Value to compare. complex(kind=real32), intent(in) :: c2 Value to compare. Contents Source Code assert_close_c32 Source Code subroutine assert_close_c32 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real32 ), intent ( in ) :: c1 !< Value to compare. complex ( real32 ), intent ( in ) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( abs ( c1 - c2 ) > this % tolerance32 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_close_c32","tags":"","loc":"proc/assert_close_c32.html"},{"title":"assert_close_c64 – FLAP","text":"private subroutine assert_close_c64(this, r1, c2) Check if two complex numbers (64 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in) :: r1 Value to compare. complex(kind=real64), intent(in) :: c2 Value to compare. Contents Source Code assert_close_c64 Source Code subroutine assert_close_c64 ( this , r1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real64 ), intent ( in ) :: r1 !< Value to compare. complex ( real64 ), intent ( in ) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( abs ( r1 - c2 ) > this % tolerance64 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_close_c64","tags":"","loc":"proc/assert_close_c64.html"},{"title":"assert_close_c32_1 – FLAP","text":"private subroutine assert_close_c32_1(this, c1, c2) Check if two complex (32 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real32), intent(in), dimension(:) :: c2 Value to compare. Contents Source Code assert_close_c32_1 Source Code subroutine assert_close_c32_1 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real32 ), intent ( in ), dimension (:) :: c1 !< Value to compare. complex ( real32 ), intent ( in ), dimension (:) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( c1 ) . ne . size ( c2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( c1 - c2 )) > this % tolerance32 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_close_c32_1","tags":"","loc":"proc/assert_close_c32_1.html"},{"title":"assert_close_c64_1 – FLAP","text":"private subroutine assert_close_c64_1(this, c1, c2) Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real64), intent(in), dimension(:) :: c2 Value to compare. Contents Source Code assert_close_c64_1 Source Code subroutine assert_close_c64_1 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real64 ), intent ( in ), dimension (:) :: c1 !< Value to compare. complex ( real64 ), intent ( in ), dimension (:) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( c1 ) . ne . size ( c2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( c1 - c2 )) > this % tolerance64 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_close_c64_1","tags":"","loc":"proc/assert_close_c64_1.html"},{"title":"fake_call – FLAP","text":"subroutine fake_call(args, spectrum, domain, grid) Wrapper for fake calls. Arguments Type Intent Optional Attributes Name character, intent(in) :: args Fake arguments. logical, intent(out) :: spectrum Spectrum value. logical, intent(out) :: domain Domain value. logical, intent(out) :: grid Grid value. Called by proc~~fake_call~~CalledByGraph proc~fake_call fake_call program~flap_test_group flap_test_group program~flap_test_group->proc~fake_call Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fake_call Source Code subroutine fake_call ( args , spectrum , domain , grid ) !--------------------------------------------------------------------------------------------------------------------------------- !< Wrapper for fake calls. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: args !< Fake arguments. logical , intent ( out ) :: spectrum !< Spectrum value. logical , intent ( out ) :: domain !< Domain value. logical , intent ( out ) :: grid !< Grid value. type ( command_line_interface ) :: cli !< Command Line Interface (CLI). integer ( I4P ) :: error !< Error trapping flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % init call cli % add_group ( group = 'new' , description = 'create new instance' ) call cli % add ( group = 'new' , switch = '--spectrum' , switch_ab = '-s' , & help = 'Create new spectrum' , required = . false ., def = '.false.' , & act = 'store_true' , error = error ) if ( error /= 0 ) stop call cli % add ( group = 'new' , switch = '--domain' , switch_ab = '-d' , & help = 'Create new domain' , required = . false ., def = '.false.' , & act = 'store_true' , error = error ) if ( error /= 0 ) stop call cli % add ( group = 'new' , switch = '--grid' , switch_ab = '-g' , & help = 'Create new grid' , required = . false ., def = '.false.' , & act = 'store_true' , error = error ) if ( error /= 0 ) stop call cli % parse ( args = args , error = error ) if ( error /= 0 ) stop call cli % get ( group = 'new' , switch = '--spectrum' , val = spectrum , error = error ) if ( error /= 0 ) stop call cli % get ( group = 'new' , switch = '--domain' , val = domain , error = error ) if ( error /= 0 ) stop call cli % get ( group = 'new' , switch = '--grid' , val = grid , error = error ) if ( error /= 0 ) stop !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine fake_call","tags":"","loc":"proc/fake_call.html"},{"title":"free_object – FLAP","text":"private elemental subroutine free_object(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. Contents Source Code free_object Source Code elemental subroutine free_object ( self ) !< Free dynamic memory. class ( object ), intent ( inout ) :: self !< Object data. if ( allocated ( self % progname )) deallocate ( self % progname ) if ( allocated ( self % version )) deallocate ( self % version ) if ( allocated ( self % help )) deallocate ( self % help ) if ( allocated ( self % help_color )) deallocate ( self % help_color ) if ( allocated ( self % help_style )) deallocate ( self % help_style ) if ( allocated ( self % help_markdown )) deallocate ( self % help_markdown ) if ( allocated ( self % description )) deallocate ( self % description ) if ( allocated ( self % license )) deallocate ( self % license ) if ( allocated ( self % authors )) deallocate ( self % authors ) if ( allocated ( self % epilog )) deallocate ( self % epilog ) if ( allocated ( self % m_exclude )) deallocate ( self % m_exclude ) if ( allocated ( self % error_message )) deallocate ( self % error_message ) if ( allocated ( self % error_color )) deallocate ( self % error_color ) if ( allocated ( self % error_style )) deallocate ( self % error_style ) self % error = 0_I4P self % usage_lun = stderr self % version_lun = stdout self % error_lun = stderr endsubroutine free_object","tags":"","loc":"proc/free_object.html"},{"title":"print_version – FLAP","text":"private subroutine print_version(self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character, intent(in), optional :: pref Prefixing string. Contents Source Code print_version Source Code subroutine print_version ( self , pref ) !< Print version. class ( object ), intent ( in ) :: self !< Object data. character ( * ), intent ( in ), optional :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. prefd = '' ; if ( present ( pref )) prefd = pref write ( self % version_lun , '(A)' ) prefd // self % progname // ' version ' // self % version if ( self % license /= '' ) then write ( self % version_lun , '(A)' ) prefd // self % license endif if ( self % authors /= '' ) then write ( self % version_lun , '(A)' ) prefd // self % authors endif endsubroutine print_version","tags":"","loc":"proc/print_version.html"},{"title":"print_error_message – FLAP","text":"private subroutine print_error_message(self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. Contents Source Code print_error_message Source Code subroutine print_error_message ( self ) !< Print meaningful error message to standard-error. class ( object ), intent ( in ) :: self !< Object data. write ( self % error_lun , '(A)' ) self % error_message write ( self % error_lun , '(A)' ) endsubroutine print_error_message","tags":"","loc":"proc/print_error_message.html"},{"title":"set_examples – FLAP","text":"private subroutine set_examples(self, examples) Set examples of correct usage. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. character, intent(in), optional :: examples (1:) Examples of correct usage. Contents Source Code set_examples Source Code subroutine set_examples ( self , examples ) !< Set examples of correct usage. class ( object ), intent ( inout ) :: self !< Object data. character ( * ), optional , intent ( in ) :: examples ( 1 :) !< Examples of correct usage. if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( self % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: self % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif self % examples = examples endif endsubroutine set_examples","tags":"","loc":"proc/set_examples.html"},{"title":"assign_object – FLAP","text":"private elemental subroutine assign_object(lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. Contents Source Code assign_object Source Code elemental subroutine assign_object ( lhs , rhs ) !< Assign two abstract objects. class ( object ), intent ( inout ) :: lhs !< Left hand side. class ( object ), intent ( in ) :: rhs !< Rigth hand side. if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % help_color )) lhs % help_color = rhs % help_color if ( allocated ( rhs % help_style )) lhs % help_style = rhs % help_style if ( allocated ( rhs % help_markdown )) lhs % help_markdown = rhs % help_markdown if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude if ( allocated ( rhs % error_message )) lhs % error_message = rhs % error_message if ( allocated ( rhs % error_color )) lhs % error_color = rhs % error_color if ( allocated ( rhs % error_style )) lhs % error_style = rhs % error_style lhs % error = rhs % error lhs % usage_lun = rhs % usage_lun lhs % version_lun = rhs % version_lun lhs % error_lun = rhs % error_lun endsubroutine assign_object","tags":"","loc":"proc/assign_object.html"},{"title":"is_passed – FLAP","text":"private pure function is_passed(self, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Contents Source Code is_passed Source Code pure function is_passed ( self , switch , position ) !< Check if a CLA has been passed. class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical :: is_passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. is_passed = . false . if ( self % Na > 0 ) then if ( present ( switch )) then do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if (( self % cla ( a )% switch == switch ). or .( self % cla ( a )% switch_ab == switch )) then is_passed = self % cla ( a )% is_passed exit endif endif enddo elseif ( present ( position )) then is_passed = self % cla ( position )% is_passed endif endif endfunction is_passed","tags":"","loc":"proc/is_passed.html"},{"title":"is_defined – FLAP","text":"private function is_defined(self, switch, pos) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character, intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. Contents Source Code is_defined Source Code function is_defined ( self , switch , pos ) !< Check if a CLA has been defined. class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( out ) :: pos !< CLA position. logical :: is_defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. is_defined = . false . if ( present ( pos )) pos = 0 if ( self % Na > 0 ) then do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if (( self % cla ( a )% switch == switch ). or .( self % cla ( a )% switch_ab == switch )) then is_defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif endfunction is_defined","tags":"","loc":"proc/is_defined.html"},{"title":"usage – FLAP","text":"private function usage(self, pref, no_header, markdown) Get correct CLAsG usage. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: markdown Format things form markdown. Return Value character(len=:),allocatable Usage string. Contents Source Code usage Source Code function usage ( self , pref , no_header , markdown ) !< Get correct CLAsG usage. class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( in ) :: markdown !< Format things form markdown. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: markdownd !< Markdonw format, local variable. markdownd = . false . ; if ( present ( markdown )) markdownd = markdown prefd = '' ; if ( present ( pref )) prefd = pref usage = self % progname ; if ( self % group /= '' ) usage = self % progname // ' ' // self % group usage = prefd // self % help // ' ' // usage // self % signature () if ( self % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // self % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( self % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , self % Na if ( self % cla ( a )% is_required . and .(. not . self % cla ( a )% is_hidden )) usage = usage // new_line ( 'a' ) // & self % cla ( a )% usage ( pref = prefd , markdown = markdownd ) enddo endif if ( self % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , self % Na if (. not . self % cla ( a )% is_required . and .(. not . self % cla ( a )% is_hidden )) usage = usage // new_line ( 'a' ) // & self % cla ( a )% usage ( pref = prefd , markdown = markdownd ) enddo endif endfunction usage","tags":"","loc":"proc/usage.html"},{"title":"signature – FLAP","text":"private function signature(self, bash_completion, plain) Get CLAsG signature. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. logical, intent(in), optional :: bash_completion Return the signature for bash completion. logical, intent(in), optional :: plain Return the signature as plain switches list. Return Value character(len=:),allocatable Signature. Contents Source Code signature Source Code function signature ( self , bash_completion , plain ) !< Get CLAsG signature. class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. logical , optional , intent ( in ) :: bash_completion !< Return the signature for bash completion. logical , optional , intent ( in ) :: plain !< Return the signature as plain switches list. ! logical                                         :: plain_           !< Return the signature as plain switches list, local var. logical :: bash_completion_ !< Return the signature for bash completion, local variable. character ( len = :), allocatable :: signature !< Signature. ! logical                                         :: clas_choices     !< Flag to check if there are CLAs with choices. integer ( I4P ) :: a !, aa            !< Counter. signature = '' bash_completion_ = . false . ; if ( present ( bash_completion )) bash_completion_ = bash_completion ! plain_ = .false. ; if (present(plain)) plain_ = plain ! if (bash_completion_) then !   ! if (plain_) then !   !   do a=1, self%Na !   !     signature = signature//self%cla(a)%signature(bash_completion=bash_completion, plain=plain) !   !   enddo !   ! else !     clas_choices = .false. !     do a=1, self%Na !       if (self%cla(a)%has_choices()) then !         aa = a !         clas_choices = .true. !         exit !       endif !     enddo !     if (clas_choices) then !       signature = signature//new_line('a')//& !                   '    if [ \"$prev\" == \"'//self%cla(aa)%switch//'\" ] || [ \"$prev\" == \"'//self%cla(aa)%switch_ab//'\" ] ; then' !       signature = signature//new_line('a')//'       COMPREPLY=( $( compgen -W \"'//choices(self%cla(aa)%choices)//'\" -- $cur ) )' !       do a=aa+1, self%Na !         if (self%cla(a)%has_choices()) then !           signature = signature//new_line('a')//& !                       '    elif [ \"$prev\" == \"'//self%cla(a)%switch//'\" ] || [ \"$prev\" == \"'//self%cla(a)%switch_ab//'\" ] ; then' !           signature = signature//new_line('a')//'       COMPREPLY=( $( compgen -W \"'//choices(self%cla(a)%choices)//& !                       '\" -- $cur ) )' !         endif !       enddo !       signature = signature//new_line('a')//'    else'//new_line('a')//'      COMPREPLY=( $( compgen -W \"' !       do a=1, self%Na !         signature = signature//self%cla(a)%signature(bash_completion=bash_completion) !       enddo !       signature = signature//'\" -- $cur ) )'//new_line('a')//'    fi' !     else !       signature = signature//new_line('a')//'    COMPREPLY=( $( compgen -W \"' !       do a=1, self%Na !         signature = signature//self%cla(a)%signature(bash_completion=bash_completion) !       enddo !       signature = signature//'\" -- $cur ) )' !     endif !   ! endif ! else if ( bash_completion_ ) then do a = 1 , self % Na signature = signature // self % cla ( a )% signature ( bash_completion = bash_completion , plain = . true .) enddo signature = new_line ( 'a' ) // '    COMPREPLY=( $( compgen -W \"' // signature // '\" -- $cur ) )' endif do a = 1 , self % Na signature = signature // self % cla ( a )% signature ( bash_completion = bash_completion , plain = plain ) enddo ! endif !contains !  pure function choices(choices_c) !  !< Return space-separated choices list from a comma-separated one. !  character(len=*), intent(in)  :: choices_c !< Comma-separated list of choices. !  character(len=len(choices_c)) :: choices   !< Space-separated list of choices. !  integer(I4P)                  :: c         !< Counter. !  choices = choices_c !  do c=1, len(choices) !    if (choices(c:c)==',') choices(c:c) = ' ' !  enddo !  endfunction choices endfunction signature","tags":"","loc":"proc/signature.html"},{"title":"free – FLAP","text":"private elemental subroutine free(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. Contents Source Code free Source Code elemental subroutine free ( self ) !< Free dynamic memory. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. ! object members call self % free_object ! command_line_arguments_group members if ( allocated ( self % group )) deallocate ( self % group ) if ( allocated ( self % cla )) then call self % cla % free deallocate ( self % cla ) endif self % Na = 0_I4P self % Na_required = 0_I4P self % Na_optional = 0_I4P self % is_called = . false . endsubroutine free","tags":"","loc":"proc/free.html"},{"title":"check – FLAP","text":"private subroutine check(self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. Contents Source Code check Source Code subroutine check ( self , pref ) !< Check data consistency. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. ! verify if CLAs switches are unique CLA_unique : do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then do aa = 1 , self % Na if (( a /= aa ). and .(. not . self % cla ( aa )% is_positional )) then if (( self % cla ( a )% switch == self % cla ( aa )% switch ). or .( self % cla ( a )% switch_ab == self % cla ( aa )% switch ). or .& ( self % cla ( a )% switch == self % cla ( aa )% switch_ab ). or .( self % cla ( a )% switch_ab == self % cla ( aa )% switch_ab )) then call self % errored ( pref = pref , error = ERROR_CONSISTENCY , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! update mutually exclusive relations CLA_exclude : do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if ( self % cla ( a )% m_exclude /= '' ) then if ( self % is_defined ( switch = self % cla ( a )% m_exclude , pos = aa )) then self % cla ( aa )% m_exclude = self % cla ( a )% switch endif endif endif enddo CLA_exclude endsubroutine check","tags":"","loc":"proc/check.html"},{"title":"is_required_passed – FLAP","text":"private subroutine is_required_passed(self, pref) Check if required CLAs are passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. Contents Source Code is_required_passed Source Code subroutine is_required_passed ( self , pref ) !< Check if required CLAs are passed. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. if ( self % is_called ) then do a = 1 , self % Na if (. not . self % cla ( a )% is_required_passed ( pref = pref )) then self % error = self % cla ( a )% error write ( self % usage_lun , '(A)' ) self % usage ( pref = pref ) return endif enddo endif endsubroutine is_required_passed","tags":"","loc":"proc/is_required_passed.html"},{"title":"raise_error_m_exclude – FLAP","text":"private subroutine raise_error_m_exclude(self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Contents Source Code raise_error_m_exclude Source Code subroutine raise_error_m_exclude ( self , pref ) !< Raise error mutually exclusive CLAs passed. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_M_EXCLUDE ) endsubroutine raise_error_m_exclude","tags":"","loc":"proc/raise_error_m_exclude.html"},{"title":"add – FLAP","text":"private subroutine add(self, pref, cla) Add CLA to CLAs list. Note If not otherwise declared the action on CLA value is set to “store” a value that must be passed after the switch name\nor directly passed in case of positional CLA. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. type( command_line_argument ), intent(in) :: cla CLA data. Contents Source Code add Source Code subroutine add ( self , pref , cla ) !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. type ( command_line_argument ), intent ( in ) :: cla !< CLA data. type ( command_line_argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. integer ( I4P ) :: c !< Counter. if ( self % Na > 0_I4P ) then if (. not . cla % is_positional ) then allocate ( cla_list_new ( 1 : self % Na + 1 )) do c = 1 , self % Na cla_list_new ( c ) = self % cla ( c ) enddo cla_list_new ( self % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : self % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = self % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , self % Na + 1 cla_list_new ( c ) = self % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = self % cla ) self % Na = self % Na + 1 if ( cla % is_required ) then self % Na_required = self % Na_required + 1 else self % Na_optional = self % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) call self % check ( pref = pref ) endsubroutine add","tags":"","loc":"proc/add.html"},{"title":"parse – FLAP","text":"private subroutine parse(self, args, ignore_unknown_clas, pref, error_unknown_clas) Parse CLAsG arguments. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in) :: args (:) Command line arguments. logical, intent(in) :: ignore_unknown_clas Disable errors-raising for passed unknown CLAs. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out) :: error_unknown_clas Error flag for passed unknown CLAs. Calls proc~~parse~~CallsGraph proc~parse parse cton cton proc~parse->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code parse Source Code subroutine parse ( self , args , ignore_unknown_clas , pref , error_unknown_clas ) !< Parse CLAsG arguments. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), intent ( in ) :: args (:) !< Command line arguments. logical , intent ( in ) :: ignore_unknown_clas !< Disable errors-raising for passed unknown CLAs. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), intent ( out ) :: error_unknown_clas !< Error flag for passed unknown CLAs. type ( command_line_argument ) :: cla !< CLA data. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. error_unknown_clas = 0 if ( self % is_called ) then arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , self % Na ! loop over CLAs group clas named options if (. not . self % cla ( a )% is_positional ) then if ( trim ( adjustl ( self % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( self % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( self % cla ( a )% is_passed ) then ! current CLA has been already passed, raise an error call self % cla ( arg )% raise_error_duplicated_clas ( pref = pref , switch = trim ( adjustl ( args ( arg )))) self % error = self % cla ( arg )% error endif found_val = . false . if ( self % cla ( a )% act == action_store ) then if ( allocated ( self % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . self % is_defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = self % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then self % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( self % cla ( a )% def )) then self % cla ( a )% val = self % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( self % cla ( a )% nargs )) then self % cla ( a )% val = '' select case ( self % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . self % is_defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call self % cla ( a )% raise_error_nargs_insufficient ( pref = pref ) self % error = self % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . self % is_defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( self % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call self % cla ( a )% raise_error_nargs_insufficient ( pref = pref ) self % error = self % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) enddo found_val = . true . arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call self % cla ( a )% raise_error_value_missing ( pref = pref ) self % error = self % cla ( a )% error return endif arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( self % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . self % is_defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! flush default to val if default is set if ( allocated ( self % cla ( a )% def )) self % cla ( a )% val = self % cla ( a )% def endif elseif ( self % cla ( a )% act == action_print_help ) then self % error = STATUS_PRINT_H elseif ( self % cla ( a )% act == action_print_vers ) then self % error = STATUS_PRINT_V endif self % cla ( a )% is_passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if ( arg > self % Na ) then ! has been passed too much CLAs ! place the error into a new positional dummy CLA call cla % assign_object ( self ) cla % is_passed = . true . cla % m_exclude = '' call self % add ( pref = pref , cla = cla ) call self % cla ( self % Na )% raise_error_switch_unknown ( pref = pref , switch = trim ( adjustl ( args ( arg )))) self % error = self % cla ( self % Na )% error return endif if (. not . self % cla ( arg )% is_positional ) then ! current argument (arg-th) is not positional... there is a problem! call self % cla ( arg )% raise_error_switch_unknown ( pref = pref , switch = trim ( adjustl ( args ( arg )))) self % error = self % cla ( arg )% error error_unknown_clas = self % error if (. not . ignore_unknown_clas ) return else ! positional CLA always stores a value self % cla ( arg )% val = trim ( adjustl ( args ( arg ))) self % cla ( arg )% is_passed = . true . endif endif enddo call self % check_m_exclusive ( pref = pref ) call self % sanitize_defaults endif endsubroutine parse","tags":"","loc":"proc/parse.html"},{"title":"errored – FLAP","text":"private subroutine errored(self, error, pref, a1, a2) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. integer(kind=I4P), intent(in) :: error Error occurred. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(in), optional :: a1 First index CLAs group inconsistent. integer(kind=I4P), intent(in), optional :: a2 Second index CLAs group inconsistent. Calls proc~~errored~~CallsGraph proc~errored errored interface~colorize colorize proc~errored->interface~colorize str str proc~errored->str proc~colorize_default colorize_default interface~colorize->proc~colorize_default proc~color_index color_index proc~colorize_default->proc~color_index proc~upper upper proc~colorize_default->proc~upper proc~style_index style_index proc~colorize_default->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code errored Source Code subroutine errored ( self , error , pref , a1 , a2 ) !< Trig error occurrence and print meaningful message. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( in ) :: a1 !< First index CLAs group inconsistent. integer ( I4P ), optional , intent ( in ) :: a2 !< Second index CLAs group inconsistent. character ( len = :), allocatable :: prefd !< Prefixing string. self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref prefd = prefd // self % progname // ': ' // colorize ( 'error' , color_fg = self % error_color , style = self % error_style ) select case ( self % error ) case ( ERROR_CONSISTENCY ) if ( self % group /= '' ) then self % error_message = prefd // ': group (command) name: \"' // self % group // '\" consistency error:' else self % error_message = prefd // ': consistency error:' endif self % error_message = self % error_message // ' \"' // trim ( str ( a1 , . true .)) // & '-th\" option has the same switch or abbreviated switch of \"' // & trim ( str ( a2 , . true .)) // '-th\" option:' // new_line ( 'a' ) self % error_message = self % error_message // prefd // ' CLA(' // trim ( str ( a1 , . true .)) // ') switches = ' // self % cla ( a1 )% switch // ' ' // & self % cla ( a1 )% switch_ab // new_line ( 'a' ) self % error_message = self % error_message // prefd // ' CLA(' // trim ( str ( a2 , . true .)) // ') switches = ' // self % cla ( a2 )% switch // ' ' // & self % cla ( a2 )% switch_ab case ( ERROR_M_EXCLUDE ) self % error_message = prefd // ': the group \"' // self % group // '\" and \"' // self % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect call self % print_error_message endif endsubroutine errored","tags":"","loc":"proc/errored.html"},{"title":"check_m_exclusive – FLAP","text":"private subroutine check_m_exclusive(self, pref) Check if two mutually exclusive CLAs have been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. Contents Source Code check_m_exclusive Source Code subroutine check_m_exclusive ( self , pref ) !< Check if two mutually exclusive CLAs have been passed. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. if ( self % is_called ) then do a = 1 , self % Na if ( self % cla ( a )% is_passed ) then if ( self % cla ( a )% m_exclude /= '' ) then if ( self % is_passed ( switch = self % cla ( a )% m_exclude )) then call self % cla ( a )% raise_error_m_exclude ( pref = pref ) self % error = self % cla ( a )% error return endif endif endif enddo endif endsubroutine check_m_exclusive","tags":"","loc":"proc/check_m_exclusive.html"},{"title":"sanitize_defaults – FLAP","text":"private subroutine sanitize_defaults(self) Sanitize defaults values. It is necessary to sanitize the default values of non-passed, optional CLAs. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. Contents Source Code sanitize_defaults Source Code subroutine sanitize_defaults ( self ) !< Sanitize defaults values. !< !< It is necessary to *sanitize* the default values of non-passed, optional CLAs. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. integer ( I4P ) :: a !< Counter. if ( self % is_called ) then do a = 1 , self % Na call self % cla ( a )% sanitize_defaults enddo endif endsubroutine sanitize_defaults","tags":"","loc":"proc/sanitize_defaults.html"},{"title":"clasg_assign_clasg – FLAP","text":"private elemental subroutine clasg_assign_clasg(lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: lhs Left hand side. type( command_line_arguments_group ), intent(in) :: rhs Right hand side. Contents Source Code clasg_assign_clasg Source Code elemental subroutine clasg_assign_clasg ( lhs , rhs ) !< Assignment operator. class ( command_line_arguments_group ), intent ( INOUT ) :: lhs !< Left hand side. type ( command_line_arguments_group ), intent ( IN ) :: rhs !< Right hand side. ! object members call lhs % assign_object ( rhs ) ! command_line_arguments_group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % is_called = rhs % is_called endsubroutine clasg_assign_clasg","tags":"","loc":"proc/clasg_assign_clasg.html"},{"title":"finalize – FLAP","text":"private elemental subroutine finalize(self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_arguments_group ), intent(inout) :: self CLAsG data. Contents Source Code finalize Source Code elemental subroutine finalize ( self ) !< Free dynamic memory when finalizing. type ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. call self % free endsubroutine finalize","tags":"","loc":"proc/finalize.html"},{"title":"is_passed – FLAP","text":"private function is_passed(self, group, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Contents Source Code is_passed Source Code function is_passed ( self , group , switch , position ) !< Check if a CLA has been passed. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical :: is_passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. is_passed = . false . if (. not . present ( group )) then if ( present ( switch )) then is_passed = self % clasg ( 0 )% is_passed ( switch = switch ) elseif ( present ( position )) then is_passed = self % clasg ( 0 )% is_passed ( position = position ) endif else if ( self % is_defined_group ( group = group , g = g )) then if ( present ( switch )) then is_passed = self % clasg ( g )% is_passed ( switch = switch ) elseif ( present ( position )) then is_passed = self % clasg ( g )% is_passed ( position = position ) endif endif endif endfunction is_passed","tags":"","loc":"proc/is_passed~2.html"},{"title":"is_defined_group – FLAP","text":"private function is_defined_group(self, group, g) result(defined) Check if a CLAs group has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. Contents Source Code is_defined_group Source Code function is_defined_group ( self , group , g ) result ( defined ) !< Check if a CLAs group has been defined. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( out ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg !< Counter. integer ( I4P ) :: ggg !< Counter. defined = . false . do gg = 0 , size ( self % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( self % clasg ( gg )% group )) defined = ( self % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg endfunction is_defined_group","tags":"","loc":"proc/is_defined_group.html"},{"title":"is_called_group – FLAP","text":"private function is_called_group(self, group) result(called) Check if a CLAs group has been run. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. Contents Source Code is_called_group Source Code function is_called_group ( self , group ) result ( called ) !< Check if a CLAs group has been run. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. called = . false . if ( self % is_defined_group ( group = group , g = g )) called = self % clasg ( g )% is_called endfunction is_called_group","tags":"","loc":"proc/is_called_group.html"},{"title":"is_defined – FLAP","text":"private function is_defined(self, switch, group) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: switch Switch name. character, intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. Contents Source Code is_defined Source Code function is_defined ( self , switch , group ) !< Check if a CLA has been defined. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: switch !< Switch name. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLAs. logical :: is_defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. is_defined = . false . if (. not . present ( group )) then is_defined = self % clasg ( 0 )% is_defined ( switch = switch ) else if ( self % is_defined_group ( group = group , g = g )) is_defined = self % clasg ( g )% is_defined ( switch = switch ) endif endfunction is_defined","tags":"","loc":"proc/is_defined~2.html"},{"title":"is_parsed – FLAP","text":"private elemental function is_parsed(self) Check if CLI has been parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value logical Parsed status. Contents Source Code is_parsed Source Code elemental function is_parsed ( self ) !< Check if CLI has been parsed. class ( command_line_interface ), intent ( in ) :: self !< CLI data. logical :: is_parsed !< Parsed status. is_parsed = self % is_parsed_ endfunction is_parsed","tags":"","loc":"proc/is_parsed.html"},{"title":"usage – FLAP","text":"private function usage(self, g, pref, no_header, no_examples, no_epilog, markdown) result(usaged) Print correct usage of CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. integer(kind=I4P), intent(in) :: g Group index. character, intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. logical, intent(in), optional :: markdown Format things with markdown Return Value character(len=:),allocatable Usage string. Contents Source Code usage Source Code function usage ( self , g , pref , no_header , no_examples , no_epilog , markdown ) result ( usaged ) !< Print correct usage of CLI. class ( command_line_interface ), intent ( in ) :: self !< CLI data. integer ( I4P ), intent ( in ) :: g !< Group index. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( in ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( in ) :: no_epilog !< Avoid insert epilogue to usage. logical , optional , intent ( in ) :: markdown !< Format things with markdown character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. logical :: markdownd !< Format for markdown. logical :: grouped_examples !< Will show examples of group usage. integer ( I4P ) :: gi !< Counter. no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog markdownd = . false . ; if ( present ( markdown )) markdownd = markdown prefd = '' ; if ( present ( pref )) prefd = pref grouped_examples = . false . if ( g > 0 ) then ! usage of a specific command usaged = self % clasg ( g )% usage ( pref = prefd , no_header = no_headerd , markdown = markdownd ) if ( allocated ( self % clasg ( g )% examples ). and .(. not . no_examplesd )) then usaged = usaged // print_examples ( prefd , self % clasg ( g )% examples ) grouped_examples = . true . endif else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // self % help // self % progname // ' ' // self % signature () if ( self % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // self % description endif if ( self % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // self % clasg ( 0 )% usage ( pref = prefd , no_header = . true ., markdown = markdownd ) if ( size ( self % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( self % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // self % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // self % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( self % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // self % progname // ' ' // self % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( self % examples ). and .(. not . no_examplesd ). and .(. not . grouped_examples )) then usaged = usaged // print_examples ( prefd , self % examples ) endif if ( self % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // self % epilog contains function print_examples ( prefd , examples ) result ( exampled ) !< Print examples of the correct usage. character ( * ), intent ( in ) :: prefd !< Prefixing string. character ( * ), intent ( in ) :: examples ( 1 :) !< Examples to be printed. character ( len = :), allocatable :: exampled !< Examples string. integer ( I4P ) :: e !< Counter. exampled = new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( examples , dim = 1 ) exampled = exampled // new_line ( 'a' ) // prefd // '   ' // trim ( examples ( e )) enddo endfunction print_examples endfunction usage","tags":"","loc":"proc/usage~2.html"},{"title":"signature – FLAP","text":"private function signature(self, bash_completion) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. logical, intent(in), optional :: bash_completion Return the signature for bash completion. Return Value character(len=:),allocatable Signature. Contents Source Code signature Source Code function signature ( self , bash_completion ) !< Get signature. class ( command_line_interface ), intent ( in ) :: self !< CLI data. logical , optional , intent ( in ) :: bash_completion !< Return the signature for bash completion. logical :: bash_completion_ !< Return the signature for bash completion, local variable. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: g !< Counter. bash_completion_ = . false . ; if ( present ( bash_completion )) bash_completion_ = bash_completion if ( bash_completion_ ) then signature = signature // new_line ( 'a' ) // '    COMPREPLY=( )' signature = signature // new_line ( 'a' ) // '    COMPREPLY+=( $( compgen -W \"' // & self % clasg ( 0 )% signature ( bash_completion = bash_completion , plain = . true .) // '\" -- $cur ) )' if ( size ( self % clasg , dim = 1 ) > 1 ) then do g = 1 , size ( self % clasg , dim = 1 ) - 1 signature = signature // new_line ( 'a' ) // '    COMPREPLY+=( $( compgen -W \"' // self % clasg ( g )% group // '\" -- $cur ) )' enddo endif else signature = self % clasg ( 0 )% signature () if ( size ( self % clasg , dim = 1 ) > 1 ) then signature = signature // ' {' // self % clasg ( 1 )% group do g = 2 , size ( self % clasg , dim = 1 ) - 1 signature = signature // ',' // self % clasg ( g )% group enddo signature = signature // '} ...' endif endif endfunction signature","tags":"","loc":"proc/signature~2.html"},{"title":"free – FLAP","text":"private elemental subroutine free(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. Contents Source Code free Source Code elemental subroutine free ( self ) !< Free dynamic memory. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ) :: g !< Counter. ! object members call self % free_object ! command_line_interface members if ( allocated ( self % clasg )) then do g = 0 , size ( self % clasg , dim = 1 ) - 1 call self % clasg ( g )% free enddo deallocate ( self % clasg ) endif if ( allocated ( self % args )) deallocate ( self % args ) if ( allocated ( self % examples )) deallocate ( self % examples ) self % disable_hv = . false . self % is_parsed_ = . false . self % ignore_unknown_clas = . false . self % error_unknown_clas = 0_I4P endsubroutine free","tags":"","loc":"proc/free~2.html"},{"title":"init – FLAP","text":"private subroutine init(self, progname, version, help, description, license, authors, examples, epilog, disable_hv, usage_lun, error_lun, version_lun, error_color, error_style, ignore_unknown_clas) Initialize CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: progname Program name. character, intent(in), optional :: version Program version. character, intent(in), optional :: help Help message introducing the CLI usage. character, intent(in), optional :: description Detailed description message introducing the program. character, intent(in), optional :: license License description. character, intent(in), optional :: authors Authors list. character, intent(in), optional :: examples (1:) Examples of correct usage. character, intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of ‘help’ and ‘version’ CLAs. integer(kind=I4P), intent(in), optional :: usage_lun Unit number to print usage/help. integer(kind=I4P), intent(in), optional :: error_lun Unit number to print error info. integer(kind=I4P), intent(in), optional :: version_lun Unit number to print version/license info. character, intent(in), optional :: error_color ANSI color of error messages. character, intent(in), optional :: error_style ANSI style of error messages. logical, intent(in), optional :: ignore_unknown_clas Disable errors-raising for passed unknown CLAs. Contents Source Code init Source Code subroutine init ( self , progname , version , help , description , license , authors , examples , epilog , disable_hv , & usage_lun , error_lun , version_lun , error_color , error_style , ignore_unknown_clas ) !< Initialize CLI. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: progname !< Program name. character ( * ), optional , intent ( in ) :: version !< Program version. character ( * ), optional , intent ( in ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( in ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( in ) :: license !< License description. character ( * ), optional , intent ( in ) :: authors !< Authors list. character ( * ), optional , intent ( in ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( in ) :: epilog !< Epilog message. logical , optional , intent ( in ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. integer ( I4P ), optional , intent ( in ) :: usage_lun !< Unit number to print usage/help. integer ( I4P ), optional , intent ( in ) :: version_lun !< Unit number to print version/license info. integer ( I4P ), optional , intent ( in ) :: error_lun !< Unit number to print error info. character ( * ), optional , intent ( in ) :: error_color !< ANSI color of error messages. character ( * ), optional , intent ( in ) :: error_style !< ANSI style of error messages. logical , optional , intent ( in ) :: ignore_unknown_clas !< Disable errors-raising for passed unknown CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. call self % free if ( present ( progname )) then self % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then self % progname = prog_invocation else self % progname = 'program' endif endif self % version = 'unknown' ; if ( present ( version )) self % version = version self % help = 'usage: ' ; if ( present ( help )) self % help = help self % description = '' ; if ( present ( description )) self % description = description self % license = '' ; if ( present ( license )) self % license = license self % authors = '' ; if ( present ( authors )) self % authors = authors call self % set_examples ( examples ) self % epilog = '' ; if ( present ( epilog )) self % epilog = epilog if ( present ( disable_hv )) self % disable_hv = disable_hv ! default set by self%free if ( present ( usage_lun )) self % usage_lun = usage_lun ! default set by self%free if ( present ( version_lun )) self % version_lun = version_lun ! default set by self%free if ( present ( error_lun )) self % error_lun = error_lun ! default set by self%free self % error_color = '' ; if ( present ( error_color )) self % error_color = error_color self % error_style = '' ; if ( present ( error_style )) self % error_style = error_style if ( present ( ignore_unknown_clas )) self % ignore_unknown_clas = ignore_unknown_clas ! default set by self%free ! initialize only the first default group allocate ( self % clasg ( 0 : 0 )) call self % clasg ( 0 )% assign_object ( self ) self % clasg ( 0 )% group = '' endsubroutine init","tags":"","loc":"proc/init~2.html"},{"title":"add_group – FLAP","text":"private subroutine add_group(self, help, description, exclude, examples, group) Add CLAs group to CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: help Help message. character, intent(in), optional :: description Detailed description. character, intent(in), optional :: exclude Group name of the mutually exclusive group. character, intent(in), optional :: examples (1:) Examples of correct usage of the group. character, intent(in) :: group Name of the grouped CLAs. Contents Source Code add_group Source Code subroutine add_group ( self , help , description , exclude , examples , group ) !< Add CLAs group to CLI. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: help !< Help message. character ( * ), optional , intent ( in ) :: description !< Detailed description. character ( * ), optional , intent ( in ) :: exclude !< Group name of the mutually exclusive group. character ( * ), optional , intent ( in ) :: examples ( 1 :) !< Examples of correct usage of the group. character ( * ), intent ( in ) :: group !< Name of the grouped CLAs. type ( command_line_arguments_group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. integer ( I4P ) :: gi !< Group index if (. not . self % is_defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( self % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) !    clasg_list_new(0:Ng-1) = self%clasg(0:Ng-1) ! Not working on Intel Fortran 15.0.2 do gi = 0 , Ng - 1 clasg_list_new ( gi ) = self % clasg ( gi ) enddo call clasg_list_new ( Ng )% assign_object ( self ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded call clasg_list_new ( Ng )% set_examples ( examples ) deallocate ( self % clasg ) allocate ( self % clasg ( 0 : Ng )) self % clasg = clasg_list_new deallocate ( clasg_list_new ) endif endsubroutine add_group","tags":"","loc":"proc/add_group.html"},{"title":"set_mutually_exclusive_groups – FLAP","text":"private subroutine set_mutually_exclusive_groups(self, group1, group2) Set two CLAs group ad mutually exclusive. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in) :: group1 Name of the first grouped CLAs. character, intent(in) :: group2 Name of the second grouped CLAs. Contents Source Code set_mutually_exclusive_groups Source Code subroutine set_mutually_exclusive_groups ( self , group1 , group2 ) !< Set two CLAs group ad mutually exclusive. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), intent ( in ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( in ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 !< Counter. integer ( I4P ) :: g2 !< Counter. if ( self % is_defined_group ( group = group1 , g = g1 ). and . self % is_defined_group ( group = group2 , g = g2 )) then self % clasg ( g1 )% m_exclude = group2 self % clasg ( g2 )% m_exclude = group1 endif endsubroutine set_mutually_exclusive_groups","tags":"","loc":"proc/set_mutually_exclusive_groups.html"},{"title":"add – FLAP","text":"private subroutine add(self, pref, group, group_index, switch, switch_ab, help, help_markdown, help_color, help_style, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Add CLA to CLI. Note If not otherwise declared the action on CLA value is set to “store” a value that must be passed after the switch name\nor directly passed in case of positional CLA. Note If not otherwise speficied the CLA belongs to the default group “zero” that is the group of non-grouped CLAs. Note If CLA belongs to a not yet present group it is created on the fly. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character, intent(in), optional :: switch Switch name. character, intent(in), optional :: switch_ab Abbreviated switch name. character, intent(in), optional :: help Help message describing the CLA. character, intent(in), optional :: help_markdown Longer help message, markdown formatted. character, intent(in), optional :: help_color ANSI color of help messages. character, intent(in), optional :: help_style ANSI style of help messages. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character, intent(in), optional :: act CLA value action. character, intent(in), optional :: def Default value. character, intent(in), optional :: nargs Number of arguments consumed by CLA. character, intent(in), optional :: choices List of allowable values for the argument. character, intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character, intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Calls proc~~add~2~~CallsGraph proc~add~2 add proc~upper_case upper_case proc~add~2->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code add Source Code subroutine add ( self , pref , group , group_index , switch , switch_ab , help , help_markdown , help_color , help_style , & required , positional , position , hidden , act , def , nargs , choices , exclude , envvar , error ) !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( in ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( in ) :: switch !< Switch name. character ( * ), optional , intent ( in ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( in ) :: help !< Help message describing the CLA. character ( * ), optional , intent ( in ) :: help_color !< ANSI color of help messages. character ( * ), optional , intent ( in ) :: help_style !< ANSI style of help messages. character ( * ), optional , intent ( in ) :: help_markdown !< Longer help message, markdown formatted. logical , optional , intent ( in ) :: required !< Flag for set required argument. logical , optional , intent ( in ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical , optional , intent ( in ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( in ) :: act !< CLA value action. character ( * ), optional , intent ( in ) :: def !< Default value. character ( * ), optional , intent ( in ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( in ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( in ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( in ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. type ( command_line_argument ) :: cla !< CLA data. integer ( I4P ) :: g !< Counter. ! initialize CLA call cla % assign_object ( self ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % help_color = '' ; if ( present ( help_color )) cla % help_color = help_color cla % help_style = '' ; if ( present ( help_style )) cla % help_style = help_style cla % help_markdown = '' ; if ( present ( help_markdown )) cla % help_markdown = help_markdown cla % is_required = . false . ; if ( present ( required )) cla % is_required = required cla % is_positional = . false . ; if ( present ( positional )) cla % is_positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % is_hidden = . false . ; if ( present ( hidden )) cla % is_hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( def )) cla % val = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar call cla % check ( pref = pref ) ; self % error = cla % error if ( self % error /= 0 ) then if ( present ( error )) error = self % error return endif ! add CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call self % clasg ( 0 )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( 0 )% error elseif ( present ( group )) then if ( self % is_defined_group ( group = group , g = g )) then call self % clasg ( g )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( g )% error else call self % add_group ( group = group ) call self % clasg ( size ( self % clasg , dim = 1 ) - 1 )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( size ( self % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( self % clasg , dim = 1 ) - 1 ) then call self % clasg ( group_index )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( group_index )% error endif endif if ( present ( error )) error = self % error endsubroutine add","tags":"","loc":"proc/add~2.html"},{"title":"check – FLAP","text":"private subroutine check(self, pref, error) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code check Source Code subroutine check ( self , pref , error ) !< Check data consistency. class ( command_line_interface ), intent ( INOUT ) :: self !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. do g = 0 , size ( self % clasg , dim = 1 ) - 1 ! check group consistency call self % clasg ( g )% check ( pref = pref ) self % error = self % clasg ( g )% error if ( present ( error )) error = self % error if ( self % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( self % clasg ( g )% m_exclude /= '' ) then if ( self % is_defined_group ( group = self % clasg ( g )% m_exclude , g = gg )) self % clasg ( gg )% m_exclude = self % clasg ( g )% group endif endif enddo endsubroutine check","tags":"","loc":"proc/check~2.html"},{"title":"check_m_exclusive – FLAP","text":"private subroutine check_m_exclusive(self, pref) Check if two mutually exclusive CLAs group have been called. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: pref Prefixing string. Contents Source Code check_m_exclusive Source Code subroutine check_m_exclusive ( self , pref ) !< Check if two mutually exclusive CLAs group have been called. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. do g = 1 , size ( self % clasg , dim = 1 ) - 1 if ( self % clasg ( g )% is_called . and .( self % clasg ( g )% m_exclude /= '' )) then if ( self % is_defined_group ( group = self % clasg ( g )% m_exclude , g = gg )) then if ( self % clasg ( gg )% is_called ) then call self % clasg ( g )% raise_error_m_exclude ( pref = pref ) self % error = self % clasg ( g )% error exit endif endif endif enddo endsubroutine check_m_exclusive","tags":"","loc":"proc/check_m_exclusive~2.html"},{"title":"parse – FLAP","text":"private subroutine parse(self, pref, args, error) Parse Command Line Interfaces by means of a previously initialized CLAs groups list. Note The leading and trailing white spaces are removed from CLA values. Note If the args argument is passed the command line arguments are taken from it and not from the actual program CLI\ninvocations. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code parse Source Code subroutine parse ( self , pref , args , error ) !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. if ( present ( error )) error = 0 if ( self % is_parsed_ ) return ! add help and version switches if not done by user if (. not . self % disable_hv ) then do g = 0 , size ( self % clasg , dim = 1 ) - 1 if (. not .( self % is_defined ( group = self % clasg ( g )% group , switch = '--help' ). and .& self % is_defined ( group = self % clasg ( g )% group , switch = '-h' ))) & call self % add ( pref = pref , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( self % is_defined ( group = self % clasg ( g )% group , switch = '--version' ). and . & self % is_defined ( group = self % clasg ( g )% group , switch = '-v' ))) & call self % add ( pref = pref , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( self % clasg , dim = 1 ) - 1 if (. not . self % is_defined ( group = self % clasg ( g )% group , switch = '--' )) & call self % add ( pref = pref , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parse passed CLAs grouping in indexes if ( present ( args )) then call self % get_args ( args = args , ai = ai ) else call self % get_args ( ai = ai ) endif ! check CLI consistency call self % check ( pref = pref ) if ( self % error > 0 ) then if ((( self % error == ERROR_UNKNOWN ). and .(. not . self % ignore_unknown_clas )). or .( self % error /= ERROR_UNKNOWN )) then if ( present ( error )) error = self % error return else self % error_unknown_clas = ERROR_UNKNOWN_CLAS_IGNORED endif endif ! parse CLI do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) then call self % clasg ( g )% parse ( args = self % args ( ai ( g , 1 ): ai ( g , 2 )), ignore_unknown_clas = self % ignore_unknown_clas , & pref = pref , error_unknown_clas = self % error_unknown_clas ) else call self % clasg ( g )% sanitize_defaults endif self % error = self % clasg ( g )% error if ( self % error < 0 ) exit if ( self % error > 0 ) then if ((( self % error == ERROR_UNKNOWN ). and .(. not . self % ignore_unknown_clas )). or .( self % error /= ERROR_UNKNOWN )) then if ( present ( error )) error = self % error exit else self % error_unknown_clas = ERROR_UNKNOWN_CLAS_IGNORED endif endif enddo if ( self % error > 0 ) then if ((( self % error == ERROR_UNKNOWN ). and .(. not . self % ignore_unknown_clas )). or .( self % error /= ERROR_UNKNOWN )) then if ( present ( error )) error = self % error return else self % error_unknown_clas = ERROR_UNKNOWN_CLAS_IGNORED endif endif ! trap the special cases of version/help printing if ( self % error == STATUS_PRINT_V ) then call self % print_version ( pref = pref ) stop elseif ( self % error == STATUS_PRINT_H ) then do g = 0 , size ( ai , dim = 1 ) - 1 if ( self % clasg ( g )% error == STATUS_PRINT_H ) then write ( self % usage_lun , '(A)' ) self % usage ( pref = pref , g = g ) stop endif enddo endif ! check if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call self % clasg ( g )% is_required_passed ( pref = pref ) self % error = self % clasg ( g )% error if ( self % error > 0 ) then if ((( self % error == ERROR_UNKNOWN ). and .(. not . self % ignore_unknown_clas )). or .( self % error /= ERROR_UNKNOWN )) then if ( present ( error )) error = self % error exit else self % error_unknown_clas = ERROR_UNKNOWN_CLAS_IGNORED endif endif enddo if ( self % error > 0 ) then if ((( self % error == ERROR_UNKNOWN ). and .(. not . self % ignore_unknown_clas )). or .( self % error /= ERROR_UNKNOWN )) then if ( present ( error )) error = self % error return else self % error_unknown_clas = ERROR_UNKNOWN_CLAS_IGNORED endif endif ! check mutually exclusive interaction call self % check_m_exclusive ( pref = pref ) self % is_parsed_ = . true . ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine parse","tags":"","loc":"proc/parse~2.html"},{"title":"get_clasg_indexes – FLAP","text":"private subroutine get_clasg_indexes(self, ai) Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Contents Source Code get_clasg_indexes Source Code subroutine get_clasg_indexes ( self , ai ) !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. allocate ( ai ( 0 : size ( self % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( self % args )) then Na = size ( self % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( self % is_defined_group ( group = trim ( self % args ( a )), g = g )) then found = . true . self % clasg ( g )% is_called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( self % is_defined_group ( group = trim ( self % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 self % clasg ( 0 )% is_called = . true . elseif ( all ( ai == 0 )) then self % clasg ( 0 )% is_called = . true . endif else self % clasg ( 0 )% is_called = . true . endif endsubroutine get_clasg_indexes","tags":"","loc":"proc/get_clasg_indexes.html"},{"title":"get_args_from_string – FLAP","text":"private subroutine get_args_from_string(self, args, ai) Get CLAs from string. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Calls proc~~get_args_from_string~~CallsGraph proc~get_args_from_string get_args_from_string proc~tokenize tokenize proc~get_args_from_string->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_args_from_string Source Code subroutine get_args_from_string ( self , args , ai ) !< Get CLAs from string. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), intent ( in ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif ! prepare CLI arguments list if ( allocated ( self % args )) deallocate ( self % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate CLI arguments list #ifdef __GFORTRAN__ allocate ( self % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: self % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 self % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call self % get_clasg_indexes ( ai = ai ) contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. character ( * ), intent ( in ) :: argsin !< Arguments string. character ( * ), intent ( in ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t !< Counter. integer ( I4P ) :: tt !< Counter. call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) endfunction sanitize_args endsubroutine get_args_from_string","tags":"","loc":"proc/get_args_from_string.html"},{"title":"get_args_from_invocation – FLAP","text":"private subroutine get_args_from_invocation(self, ai) Get CLAs from CLI invocation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Contents Source Code get_args_from_invocation Source Code subroutine get_args_from_invocation ( self , ai ) !< Get CLAs from CLI invocation. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. if ( allocated ( self % args )) deallocate ( self % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( self % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: self % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) self % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call self % get_clasg_indexes ( ai = ai ) endsubroutine get_args_from_invocation","tags":"","loc":"proc/get_args_from_invocation.html"},{"title":"get_cla – FLAP","text":"private subroutine get_cla(self, val, pref, args, group, switch, position, error) Get CLA (single) value from CLAs list parsed. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val CLA value. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code get_cla Source Code subroutine get_cla ( self , val , pref , args , group , switch , position , error ) !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( self % error == 0. or . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) then if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( position )% error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( self % error == 0. and .(. not . self % clasg ( g )% is_called )) then ! TODO warn (if liked) for non invoked group querying endif if ( present ( error )) error = self % error endsubroutine get_cla","tags":"","loc":"proc/get_cla.html"},{"title":"get_cla_list – FLAP","text":"private subroutine get_cla_list(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val (1:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code get_cla_list Source Code subroutine get_cla_list ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. class ( * ), intent ( inout ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list","tags":"","loc":"proc/get_cla_list.html"},{"title":"get_cla_list_varying_R16P – FLAP","text":"private subroutine get_cla_list_varying_R16P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code get_cla_list_varying_R16P Source Code subroutine get_cla_list_varying_R16P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R16P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_R16P","tags":"","loc":"proc/get_cla_list_varying_r16p.html"},{"title":"get_cla_list_varying_R8P – FLAP","text":"private subroutine get_cla_list_varying_R8P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code get_cla_list_varying_R8P Source Code subroutine get_cla_list_varying_R8P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_R8P","tags":"","loc":"proc/get_cla_list_varying_r8p.html"},{"title":"get_cla_list_varying_R4P – FLAP","text":"private subroutine get_cla_list_varying_R4P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code get_cla_list_varying_R4P Source Code subroutine get_cla_list_varying_R4P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_R4P","tags":"","loc":"proc/get_cla_list_varying_r4p.html"},{"title":"get_cla_list_varying_I8P – FLAP","text":"private subroutine get_cla_list_varying_I8P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code get_cla_list_varying_I8P Source Code subroutine get_cla_list_varying_I8P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I8P","tags":"","loc":"proc/get_cla_list_varying_i8p.html"},{"title":"get_cla_list_varying_I4P – FLAP","text":"private subroutine get_cla_list_varying_I4P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code get_cla_list_varying_I4P Source Code subroutine get_cla_list_varying_I4P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I4P","tags":"","loc":"proc/get_cla_list_varying_i4p.html"},{"title":"get_cla_list_varying_I2P – FLAP","text":"private subroutine get_cla_list_varying_I2P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code get_cla_list_varying_I2P Source Code subroutine get_cla_list_varying_I2P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I2P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I2P","tags":"","loc":"proc/get_cla_list_varying_i2p.html"},{"title":"get_cla_list_varying_I1P – FLAP","text":"private subroutine get_cla_list_varying_I1P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code get_cla_list_varying_I1P Source Code subroutine get_cla_list_varying_I1P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I1P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I1P","tags":"","loc":"proc/get_cla_list_varying_i1p.html"},{"title":"get_cla_list_varying_logical – FLAP","text":"private subroutine get_cla_list_varying_logical(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, logical. Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. logical, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code get_cla_list_varying_logical Source Code subroutine get_cla_list_varying_logical ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. logical , allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_logical","tags":"","loc":"proc/get_cla_list_varying_logical.html"},{"title":"get_cla_list_varying_char – FLAP","text":"private subroutine get_cla_list_varying_char(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, character. Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code get_cla_list_varying_char Source Code subroutine get_cla_list_varying_char ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_char","tags":"","loc":"proc/get_cla_list_varying_char.html"},{"title":"print_usage – FLAP","text":"private subroutine print_usage(self, pref) Print correct usage. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in), optional :: pref Prefixing string. Contents Source Code print_usage Source Code subroutine print_usage ( self , pref ) !< Print correct usage. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. write ( self % usage_lun , '(A)' ) self % usage ( pref = pref , g = 0 ) endsubroutine print_usage","tags":"","loc":"proc/print_usage.html"},{"title":"save_bash_completion – FLAP","text":"private subroutine save_bash_completion(self, bash_file, error) Save bash completion script (for named CLAs only). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: bash_file Output file name of bash completion script. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Contents Source Code save_bash_completion Source Code subroutine save_bash_completion ( self , bash_file , error ) !< Save bash completion script (for named CLAs only). class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: bash_file !< Output file name of bash completion script. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. character ( len = :), allocatable :: script !< Script text. integer ( I4P ) :: g !< CLAs groups counter. integer ( I4P ) :: u !< Unit file handler. script = '#/usr/bin/env bash' if ( size ( self % clasg , dim = 1 ) > 1 ) then script = script // new_line ( 'a' ) // '_completion()' script = script // new_line ( 'a' ) // '{' script = script // new_line ( 'a' ) // '  cur=${COMP_WORDS[COMP_CWORD]}' script = script // new_line ( 'a' ) // '  prev=${COMP_WORDS[COMP_CWORD - 1]}' ! script = script//new_line('a')//'  if [[ $prev == \"--help\" || $prev == \"-h\" || $prev == \"--version\" || $prev == \"-v\" ]] ; then' ! script = script//new_line('a')//'    COMPREPLY=()' ! script = script//new_line('a')//'  else' script = script // new_line ( 'a' ) // '  groups=(' do g = 1 , size ( self % clasg , dim = 1 ) - 1 script = script // ' \"' // self % clasg ( g )% group // '\"' enddo script = script // ' )' ! script = script//new_line('a')//'    base_clas=('//& !          self%clasg(0)%signature(bash_completion=.true., plain=.true.)//' )' ! do g=1,size(self%clasg,dim=1)-1 !   script = script//new_line('a')//'    '//self%clasg(g)%group//'_clas=('//& !            self%clasg(g)%signature(bash_completion=.true., plain=.true.)//' )' ! enddo script = script // new_line ( 'a' ) // '  for g in ${groups[@]}; do' script = script // new_line ( 'a' ) // '    if [ \"$prev\" == \"$g\" ] ; then' script = script // new_line ( 'a' ) // '      group=$prev ' script = script // new_line ( 'a' ) // '    fi' script = script // new_line ( 'a' ) // '  done' ! script = script//new_line('a')//'  fi' script = script // new_line ( 'a' ) // '  if [ \"$group\" == \"' // self % clasg ( 1 )% group // '\" ] ; then' script = script // self % clasg ( 1 )% signature ( bash_completion = . true .) do g = 2 , size ( self % clasg , dim = 1 ) - 1 script = script // new_line ( 'a' ) // '  elif [ \"$group\" == \"' // self % clasg ( g )% group // '\" ] ; then' script = script // self % clasg ( g )% signature ( bash_completion = . true .) enddo script = script // new_line ( 'a' ) // '  else' script = script // '    ' // self % signature ( bash_completion = . true .) script = script // new_line ( 'a' ) // '  fi' script = script // new_line ( 'a' ) // '  return 0' script = script // new_line ( 'a' ) // '}' script = script // new_line ( 'a' ) // 'complete -F _completion ' // basename ( self % progname ) else script = script // new_line ( 'a' ) // 'complete -W \"' // self % signature ( bash_completion = . true .) // '\" ' // basename ( self % progname ) endif open ( newunit = u , file = trim ( adjustl ( bash_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) script else write ( u , \"(A)\" ) script endif close ( u ) contains pure function basename ( progname ) character ( len =* ), intent ( in ) :: progname !< Program name. character ( len = :), allocatable :: basename !< Program name without full PATH. integer ( I4P ) :: pos !< Counter. basename = progname pos = index ( basename , '/' , back = . true .) if ( pos > 0 ) then basename = basename ( pos + 1 :) else pos = index ( basename , '\\' , back = . true .) if ( pos > 0 ) basename = basename ( pos + 1 :) endif endfunction basename endsubroutine save_bash_completion","tags":"","loc":"proc/save_bash_completion.html"},{"title":"save_man_page – FLAP","text":"private subroutine save_man_page(self, man_file, error) Save CLI usage as man page. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Calls proc~~save_man_page~~CallsGraph proc~save_man_page save_man_page strz strz proc~save_man_page->strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code save_man_page Source Code subroutine save_man_page ( self , man_file , error ) !< Save CLI usage as man page. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: man_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !< Months list. call date_and_time ( values = idate ) man = '.TH ' // self % progname // ' \"1\" \"' // month ( idate ( 2 )) // ' ' // trim ( adjustl ( strz ( idate ( 1 ), 4 ))) // '\" \"version ' // self % version // & '\" \"' // self % progname // ' Manual\"' man = man // new_line ( 'a' ) // '.SH NAME' man = man // new_line ( 'a' ) // self % progname // ' - manual page for ' // self % progname // ' version ' // self % version man = man // new_line ( 'a' ) // '.SH SYNOPSIS' man = man // new_line ( 'a' ) // '.B ' // self % progname // new_line ( 'a' ) // trim ( adjustl ( self % signature ())) if ( self % description /= '' ) man = man // new_line ( 'a' ) // '.SH DESCRIPTION' // new_line ( 'a' ) // self % description if ( self % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // '.SH OPTIONS' man = man // new_line ( 'a' ) // self % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 ) endif if ( allocated ( self % examples )) then man = man // new_line ( 'a' ) // '.SH EXAMPLES' man = man // new_line ( 'a' ) // '.PP' man = man // new_line ( 'a' ) // '.nf' man = man // new_line ( 'a' ) // '.RS' do e = 1 , size ( self % examples , dim = 1 ) man = man // new_line ( 'a' ) // trim ( self % examples ( e )) enddo man = man // new_line ( 'a' ) // '.RE' man = man // new_line ( 'a' ) // '.fi' man = man // new_line ( 'a' ) // '.PP' endif if ( self % authors /= '' ) man = man // new_line ( 'a' ) // '.SH AUTHOR' // new_line ( 'a' ) // self % authors if ( self % license /= '' ) man = man // new_line ( 'a' ) // '.SH COPYRIGHT' // new_line ( 'a' ) // self % license open ( newunit = u , file = trim ( adjustl ( man_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif close ( u ) endsubroutine save_man_page","tags":"","loc":"proc/save_man_page.html"},{"title":"save_usage_to_markdown – FLAP","text":"private subroutine save_usage_to_markdown(self, markdown_file, error) Save CLI usage as markdown. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: markdown_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Calls proc~~save_usage_to_markdown~~CallsGraph proc~save_usage_to_markdown save_usage_to_markdown strz strz proc~save_usage_to_markdown->strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code save_usage_to_markdown Source Code subroutine save_usage_to_markdown ( self , markdown_file , error ) !< Save CLI usage as markdown. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: markdown_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !< Months list. call date_and_time ( values = idate ) man = '# ' // self % progname // new_line ( 'a' ) man = man // new_line ( 'a' ) // 'Manual page for `' // self % progname // '` version ' // self % version // new_line ( 'a' ) man = man // new_line ( 'a' ) // '`' // self % progname // ' ' // trim ( adjustl ( self % signature ())) // '`' // new_line ( 'a' ) man = man // new_line ( 'a' ) // month ( idate ( 2 )) // ' ' // trim ( adjustl ( strz ( idate ( 1 ), 4 ))) // new_line ( 'a' ) if ( self % description /= '' ) man = man // new_line ( 'a' ) // '### Short description' // new_line ( 'a' ) // new_line ( 'a' ) // self % description if ( self % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // new_line ( 'a' ) // '### Command line options:' man = man // self % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 , markdown = . true .) endif if ( allocated ( self % examples )) then man = man // new_line ( 'a' ) // new_line ( 'a' ) // '### Examples' do e = 1 , size ( self % examples , dim = 1 ) man = man // new_line ( 'a' ) man = man // new_line ( 'a' ) // '`' // trim ( self % examples ( e )) // '` ' enddo endif open ( newunit = u , file = trim ( adjustl ( markdown_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif close ( u ) endsubroutine save_usage_to_markdown","tags":"","loc":"proc/save_usage_to_markdown.html"},{"title":"errored – FLAP","text":"private subroutine errored(self, error, pref, group, switch) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self Object data. integer(kind=I4P), intent(in) :: error Error occurred. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: group Group name. character, intent(in), optional :: switch CLA switch name. Calls proc~~errored~2~~CallsGraph proc~errored~2 errored interface~colorize colorize proc~errored~2->interface~colorize proc~colorize_default colorize_default interface~colorize->proc~colorize_default proc~color_index color_index proc~colorize_default->proc~color_index proc~upper upper proc~colorize_default->proc~upper proc~style_index style_index proc~colorize_default->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code errored Source Code subroutine errored ( self , error , pref , group , switch ) !< Trig error occurrence and print meaningful message. class ( command_line_interface ), intent ( inout ) :: self !< Object data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: group !< Group name. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( len = :), allocatable :: prefd !< Prefixing string. self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref prefd = prefd // self % progname // ': ' // colorize ( 'error' , color_fg = self % error_color , style = self % error_style ) select case ( self % error ) case ( ERROR_MISSING_CLA ) self % error_message = prefd // ': there is no option \"' // trim ( adjustl ( switch )) // '\"!' case ( ERROR_MISSING_SELECTION_CLA ) self % error_message = prefd // ': to get an option value one of switch \"name\" or \"position\" must be provided!' case ( ERROR_MISSING_GROUP ) self % error_message = prefd // ': ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( ERROR_TOO_FEW_CLAS ) ! self%error_message = prefd//': too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,self%Na_required))//')' endselect write ( self % error_lun , '(A)' ) call self % print_error_message endif endsubroutine errored","tags":"","loc":"proc/errored~2.html"},{"title":"cli_assign_cli – FLAP","text":"private elemental subroutine cli_assign_cli(lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: lhs Left hand side. type( command_line_interface ), intent(in) :: rhs Right hand side. Contents Source Code cli_assign_cli Source Code elemental subroutine cli_assign_cli ( lhs , rhs ) !< Assignment operator. class ( command_line_interface ), intent ( inout ) :: lhs !< Left hand side. type ( command_line_interface ), intent ( in ) :: rhs !< Right hand side. ! object members call lhs % assign_object ( rhs ) ! command_line_interface members if ( allocated ( rhs % clasg )) lhs % clasg = rhs % clasg if ( allocated ( rhs % examples )) lhs % examples = rhs % examples lhs % disable_hv = rhs % disable_hv endsubroutine cli_assign_cli","tags":"","loc":"proc/cli_assign_cli.html"},{"title":"finalize – FLAP","text":"private elemental subroutine finalize(self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_interface ), intent(inout) :: self CLI data. Contents Source Code finalize Source Code elemental subroutine finalize ( self ) !< Free dynamic memory when finalizing. type ( command_line_interface ), intent ( inout ) :: self !< CLI data. call self % free endsubroutine finalize","tags":"","loc":"proc/finalize~2.html"},{"title":"is_required_passed – FLAP","text":"private function is_required_passed(self, pref) result(is_ok) Check if required CLA is passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Return Value logical Check result. Contents Source Code is_required_passed Source Code function is_required_passed ( self , pref ) result ( is_ok ) !< Check if required CLA is passed. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical :: is_ok !< Check result. is_ok = . true . if (((. not . self % is_passed ). and . self % is_required ). or .((. not . self % is_passed ). and .(. not . allocated ( self % def )))) then call self % errored ( pref = pref , error = ERROR_MISSING_REQUIRED ) is_ok = . false . endif endfunction is_required_passed","tags":"","loc":"proc/is_required_passed~2.html"},{"title":"usage – FLAP","text":"private function usage(self, pref, markdown) Get correct usage. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLAs group data. character, intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: markdown Format for markdown Return Value character(len=:),allocatable Usage string. Calls proc~~usage~3~~CallsGraph proc~usage~3 usage interface~colorize colorize proc~usage~3->interface~colorize proc~replace_all replace_all proc~usage~3->proc~replace_all str str proc~usage~3->str cton cton proc~usage~3->cton proc~colorize_default colorize_default interface~colorize->proc~colorize_default proc~replace replace proc~replace_all->proc~replace proc~wstrip wstrip proc~replace_all->proc~wstrip proc~color_index color_index proc~colorize_default->proc~color_index proc~upper upper proc~colorize_default->proc~upper proc~style_index style_index proc~colorize_default->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code usage Source Code function usage ( self , pref , markdown ) !< Get correct usage. class ( command_line_argument ), intent ( in ) :: self !< CLAs group data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: markdown !< Format for markdown character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: switch_ !< Switch name, local variable. character ( len = :), allocatable :: switch_ab_ !< Abbreviated switch name, local variable. integer ( I4P ) :: a !< Counter. logical :: markdownd !< Format for markdown integer :: indent !< how many spaces to indent markdownd = . false . ; if ( present ( markdown )) markdownd = markdown indent = 4 switch_ = colorize ( trim ( adjustl ( self % switch )), color_fg = self % help_color , style = self % help_style ) switch_ab_ = colorize ( trim ( adjustl ( self % switch_ab )), color_fg = self % help_color , style = self % help_style ) if (. not . self % is_hidden ) then if ( self % act == action_store ) then if (. not . self % is_positional ) then if ( allocated ( self % nargs )) then usage = '' select case ( self % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( self % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str ( a , . true .)) enddo endselect if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // usage // '`, `' // trim ( adjustl ( self % switch_ab )) // usage // '`' else usage = '   ' // switch_ // usage // ', ' // switch_ab_ // usage endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // usage // '`' else usage = '   ' // switch_ // usage endif endif else if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // ' value`, `' // trim ( adjustl ( self % switch_ab )) // ' value' // '`' else usage = '   ' // switch_ // ' value, ' // switch_ab_ // ' value' endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // ' value`' else usage = '   ' // switch_ // ' value' endif endif endif else usage = '  value' endif if ( allocated ( self % choices )) then usage = usage // ', value in: `' // self % choices // '`' endif elseif ( self % act == action_store_star ) then usage = '  [value]' if ( allocated ( self % choices )) then usage = usage // ', value in: (' // self % choices // ')' endif else if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // '`, `' // trim ( adjustl ( self % switch_ab )) // '`' else usage = '   ' // switch_ // ', ' // switch_ab_ endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // '`' else usage = '   ' // switch_ endif endif endif prefd = '' ; if ( present ( pref )) prefd = pref usage = prefd // usage if ( self % is_positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // trim ( str ( self % position , . true .)) // & '-th argument' if ( allocated ( self % envvar )) then if ( self % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( self % envvar )) // '\"' endif endif if (. not . self % is_required ) then if ( self % def /= '' ) then if ( markdownd ) then ! two spaces make a line break in markdown. usage = usage // '  ' // new_line ( 'a' ) // prefd // repeat ( ' ' , 4 ) // 'default value ' // trim ( replace_all ( self % def , ARGS_SEP , ' ' )) else usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // 'default value ' // trim ( replace_all ( self % def , ARGS_SEP , ' ' )) endif endif endif if ( self % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // 'mutually exclude \"' // self % m_exclude // '\"' if ( markdownd ) then usage = usage // '  ' // new_line ( 'a' ) // prefd // repeat ( ' ' , 4 ) // trim ( adjustl ( self % help )) if ( self % help_markdown /= '' ) then usage = usage // trim ( adjustl ( self % help_markdown )) endif else usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // trim ( adjustl ( self % help )) endif else usage = '' endif endfunction usage","tags":"","loc":"proc/usage~3.html"},{"title":"signature – FLAP","text":"private function signature(self, bash_completion, plain) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLA data. logical, intent(in), optional :: bash_completion Return the signature for bash completion. logical, intent(in), optional :: plain Return the signature as plain switches list. Return Value character(len=:),allocatable Signature. Calls proc~~signature~3~~CallsGraph proc~signature~3 signature cton cton proc~signature~3->cton str str proc~signature~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code signature Source Code function signature ( self , bash_completion , plain ) !< Get signature. class ( command_line_argument ), intent ( in ) :: self !< CLA data. logical , optional , intent ( in ) :: bash_completion !< Return the signature for bash completion. logical , optional , intent ( in ) :: plain !< Return the signature as plain switches list. logical :: plain_ !< Return the signature as plain switches list, local var. logical :: bash_completion_ !< Return the signature for bash completion, local variable. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. bash_completion_ = . false . ; if ( present ( bash_completion )) bash_completion_ = bash_completion plain_ = . false . ; if ( present ( plain )) plain_ = plain if (. not . self % is_hidden ) then if ( bash_completion_ ) then if (. not . self % is_positional ) then if ( plain_ ) then if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then signature = ' ' // trim ( adjustl ( self % switch )) // ' ' // trim ( adjustl ( self % switch_ab )) else signature = ' ' // trim ( adjustl ( self % switch )) endif else signature = new_line ( 'a' ) // '    if [ \"$prev\" == \"' // self % switch // '\" ] || [ \"$prev\" == \"' // self % switch_ab // '\" ] ; then' if ( self % has_choices ()) then signature = signature // new_line ( 'a' ) // '       COMPREPLY=( $( compgen -W \"' // choices ( self % choices ) // '\" -- $cur ) )' elseif (( self % act == action_store ). or .( self % act == action_store_star )) then signature = signature // new_line ( 'a' ) // '       COMPREPLY=( )' endif signature = signature // new_line ( 'a' ) // '       return 0' signature = signature // new_line ( 'a' ) // '    fi' endif ! if (trim(adjustl(self%switch))/=trim(adjustl(self%switch_ab))) then ! if (plain_) then !   signature = ' \"'//trim(adjustl(self%switch))//'\" \"'//trim(adjustl(self%switch_ab))//'\"' ! else ! signature = ' '//trim(adjustl(self%switch))//' '//trim(adjustl(self%switch_ab)) ! endif ! else ! if (plain_) then !   signature = ' \"'//trim(adjustl(self%switch))//'\"' ! else ! signature = ' '//trim(adjustl(self%switch)) ! endif ! endif endif else if ( self % act == action_store ) then if (. not . self % is_positional ) then if ( allocated ( self % nargs )) then select case ( self % nargs ) case ( '+' ) signature = ' value#1 [value#2 value#3...]' case ( '*' ) signature = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( self % nargs )), knd = 1_I4P ) signature = '' do a = 1 , nargs signature = signature // ' value#' // trim ( str ( a , . true .)) enddo endselect else signature = ' value' endif if ( self % is_required ) then signature = ' ' // trim ( adjustl ( self % switch )) // signature else signature = ' [' // trim ( adjustl ( self % switch )) // signature // ']' endif else if ( self % is_required ) then signature = ' value' else signature = ' [value]' endif endif elseif ( self % act == action_store_star ) then signature = ' [value]' else if ( self % is_required ) then signature = ' ' // trim ( adjustl ( self % switch )) else signature = ' [' // trim ( adjustl ( self % switch )) // ']' endif endif endif else signature = '' endif contains pure function choices ( choices_c ) !< Return space-separated choices list from a comma-separated one. character ( len =* ), intent ( in ) :: choices_c !< Comma-separated list of choices. character ( len = len ( choices_c )) :: choices !< Space-separated list of choices. integer ( I4P ) :: c !< Counter. choices = choices_c do c = 1 , len ( choices ) if ( choices ( c : c ) == ',' ) choices ( c : c ) = ' ' enddo endfunction choices endfunction signature","tags":"","loc":"proc/signature~3.html"},{"title":"has_choices – FLAP","text":"private pure function has_choices(self) Return true if CLA has choices. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLA data. Return Value logical Check result. Contents Source Code has_choices Source Code pure function has_choices ( self ) !< Return true if CLA has choices. class ( command_line_argument ), intent ( in ) :: self !< CLA data. logical :: has_choices !< Check result. has_choices = allocated ( self % choices ) endfunction has_choices","tags":"","loc":"proc/has_choices.html"},{"title":"check_list_size – FLAP","text":"private function check_list_size(self, Nv, val, pref) result(is_ok) Check CLA multiple values list size consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character, intent(in) :: val First value. character, intent(in), optional :: pref Prefixing string. Return Value logical Check result. Contents Source Code check_list_size Source Code function check_list_size ( self , Nv , val , pref ) result ( is_ok ) !< Check CLA multiple values list size consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I4P ), intent ( in ) :: Nv !< Number of values. character ( * ), intent ( in ) :: val !< First value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical :: is_ok !< Check result. is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( self % nargs == '+' ) then call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endif endif endif endfunction check_list_size","tags":"","loc":"proc/check_list_size.html"},{"title":"free – FLAP","text":"private elemental subroutine free(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. Contents Source Code free Source Code elemental subroutine free ( self ) !< Free dynamic memory. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. ! object members call self % free_object ! command_line_argument members if ( allocated ( self % switch )) deallocate ( self % switch ) if ( allocated ( self % switch_ab )) deallocate ( self % switch_ab ) if ( allocated ( self % act )) deallocate ( self % act ) if ( allocated ( self % def )) deallocate ( self % def ) if ( allocated ( self % nargs )) deallocate ( self % nargs ) if ( allocated ( self % choices )) deallocate ( self % choices ) if ( allocated ( self % val )) deallocate ( self % val ) if ( allocated ( self % envvar )) deallocate ( self % envvar ) self % is_required = . false . self % is_positional = . false . self % position = 0_I4P self % is_passed = . false . self % is_hidden = . false . endsubroutine free","tags":"","loc":"proc/free~3.html"},{"title":"check – FLAP","text":"private subroutine check(self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Contents Source Code check Source Code subroutine check ( self , pref ) !< Check data consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % check_envvar_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_action_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_optional_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_m_exclude_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_named_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_positional_consistency ( pref = pref ) endsubroutine check","tags":"","loc":"proc/check~3.html"},{"title":"raise_error_m_exclude – FLAP","text":"private subroutine raise_error_m_exclude(self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Contents Source Code raise_error_m_exclude Source Code subroutine raise_error_m_exclude ( self , pref ) !< Raise error mutually exclusive CLAs passed. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_M_EXCLUDE ) endsubroutine raise_error_m_exclude","tags":"","loc":"proc/raise_error_m_exclude~2.html"},{"title":"raise_error_nargs_insufficient – FLAP","text":"private subroutine raise_error_nargs_insufficient(self, pref) Raise error insufficient number of argument values passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Contents Source Code raise_error_nargs_insufficient Source Code subroutine raise_error_nargs_insufficient ( self , pref ) !< Raise error insufficient number of argument values passed. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endsubroutine raise_error_nargs_insufficient","tags":"","loc":"proc/raise_error_nargs_insufficient.html"},{"title":"raise_error_value_missing – FLAP","text":"private subroutine raise_error_value_missing(self, pref) Raise error missing value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Contents Source Code raise_error_value_missing Source Code subroutine raise_error_value_missing ( self , pref ) !< Raise error missing value. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_VALUE_MISSING ) endsubroutine raise_error_value_missing","tags":"","loc":"proc/raise_error_value_missing.html"},{"title":"raise_error_switch_unknown – FLAP","text":"private subroutine raise_error_switch_unknown(self, switch, pref) Raise error switch_unknown. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: switch CLA switch name. character, intent(in), optional :: pref Prefixing string. Contents Source Code raise_error_switch_unknown Source Code subroutine raise_error_switch_unknown ( self , switch , pref ) !< Raise error switch_unknown. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_UNKNOWN , switch = switch ) endsubroutine raise_error_switch_unknown","tags":"","loc":"proc/raise_error_switch_unknown.html"},{"title":"raise_error_duplicated_clas – FLAP","text":"private subroutine raise_error_duplicated_clas(self, switch, pref) Raise error duplicated CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: switch CLA switch name. character, intent(in), optional :: pref Prefixing string. Contents Source Code raise_error_duplicated_clas Source Code subroutine raise_error_duplicated_clas ( self , switch , pref ) !< Raise error duplicated CLAs passed. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_DUPLICATED_CLAS , switch = switch ) endsubroutine raise_error_duplicated_clas","tags":"","loc":"proc/raise_error_duplicated_clas.html"},{"title":"sanitize_defaults – FLAP","text":"private subroutine sanitize_defaults(self) Sanitize defaults values. It is necessary to sanitize the default values of non-passed, optional CLA. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLAsG data. Calls proc~~sanitize_defaults~2~~CallsGraph proc~sanitize_defaults~2 sanitize_defaults proc~wstrip wstrip proc~sanitize_defaults~2->proc~wstrip proc~unique unique proc~sanitize_defaults~2->proc~unique proc~replace_all replace_all proc~sanitize_defaults~2->proc~replace_all proc~replace_all->proc~wstrip proc~replace replace proc~replace_all->proc~replace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sanitize_defaults Source Code subroutine sanitize_defaults ( self ) !< Sanitize defaults values. !< !< It is necessary to *sanitize* the default values of non-passed, optional CLA. class ( command_line_argument ), intent ( inout ) :: self !< CLAsG data. if (. not . self % is_passed ) then if ( allocated ( self % def )) then ! strip leading and trailing white spaces self % def = wstrip ( self % def ) if ( allocated ( self % nargs )) then ! replace white space separator with FLAP ARGS_SEP self % def = unique ( string = self % def , substring = ' ' ) self % def = replace_all ( string = self % def , substring = ' ' , restring = ARGS_SEP ) endif endif endif endsubroutine sanitize_defaults","tags":"","loc":"proc/sanitize_defaults~2.html"},{"title":"errored – FLAP","text":"private subroutine errored(self, error, pref, switch, val_str, log_value) Trig error occurence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: error Error occurred. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: switch CLA switch name. character, intent(in), optional :: val_str Value string. character, intent(in), optional :: log_value Logical value to be casted. Calls proc~~errored~3~~CallsGraph proc~errored~3 errored interface~colorize colorize proc~errored~3->interface~colorize str str proc~errored~3->str proc~colorize_default colorize_default interface~colorize->proc~colorize_default proc~color_index color_index proc~colorize_default->proc~color_index proc~upper upper proc~colorize_default->proc~upper proc~style_index style_index proc~colorize_default->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code errored Source Code subroutine errored ( self , error , pref , switch , val_str , log_value ) !< Trig error occurence and print meaningful message. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: val_str !< Value string. character ( * ), optional , intent ( in ) :: log_value !< Logical value to be casted. character ( len = :), allocatable :: prefd !< Prefixing string. self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref prefd = prefd // self % progname // ': ' // colorize ( 'error' , color_fg = self % error_color , style = self % error_style ) select case ( self % error ) case ( ERROR_OPTIONAL_NO_DEF ) if ( self % is_positional ) then self % error_message = prefd // ': \"' // trim ( str ( n = self % position )) // '-th\" positional option has not a default value!' else self % error_message = prefd // ': named option \"' // self % switch // '\" has not a default value!' endif case ( ERROR_REQUIRED_M_EXCLUDE ) self % error_message = prefd // ': named option \"' // self % switch // '\" cannot exclude others' // & ', it being required, only optional ones can!' case ( ERROR_POSITIONAL_M_EXCLUDE ) self % error_message = prefd // ': \"' // trim ( str ( n = self % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( ERROR_NAMED_NO_NAME ) self % error_message = prefd // ': a non positional optiona must have a switch name!' case ( ERROR_POSITIONAL_NO_POSITION ) self % error_message = prefd // ': a positional option must have a position number different from 0!' case ( ERROR_POSITIONAL_NO_STORE ) self % error_message = prefd // ': a positional option must have action set to \"' // action_store // '\"!' case ( ERROR_M_EXCLUDE ) self % error_message = prefd // ': the options \"' // self % switch // '\" and \"' // self % m_exclude // & '\" are mutually exclusive, but both have been passed!' case ( ERROR_NOT_IN_CHOICES ) if ( self % is_positional ) then self % error_message = prefd // ': value of \"' // trim ( str ( n = self % position )) // & '-th\" positional option must be chosen in:' else self % error_message = prefd // ': value of named option \"' // self % switch // '\" must be chosen in: ' endif self % error_message = self % error_message // '(' // self % choices // ')' self % error_message = self % error_message // ' but \"' // trim ( val_str ) // '\" has been passed!' case ( ERROR_MISSING_REQUIRED ) if (. not . self % is_positional ) then self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" is required!' else self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option is required!' endif case ( ERROR_CASTING_LOGICAL ) self % error_message = prefd // ': cannot convert \"' // log_value // '\" of option \"' // self % switch // '\" to logical type!' case ( ERROR_CHOICES_LOGICAL ) self % error_message = prefd // ': cannot use \"choices\" value check for option \"' // self % switch // & '\" it being of logical type! The choices are limited to \".true.\" or \".false.\" by definition!' case ( ERROR_NO_LIST ) if (. not . self % is_positional ) then self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" has not \"nargs\" value but an array has been passed to \"get\" method!' else self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( ERROR_NARGS_INSUFFICIENT ) if (. not . self % is_positional ) then if ( self % nargs == '+' ) then self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" requires at least 1 argument but no one remains!' else self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" requires ' // & trim ( adjustl ( self % nargs )) // ' arguments but no enough ones remain!' endif else if ( self % nargs == '+' ) then self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // & '-th\" positional option requires at least 1 argument but no one remains' else self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option requires ' // & trim ( adjustl ( self % nargs )) // ' arguments but no enough ones remain!' endif endif case ( ERROR_VALUE_MISSING ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" needs a value that is not passed!' case ( ERROR_UNKNOWN ) self % error_message = prefd // ': switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( ERROR_ENVVAR_POSITIONAL ) self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( ERROR_ENVVAR_NOT_STORE ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( ERROR_ENVVAR_NARGS ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( ERROR_STORE_STAR_POSITIONAL ) self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( ERROR_STORE_STAR_NARGS ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( ERROR_STORE_STAR_ENVVAR ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( ERROR_ACTION_UNKNOWN ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" has unknown \"' // self % act // '\" action!' case ( ERROR_DUPLICATED_CLAS ) self % error_message = prefd // ': switch \"' // trim ( adjustl ( switch )) // '\" has been passed more than once!' endselect call self % print_error_message endif endsubroutine errored","tags":"","loc":"proc/errored~3.html"},{"title":"check_envvar_consistency – FLAP","text":"private subroutine check_envvar_consistency(self, pref) Check data consistency for envvar CLA. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Contents Source Code check_envvar_consistency Source Code subroutine check_envvar_consistency ( self , pref ) !< Check data consistency for envvar CLA. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if ( allocated ( self % envvar )) then if ( self % is_positional ) then call self % errored ( pref = pref , error = ERROR_ENVVAR_POSITIONAL ) return endif if (. not . allocated ( self % act )) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NOT_STORE ) return else if ( self % act /= action_store ) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NOT_STORE ) return endif endif if ( allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NARGS ) return endif endif endsubroutine check_envvar_consistency","tags":"","loc":"proc/check_envvar_consistency.html"},{"title":"check_action_consistency – FLAP","text":"private subroutine check_action_consistency(self, pref) Check CLA action consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Contents Source Code check_action_consistency Source Code subroutine check_action_consistency ( self , pref ) !< Check CLA action consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if ( allocated ( self % act )) then if ( self % act == ACTION_STORE_STAR . and . self % is_positional ) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_POSITIONAL ) return endif if ( self % act == ACTION_STORE_STAR . and . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_NARGS ) return endif if ( self % act == ACTION_STORE_STAR . and . allocated ( self % envvar )) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_ENVVAR ) return endif if ( self % act /= ACTION_STORE . and . & self % act /= ACTION_STORE_STAR . and . & self % act /= ACTION_STORE_TRUE . and . & self % act /= ACTION_STORE_FALSE . and .& self % act /= ACTION_PRINT_HELP . and . & self % act /= ACTION_PRINT_VERS ) then call self % errored ( pref = pref , error = ERROR_ACTION_UNKNOWN ) return endif endif endsubroutine check_action_consistency","tags":"","loc":"proc/check_action_consistency.html"},{"title":"check_optional_consistency – FLAP","text":"private subroutine check_optional_consistency(self, pref) Check optional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Contents Source Code check_optional_consistency Source Code subroutine check_optional_consistency ( self , pref ) !< Check optional CLA consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if ((. not . self % is_required ). and .(. not . allocated ( self % def ))) call self % errored ( pref = pref , error = ERROR_OPTIONAL_NO_DEF ) endsubroutine check_optional_consistency","tags":"","loc":"proc/check_optional_consistency.html"},{"title":"check_m_exclude_consistency – FLAP","text":"private subroutine check_m_exclude_consistency(self, pref) Check mutually exclusion consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Contents Source Code check_m_exclude_consistency Source Code subroutine check_m_exclude_consistency ( self , pref ) !< Check mutually exclusion consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if (( self % is_required ). and .( self % m_exclude /= '' )) then call self % errored ( pref = pref , error = ERROR_REQUIRED_M_EXCLUDE ) return endif if (( self % is_positional ). and .( self % m_exclude /= '' )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_M_EXCLUDE ) return endif endsubroutine check_m_exclude_consistency","tags":"","loc":"proc/check_m_exclude_consistency.html"},{"title":"check_named_consistency – FLAP","text":"private subroutine check_named_consistency(self, pref) Check named CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Contents Source Code check_named_consistency Source Code subroutine check_named_consistency ( self , pref ) !< Check named CLA consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if ((. not . self % is_positional ). and .(. not . allocated ( self % switch ))) call self % errored ( pref = pref , error = ERROR_NAMED_NO_NAME ) endsubroutine check_named_consistency","tags":"","loc":"proc/check_named_consistency.html"},{"title":"check_positional_consistency – FLAP","text":"private subroutine check_positional_consistency(self, pref) Check positional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Contents Source Code check_positional_consistency Source Code subroutine check_positional_consistency ( self , pref ) !< Check positional CLA consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if (( self % is_positional ). and .( self % position == 0_I4P )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_NO_POSITION ) return elseif (( self % is_positional ). and .( self % act /= action_store )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_NO_STORE ) endif endsubroutine check_positional_consistency","tags":"","loc":"proc/check_positional_consistency.html"},{"title":"check_choices – FLAP","text":"private subroutine check_choices(self, val, pref) Check if CLA value is in allowed choices. Note This procedure can be called if and only if cla%choices has been allocated. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(in) :: val CLA value. character, intent(in), optional :: pref Prefixing string. Calls proc~~check_choices~~CallsGraph proc~check_choices check_choices proc~tokenize tokenize proc~check_choices->proc~tokenize str str proc~check_choices->str cton cton proc~check_choices->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code check_choices Source Code subroutine check_choices ( self , val , pref ) !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. class ( * ), intent ( in ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( len ( self % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. val_in = . false . val_str = '' tmp = self % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #if defined _R16P type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo type is ( logical ) call self % errored ( pref = pref , error = ERROR_CHOICES_LOGICAL ) endselect if (. not . val_in . and .( self % error == 0 )) then call self % errored ( pref = pref , error = ERROR_NOT_IN_CHOICES , val_str = val_str ) endif endsubroutine check_choices","tags":"","loc":"proc/check_choices.html"},{"title":"get_cla – FLAP","text":"private subroutine get_cla(self, val, pref) Get CLA (single) value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(inout) :: val CLA value. character, intent(in), optional :: pref Prefixing string. Contents Source Code get_cla Source Code subroutine get_cla ( self , val , pref ) !< Get CLA (single) value. implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if (. not . self % is_required_passed ( pref = pref )) return if ( self % act == action_store . or . self % act == action_store_star ) then if ( self % is_passed . and . allocated ( self % val )) then call self % get_cla_from_buffer ( buffer = self % val , val = val , pref = pref ) elseif ( allocated ( self % def )) then ! using default value call self % get_cla_from_buffer ( buffer = self % def , val = val , pref = pref ) endif if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val , pref = pref ) elseif ( self % act == action_store_true ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( self % def )) then select type ( val ) type is ( logical ) read ( self % def , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = self % def ) endselect endif elseif ( self % act == action_store_false ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( self % def )) then select type ( val ) type is ( logical ) read ( self % def , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = self % def ) endselect endif endif endsubroutine get_cla","tags":"","loc":"proc/get_cla~2.html"},{"title":"get_cla_from_buffer – FLAP","text":"private subroutine get_cla_from_buffer(self, buffer, val, pref) Get CLA (single) value from parsed value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val CLA value. character, intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_from_buffer~~CallsGraph proc~get_cla_from_buffer get_cla_from_buffer cton cton proc~get_cla_from_buffer->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_cla_from_buffer Source Code subroutine get_cla_from_buffer ( self , buffer , val , pref ) !< Get CLA (single) value from parsed value. implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), intent ( in ) :: buffer !< Buffer containing values (parsed or default CLA value). class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. select type ( val ) #if defined _R16P type is ( real ( R16P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I1P ) type is ( logical ) read ( buffer , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = buffer ) type is ( character ( * )) val = buffer endselect endsubroutine get_cla_from_buffer","tags":"","loc":"proc/get_cla_from_buffer.html"},{"title":"get_cla_list – FLAP","text":"private subroutine get_cla_list(self, pref, val) Get CLA multiple values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. Calls proc~~get_cla_list~2~~CallsGraph proc~get_cla_list~2 get_cla_list proc~tokenize tokenize proc~get_cla_list~2->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_cla_list Source Code subroutine get_cla_list ( self , pref , val ) !< Get CLA multiple values. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. class ( * ), intent ( inout ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call self % get_cla_list_from_buffer ( buffer = self % val , val = val , pref = pref ) else ! using default value call self % get_cla_list_from_buffer ( buffer = self % def , val = val , pref = pref ) endif elseif ( self % act == action_store_true ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = self % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( self % act == action_store_false ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = self % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif endsubroutine get_cla_list","tags":"","loc":"proc/get_cla_list~2.html"},{"title":"get_cla_list_from_buffer – FLAP","text":"private subroutine get_cla_list_from_buffer(self, buffer, val, pref) Get CLA multiple values from a buffer. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val (1:) CLA value. character, intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_from_buffer~~CallsGraph proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~tokenize tokenize proc~get_cla_list_from_buffer->proc~tokenize cton cton proc~get_cla_list_from_buffer->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_cla_list_from_buffer Source Code subroutine get_cla_list_from_buffer ( self , buffer , val , pref ) !< Get CLA multiple values from a buffer. implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), intent ( in ) :: buffer !< Buffer containing values (parsed or default CLA value). class ( * ), intent ( inout ) :: val ( 1 :) !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( buffer )), allocatable :: vals (:) !< String array of values based on buffer value. integer ( I4P ) :: v !< Values counter. call tokenize ( strin = buffer , delimiter = args_sep , toks = vals , Nt = Nv ) select type ( val ) #if defined _R16P type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R16P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R8P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R4P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I8P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I4P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I2P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I1P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( vals ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = vals ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = vals ( v ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo endselect endsubroutine get_cla_list_from_buffer","tags":"","loc":"proc/get_cla_list_from_buffer.html"},{"title":"get_cla_list_varying_R16P – FLAP","text":"private subroutine get_cla_list_varying_R16P(self, val, pref) Get CLA (multiple) value with varying size, real(R16P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_r16p~2~~CallsGraph proc~get_cla_list_varying_r16p~2 get_cla_list_varying_R16P proc~tokenize tokenize proc~get_cla_list_varying_r16p~2->proc~tokenize cton cton proc~get_cla_list_varying_r16p~2->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_cla_list_varying_R16P Source Code subroutine get_cla_list_varying_R16P ( self , val , pref ) !< Get CLA (multiple) value with varying size, real(R16P). class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R16P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( self % nargs == '+' ) then call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_R16P","tags":"","loc":"proc/get_cla_list_varying_r16p~2.html"},{"title":"get_cla_list_varying_R8P – FLAP","text":"private subroutine get_cla_list_varying_R8P(self, val, pref) Get CLA (multiple) value with varying size, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_r8p~2~~CallsGraph proc~get_cla_list_varying_r8p~2 get_cla_list_varying_R8P proc~tokenize tokenize proc~get_cla_list_varying_r8p~2->proc~tokenize cton cton proc~get_cla_list_varying_r8p~2->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_cla_list_varying_R8P Source Code subroutine get_cla_list_varying_R8P ( self , val , pref ) !< Get CLA (multiple) value with varying size, real(R8P). class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_R8P","tags":"","loc":"proc/get_cla_list_varying_r8p~2.html"},{"title":"get_cla_list_varying_R4P – FLAP","text":"private subroutine get_cla_list_varying_R4P(self, val, pref) Get CLA (multiple) value with varying size, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_r4p~2~~CallsGraph proc~get_cla_list_varying_r4p~2 get_cla_list_varying_R4P proc~tokenize tokenize proc~get_cla_list_varying_r4p~2->proc~tokenize cton cton proc~get_cla_list_varying_r4p~2->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_cla_list_varying_R4P Source Code subroutine get_cla_list_varying_R4P ( self , val , pref ) !< Get CLA (multiple) value with varying size, real(R4P). class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_R4P","tags":"","loc":"proc/get_cla_list_varying_r4p~2.html"},{"title":"get_cla_list_varying_I8P – FLAP","text":"private subroutine get_cla_list_varying_I8P(self, val, pref) Get CLA (multiple) value with varying size, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_i8p~2~~CallsGraph proc~get_cla_list_varying_i8p~2 get_cla_list_varying_I8P proc~tokenize tokenize proc~get_cla_list_varying_i8p~2->proc~tokenize cton cton proc~get_cla_list_varying_i8p~2->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_cla_list_varying_I8P Source Code subroutine get_cla_list_varying_I8P ( self , val , pref ) !< Get CLA (multiple) value with varying size, integer(I8P). class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_I8P","tags":"","loc":"proc/get_cla_list_varying_i8p~2.html"},{"title":"get_cla_list_varying_I4P – FLAP","text":"private subroutine get_cla_list_varying_I4P(self, val, pref) Get CLA (multiple) value with varying size, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_i4p~2~~CallsGraph proc~get_cla_list_varying_i4p~2 get_cla_list_varying_I4P proc~tokenize tokenize proc~get_cla_list_varying_i4p~2->proc~tokenize cton cton proc~get_cla_list_varying_i4p~2->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_cla_list_varying_I4P Source Code subroutine get_cla_list_varying_I4P ( self , val , pref ) !< Get CLA (multiple) value with varying size, integer(I4P). class ( command_line_argument ), intent ( INOUT ) :: self !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_I4P","tags":"","loc":"proc/get_cla_list_varying_i4p~2.html"},{"title":"get_cla_list_varying_I2P – FLAP","text":"private subroutine get_cla_list_varying_I2P(self, val, pref) Get CLA (multiple) value with varying size, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_i2p~2~~CallsGraph proc~get_cla_list_varying_i2p~2 get_cla_list_varying_I2P proc~tokenize tokenize proc~get_cla_list_varying_i2p~2->proc~tokenize cton cton proc~get_cla_list_varying_i2p~2->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_cla_list_varying_I2P Source Code subroutine get_cla_list_varying_I2P ( self , val , pref ) !< Get CLA (multiple) value with varying size, integer(I2P). class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I2P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_I2P","tags":"","loc":"proc/get_cla_list_varying_i2p~2.html"},{"title":"get_cla_list_varying_I1P – FLAP","text":"private subroutine get_cla_list_varying_I1P(self, val, pref) Get CLA (multiple) value with varying size, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_i1p~2~~CallsGraph proc~get_cla_list_varying_i1p~2 get_cla_list_varying_I1P proc~tokenize tokenize proc~get_cla_list_varying_i1p~2->proc~tokenize cton cton proc~get_cla_list_varying_i1p~2->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_cla_list_varying_I1P Source Code subroutine get_cla_list_varying_I1P ( self , val , pref ) !< Get CLA (multiple) value with varying size, integer(I1P). class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I1P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_I1P","tags":"","loc":"proc/get_cla_list_varying_i1p~2.html"},{"title":"get_cla_list_varying_logical – FLAP","text":"private subroutine get_cla_list_varying_logical(self, val, pref) Get CLA (multiple) value with varying size, logical. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. logical, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_logical~2~~CallsGraph proc~get_cla_list_varying_logical~2 get_cla_list_varying_logical proc~tokenize tokenize proc~get_cla_list_varying_logical~2->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_cla_list_varying_logical Source Code subroutine get_cla_list_varying_logical ( self , val , pref ) !< Get CLA (multiple) value with varying size, logical. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. logical , allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = valsD ( v )) exit endif enddo endif endif endsubroutine get_cla_list_varying_logical","tags":"","loc":"proc/get_cla_list_varying_logical~2.html"},{"title":"get_cla_list_varying_char – FLAP","text":"private subroutine get_cla_list_varying_char(self, val, pref) Get CLA (multiple) value with varying size, character. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_char~2~~CallsGraph proc~get_cla_list_varying_char~2 get_cla_list_varying_char proc~tokenize tokenize proc~get_cla_list_varying_char~2->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_cla_list_varying_char Source Code subroutine get_cla_list_varying_char ( self , val , pref ) !< Get CLA (multiple) value with varying size, character. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif endsubroutine get_cla_list_varying_char","tags":"","loc":"proc/get_cla_list_varying_char~2.html"},{"title":"cla_assign_cla – FLAP","text":"private elemental subroutine cla_assign_cla(lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: lhs Left hand side. type( command_line_argument ), intent(in) :: rhs Rigth hand side. Contents Source Code cla_assign_cla Source Code elemental subroutine cla_assign_cla ( lhs , rhs ) !< Assignment operator. class ( command_line_argument ), intent ( inout ) :: lhs !< Left hand side. type ( command_line_argument ), intent ( in ) :: rhs !< Rigth hand side. ! object members call lhs % assign_object ( rhs ) ! command_line_argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % is_required = rhs % is_required lhs % is_positional = rhs % is_positional lhs % position = rhs % position lhs % is_passed = rhs % is_passed lhs % is_hidden = rhs % is_hidden endsubroutine cla_assign_cla","tags":"","loc":"proc/cla_assign_cla.html"},{"title":"finalize – FLAP","text":"private elemental subroutine finalize(self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_argument ), intent(inout) :: self CLA data. Contents Source Code finalize Source Code elemental subroutine finalize ( self ) !< Free dynamic memory when finalizing. type ( command_line_argument ), intent ( inout ) :: self !< CLA data. call self % free endsubroutine finalize","tags":"","loc":"proc/finalize~3.html"},{"title":"count_substring – FLAP","text":"private elemental function count_substring(string, substring) result(No) Count the number of occurences of a substring into a string. Arguments Type Intent Optional Attributes Name character, intent(in) :: string String. character, intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Called by proc~~count_substring~~CalledByGraph proc~count_substring count_substring interface~count count interface~count->proc~count_substring Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code count_substring Source Code elemental function count_substring ( string , substring ) result ( No ) !< Count the number of occurences of a substring into a string. character ( * ), intent ( in ) :: string !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. No = 0 if ( len ( substring ) > len ( string )) return c1 = 1 do c2 = index ( string = string ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo endfunction count_substring","tags":"","loc":"proc/count_substring.html"},{"title":"replace – FLAP","text":"public pure function replace(string, substring, restring) result(newstring) Replace substring (only first occurrence) into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. character(len=*), intent(in) :: substring Substring to be replaced. character(len=*), intent(in) :: restring String to be inserted. Return Value character(len=:),allocatable New modified string. Called by proc~~replace~~CalledByGraph proc~replace replace proc~replace_all replace_all proc~replace_all->proc~replace proc~usage~3 usage proc~usage~3->proc~replace_all proc~sanitize_defaults~2 sanitize_defaults proc~sanitize_defaults~2->proc~replace_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code replace Source Code pure function replace ( string , substring , restring ) result ( newstring ) !< Replace substring (only first occurrence) into a string. character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len =* ), intent ( in ) :: substring !< Substring to be replaced. character ( len =* ), intent ( in ) :: restring !< String to be inserted. character ( len = :), allocatable :: newstring !< New modified string. integer ( I4P ) :: pos !< Position from which replace the substring. pos = index ( string = string , substring = substring ) newstring = string if ( pos > 0 ) then if ( pos == 1 ) then newstring = restring // string ( len ( substring ) + 1 :) else newstring = string ( 1 : pos - 1 ) // restring // string ( pos + len ( substring ):) endif endif endfunction replace","tags":"","loc":"proc/replace.html"},{"title":"replace_all – FLAP","text":"public pure function replace_all(string, substring, restring) result(newstring) Replace substring (all occurrences) into a string. Note Leading and trailing white spaces are stripped out. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. character(len=*), intent(in) :: substring Substring to be replaced. character(len=*), intent(in) :: restring String to be inserted. Return Value character(len=:),allocatable New modified string. Calls proc~~replace_all~~CallsGraph proc~replace_all replace_all proc~wstrip wstrip proc~replace_all->proc~wstrip proc~replace replace proc~replace_all->proc~replace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~replace_all~~CalledByGraph proc~replace_all replace_all proc~usage~3 usage proc~usage~3->proc~replace_all proc~sanitize_defaults~2 sanitize_defaults proc~sanitize_defaults~2->proc~replace_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code replace_all Source Code pure function replace_all ( string , substring , restring ) result ( newstring ) !< Replace substring (all occurrences) into a string. !< !< @note Leading and trailing white spaces are stripped out. character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len =* ), intent ( in ) :: substring !< Substring to be replaced. character ( len =* ), intent ( in ) :: restring !< String to be inserted. character ( len = :), allocatable :: newstring !< New modified string. newstring = wstrip ( string ) do if ( index ( newstring , substring ) > 0 ) then newstring = replace ( string = newstring , substring = substring , restring = restring ) else exit endif enddo endfunction replace_all","tags":"","loc":"proc/replace_all.html"},{"title":"unique – FLAP","text":"public elemental function unique(string, substring) result(uniq) Reduce to one (unique) multiple (sequential) occurrences of a characters substring into a string. For example the string ‘ ab-cre-cre-ab’ is reduce to ‘ab-cre-ab’ if the substring is ‘-cre’. Note Eventual multiple trailing white space are not reduced to one occurrence. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be parsed. character(len=*), intent(in) :: substring Substring which multiple occurences must be reduced to one. Return Value character(len=len) String parsed. Called by proc~~unique~~CalledByGraph proc~unique unique proc~sanitize_defaults~2 sanitize_defaults proc~sanitize_defaults~2->proc~unique Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code unique Source Code elemental function unique ( string , substring ) result ( uniq ) !< Reduce to one (unique) multiple (sequential) occurrences of a characters substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. character ( len =* ), intent ( in ) :: string !< String to be parsed. character ( len =* ), intent ( in ) :: substring !< Substring which multiple occurences must be reduced to one. character ( len = len ( string )) :: uniq !< String parsed. integer ( I4P ) :: Lsub !< Lenght of substring. integer ( I4P ) :: c1 !< Counter. integer ( I4P ) :: c2 !< Counter. uniq = string Lsub = len ( substring ) if ( Lsub > len ( string )) return c1 = 1 Loop1 : do if ( c1 >= len_trim ( uniq )) exit Loop1 if ( uniq ( c1 : c1 + Lsub - 1 ) == substring . and . uniq ( c1 + Lsub : c1 + 2 * Lsub - 1 ) == substring ) then c2 = c1 + Lsub Loop2 : do if ( c2 >= len_trim ( uniq )) exit Loop2 if ( uniq ( c2 : c2 + Lsub - 1 ) == substring ) then c2 = c2 + Lsub else exit Loop2 endif enddo Loop2 uniq = uniq ( 1 : c1 ) // uniq ( c2 :) else c1 = c1 + Lsub endif enddo Loop1 endfunction unique","tags":"","loc":"proc/unique.html"},{"title":"upper_case – FLAP","text":"public elemental function upper_case(string) Convert the lower case characters of a string to upper case one. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be converted. Return Value character(len=len) Converted string. Called by proc~~upper_case~~CalledByGraph proc~upper_case upper_case proc~add~2 add proc~add~2->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code upper_case Source Code elemental function upper_case ( string ) !< Convert the lower case characters of a string to upper case one. character ( len =* ), intent ( in ) :: string !< String to be converted. character ( len = len ( string )) :: upper_case !< Converted string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. character ( len = 26 ), parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( len = 26 ), parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. upper_case = string do n1 = 1 , len ( string ) n2 = index ( lower_alphabet , string ( n1 : n1 )) if ( n2 > 0 ) upper_case ( n1 : n1 ) = upper_alphabet ( n2 : n2 ) enddo endfunction upper_case","tags":"","loc":"proc/upper_case.html"},{"title":"wstrip – FLAP","text":"public pure function wstrip(string) result(newstring) Strip out leading and trailing white spaces from a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. Return Value character(len=:),allocatable New modified string. Called by proc~~wstrip~~CalledByGraph proc~wstrip wstrip proc~replace_all replace_all proc~replace_all->proc~wstrip proc~sanitize_defaults~2 sanitize_defaults proc~sanitize_defaults~2->proc~wstrip proc~sanitize_defaults~2->proc~replace_all proc~usage~3 usage proc~usage~3->proc~replace_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code wstrip Source Code pure function wstrip ( string ) result ( newstring ) !< Strip out leading and trailing white spaces from a string. character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len = :), allocatable :: newstring !< New modified string. allocate ( newstring , source = trim ( adjustl ( string ))) endfunction wstrip","tags":"","loc":"proc/wstrip.html"},{"title":"tokenize – FLAP","text":"public pure subroutine tokenize(strin, delimiter, toks, Nt) Tokenize a string in order to parse it. Note The dummy array containing tokens must allocatable and its character elements must have the same length of the input\nstring. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with\nonly one element set to input string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strin String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len), intent(out), allocatable :: toks (:) Tokens. integer(kind=I4P), intent(out), optional :: Nt Number of tokens. Called by proc~~tokenize~~CalledByGraph proc~tokenize tokenize proc~get_args_from_string get_args_from_string proc~get_args_from_string->proc~tokenize proc~check_choices check_choices proc~check_choices->proc~tokenize proc~get_cla_list_varying_r4p~2 get_cla_list_varying_R4P proc~get_cla_list_varying_r4p~2->proc~tokenize proc~get_cla_list_varying_r16p~2 get_cla_list_varying_R16P proc~get_cla_list_varying_r16p~2->proc~tokenize proc~get_cla_list~2 get_cla_list proc~get_cla_list~2->proc~tokenize proc~get_cla_list_varying_i4p~2 get_cla_list_varying_I4P proc~get_cla_list_varying_i4p~2->proc~tokenize proc~get_cla_list_varying_logical~2 get_cla_list_varying_logical proc~get_cla_list_varying_logical~2->proc~tokenize proc~get_cla_list_varying_char~2 get_cla_list_varying_char proc~get_cla_list_varying_char~2->proc~tokenize proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->proc~tokenize proc~get_cla_list_varying_r8p~2 get_cla_list_varying_R8P proc~get_cla_list_varying_r8p~2->proc~tokenize proc~get_cla_list_varying_i8p~2 get_cla_list_varying_I8P proc~get_cla_list_varying_i8p~2->proc~tokenize proc~get_cla_list_varying_i2p~2 get_cla_list_varying_I2P proc~get_cla_list_varying_i2p~2->proc~tokenize proc~get_cla_list_varying_i1p~2 get_cla_list_varying_I1P proc~get_cla_list_varying_i1p~2->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code tokenize Source Code pure subroutine tokenize ( strin , delimiter , toks , Nt ) !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to input string. character ( len =* ), intent ( in ) :: strin !< String to be tokenized. character ( len =* ), intent ( in ) :: delimiter !< Delimiter of tokens. character ( len = len ( strin )), intent ( out ), allocatable :: toks (:) !< Tokens. integer ( I4P ), intent ( out ), optional :: Nt !< Number of tokens. character ( len = len ( strin )) :: strsub !< Temporary string. integer ( I4P ) :: dlen !< Delimiter length. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: n !< Counter. integer ( I4P ) :: t !< Counter. ! initialization if ( allocated ( toks )) deallocate ( toks ) strsub = strin dlen = len ( delimiter ) if ( dlen > len ( strin )) then allocate ( toks ( 1 : 1 )) ; toks ( 1 ) = strin ; if ( present ( Nt )) Nt = 1 ; return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenization do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n endsubroutine tokenize","tags":"","loc":"proc/tokenize.html"},{"title":"count – FLAP","text":"public interface count Overload intrinsic function count for counting substring occurences into strings. Calls interface~~count~~CallsGraph interface~count count proc~count_substring count_substring interface~count->proc~count_substring Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures count_substring Module Procedures private elemental function count_substring (string, substring) result(No) Count the number of occurences of a substring into a string. Arguments Type Intent Optional Attributes Name character, intent(in) :: string String. character, intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences.","tags":"","loc":"interface/count.html"},{"title":"face – FLAP","text":"FACE, Fortran Ansi Colors Environment. Uses iso_fortran_env module~~face~~UsesGraph module~face face iso_fortran_env iso_fortran_env module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~face~~UsedByGraph module~face face module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~face module~flap_command_line_argument_t flap_command_line_argument_t module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t program~face_test_colors face_test_colors program~face_test_colors->module~face module~flap_command_line_interface_t flap_command_line_interface_t module~flap_command_line_interface_t->module~face module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_argument_t->module~face program~face_test_ucs4 face_test_ucs4 program~face_test_ucs4->module~face program~face_test_basic face_test_basic program~face_test_basic->module~face program~face_test_styles face_test_styles program~face_test_styles->module~face module~flap flap module~flap->module~flap_command_line_arguments_group_t module~flap->module~flap_command_line_interface_t module~flap->module~flap_command_line_argument_t program~flap_save_usage_to_markdown flap_save_usage_to_markdown program~flap_save_usage_to_markdown->module~flap program~flap_test_choices_logical flap_test_choices_logical program~flap_test_choices_logical->module~flap program~flap_save_man_page flap_save_man_page program~flap_save_man_page->module~flap program~flap_test_nested flap_test_nested program~flap_test_nested->module~flap program~flap_test_hidden flap_test_hidden program~flap_test_hidden->module~flap program~flap_test_duplicated_clas flap_test_duplicated_clas program~flap_test_duplicated_clas->module~flap program~flap_test_ansi_color_style flap_test_ansi_color_style program~flap_test_ansi_color_style->module~flap program~flap_test_ignore_unknown_clas flap_test_ignore_unknown_clas program~flap_test_ignore_unknown_clas->module~flap program~flap_test_nargs_insufficient flap_test_nargs_insufficient program~flap_test_nargs_insufficient->module~flap program~flap_test_group flap_test_group program~flap_test_group->module~flap program~flap_test_minimal flap_test_minimal program~flap_test_minimal->module~flap program~flap_test_group_examples flap_test_group_examples program~flap_test_group_examples->module~flap program~flap_test_nargs_insufficient~2 flap_test_nargs_insufficient program~flap_test_nargs_insufficient~2->module~flap program~flap_save_bash_completion flap_save_bash_completion program~flap_save_bash_completion->module~flap program~flap_test_string flap_test_string program~flap_test_string->module~flap program~flap_test_basic flap_test_basic program~flap_test_basic->module~flap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables ASCII UCS4 UPPER_ALPHABET LOWER_ALPHABET NL ESCAPE CODE_START CODE_END CODE_CLEAR STYLES COLORS_FG COLORS_BG Interfaces colorize Functions colorize_ascii colorize_default colorize_ucs4 color_index style_index upper Subroutines colors_samples styles_samples Variables Type Visibility Attributes Name Initial integer, public, parameter :: ASCII = selected_char_kind('default') ASCII character set kind. integer, public, parameter :: UCS4 = selected_char_kind('default') Unicode character set kind. character(len=26), private, parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(len=26), private, parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. character(len=1), private, parameter :: NL = new_line('a') New line character. character(len=1), private, parameter :: ESCAPE = achar(27) “\" character. character(len=2), private, parameter :: CODE_START = ESCAPE//'[' Start ansi code, “[“. character(len=1), private, parameter :: CODE_END = 'm' End ansi code, “m”. character(len=4), private, parameter :: CODE_CLEAR = CODE_START//'0'//CODE_END Clear all styles, “[0m”. character(len=17), private, parameter :: STYLES (1:2,1:16) = reshape(['BOLD_ON          ', '1                ', 'ITALICS_ON       ', '3                ', 'UNDERLINE_ON     ', '4                ', 'INVERSE_ON       ', '7                ', 'STRIKETHROUGH_ON ', '9                ', 'BOLD_OFF         ', '22               ', 'ITALICS_OFF      ', '23               ', 'UNDERLINE_OFF    ', '24               ', 'INVERSE_OFF      ', '27               ', 'STRIKETHROUGH_OFF', '29               ', 'FRAMED_ON        ', '51               ', 'ENCIRCLED_ON     ', '52               ', 'OVERLINED_ON     ', '53               ', 'FRAMED_OFF       ', '54               ', 'ENCIRCLED_OFF    ', '54               ', 'OVERLINED_OFF    ', '55               '], [2, 16]) Styles. character(len=15), private, parameter :: COLORS_FG (1:2,1:17) = reshape(['BLACK          ', '30             ', 'RED            ', '31             ', 'GREEN          ', '32             ', 'YELLOW         ', '33             ', 'BLUE           ', '34             ', 'MAGENTA        ', '35             ', 'CYAN           ', '36             ', 'WHITE          ', '37             ', 'DEFAULT        ', '39             ', 'BLACK_INTENSE  ', '90             ', 'RED_INTENSE    ', '91             ', 'GREEN_INTENSE  ', '92             ', 'YELLOW_INTENSE ', '93             ', 'BLUE_INTENSE   ', '94             ', 'MAGENTA_INTENSE', '95             ', 'CYAN_INTENSE   ', '96             ', 'WHITE_INTENSE  ', '97             '], [2, 17]) Foreground colors. character(len=15), private, parameter :: COLORS_BG (1:2,1:17) = reshape(['BLACK          ', '40             ', 'RED            ', '41             ', 'GREEN          ', '42             ', 'YELLOW         ', '43             ', 'BLUE           ', '44             ', 'MAGENTA        ', '45             ', 'CYAN           ', '46             ', 'WHITE          ', '47             ', 'DEFAULT        ', '49             ', 'BLACK_INTENSE  ', '100            ', 'RED_INTENSE    ', '101            ', 'GREEN_INTENSE  ', '102            ', 'YELLOW_INTENSE ', '103            ', 'BLUE_INTENSE   ', '104            ', 'MAGENTA_INTENSE', '105            ', 'CYAN_INTENSE   ', '106            ', 'WHITE_INTENSE  ', '107            '], [2, 17]) Background colors. Interfaces public interface colorize private pure function colorize_default (string, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, DEFAULT kind. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:),allocatable Colorized string. Functions private pure function colorize_ascii (string, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, ASCII kind. Arguments Type Intent Optional Attributes Name character(kind=ASCII,len=*), intent(in) :: string Input string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(kind=ASCII,len=:),allocatable Colorized string. private pure function colorize_default (string, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, DEFAULT kind. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:),allocatable Colorized string. private pure function colorize_ucs4 (string, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, UCS4 kind. Arguments Type Intent Optional Attributes Name character(kind=UCS4,len=*), intent(in) :: string Input string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(kind=UCS4,len=:),allocatable Colorized string. private elemental function color_index (color) Return the array-index corresponding to the queried color. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: color Color definition. Return Value integer(kind=int32) Index into the colors arrays. private elemental function style_index (style) Return the array-index corresponding to the queried style. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: style Style definition. Return Value integer(kind=int32) Index into the styles array. private elemental function upper (string) Return a string with all uppercase characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input string. Return Value character(len=len) Upper case string. Subroutines public subroutine colors_samples () Print to standard output all colors samples. Arguments None public subroutine styles_samples () Print to standard output all styles samples. Arguments None","tags":"","loc":"module/face.html"},{"title":"tester – FLAP","text":"Routines to test Fortran programs Uses iso_fortran_env module~~tester~~UsesGraph module~tester tester iso_fortran_env iso_fortran_env module~tester->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~tester~~UsedByGraph module~tester tester program~test_tester_1 test_tester_1 program~test_tester_1->module~tester program~test_tester_4 test_tester_4 program~test_tester_4->module~tester program~test_tester_3 test_tester_3 program~test_tester_3->module~tester program~test_tester_05 test_tester_05 program~test_tester_05->module~tester program~test_tester_6 test_tester_6 program~test_tester_6->module~tester program~test_tester_1~2 test_tester_1 program~test_tester_1~2->module~tester program~test_tester_2 test_tester_2 program~test_tester_2->module~tester program~test_tester_7 test_tester_7 program~test_tester_7->module~tester program~test_tester_8 test_tester_8 program~test_tester_8->module~tester program~flap_test_group flap_test_group program~flap_test_group->module~tester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types tester_t Subroutines init print assert_equal_i8 assert_equal_i16 assert_equal_i32 assert_equal_i64 assert_equal_r32 assert_equal_r64 assert_equal_c32 assert_equal_c64 assert_equal_l assert_equal_i8_1 assert_equal_i16_1 assert_equal_i32_1 assert_equal_i64_1 assert_equal_r32_1 assert_equal_r64_1 assert_equal_c32_1 assert_equal_c64_1 assert_equal_l_1 assert_positive_i8 assert_positive_i16 assert_positive_i32 assert_positive_i64 assert_positive_r32 assert_positive_r64 assert_positive_i8_1 assert_positive_i16_1 assert_positive_i32_1 assert_positive_i64_1 assert_positive_r32_1 assert_positive_r64_1 assert_close_r32 assert_close_r64 assert_close_r32_1 assert_close_r64_1 assert_close_c32 assert_close_c64 assert_close_c32_1 assert_close_c64_1 Derived Types type, public :: tester_t The main tester class. Components Type Visibility Attributes Name Initial integer(kind=int32), private :: n_errors = 0_int32 Number of errors. integer(kind=int32), private :: n_tests = 0_int32 Number of tests. real(kind=real32), private :: tolerance32 = 2._real32*epsilon(1._real32) Real tolerance, 32 bits. real(kind=real64), private :: tolerance64 = 2._real64*epsilon(1._real64) Real tolerance, 64 bits. Type-Bound Procedures procedure, public :: init Initialize the tester. procedure, public :: print Print tests results. generic, public :: assert_equal => assert_equal_i8, assert_equal_i16, assert_equal_i32, assert_equal_i64, assert_equal_r32, assert_equal_r64, assert_equal_c32, assert_equal_c64, assert_equal_l, assert_equal_i8_1, assert_equal_i16_1, assert_equal_i32_1, assert_equal_i64_1, assert_equal_r32_1, assert_equal_r64_1, assert_equal_c32_1, assert_equal_c64_1, assert_equal_l_1 Check if two values (integer, real, complex or logical) are equal. procedure, private :: assert_equal_i8 Check if two integers (8  bits) are equal. procedure, private :: assert_equal_i16 Check if two integers (16 bits) are equal. procedure, private :: assert_equal_i32 Check if two integers (32 bits) are equal. procedure, private :: assert_equal_i64 Check if two integers (64 bits) are equal. procedure, private :: assert_equal_r32 Check if two reals (32 bits) are equal. procedure, private :: assert_equal_r64 Check if two reals (64 bits) are equal. procedure, private :: assert_equal_c32 Check if two complex numbers (32 bits) are equal. procedure, private :: assert_equal_c64 Check if two complex numbers (64 bits) are equal. procedure, private :: assert_equal_l Check if two logicals are equal. procedure, private :: assert_equal_i8_1 Check if two integer (8  bits) arrays (rank 1) are equal. procedure, private :: assert_equal_i16_1 Check if two integer (16 bits) arrays (rank 1) are equal. procedure, private :: assert_equal_i32_1 Check if two integer (32 bits) arrays (rank 1) are equal. procedure, private :: assert_equal_i64_1 Check if two integer (64 bits) arrays (rank 1) are equal. procedure, private :: assert_equal_r32_1 Check if two real (32 bits) arrays (rank 1) are equal. procedure, private :: assert_equal_r64_1 Check if two real (64 bits) arrays (rank 1) are equal. procedure, private :: assert_equal_c32_1 Check if two complex (32 bits) arrays (rank 1) are equal. procedure, private :: assert_equal_c64_1 Check if two complex (64 bits) arrays (rank 1) are equal. procedure, private :: assert_equal_l_1 Check if two logical arrays (rank 1) are equal. generic, public :: assert_positive => assert_positive_i8, assert_positive_i16, assert_positive_i32, assert_positive_i64, assert_positive_r32, assert_positive_r64, assert_positive_i8_1, assert_positive_i16_1, assert_positive_i32_1, assert_positive_i64_1, assert_positive_r32_1, assert_positive_r64_1 Check if a number (integer or real) is positive. procedure, private :: assert_positive_i8 Check if a integer (8  bits) is positive. procedure, private :: assert_positive_i16 Check if a integer (16 bits) is positive. procedure, private :: assert_positive_i32 Check if a integer (32 bits) is positive. procedure, private :: assert_positive_i64 Check if a integer (64 bits) is positive. procedure, private :: assert_positive_r32 Check if a real (32 bits) is positive. procedure, private :: assert_positive_r64 Check if a real (64 bits) is positive. procedure, private :: assert_positive_i8_1 Check if a integer (8  bits) array (rank 1) is positive. procedure, private :: assert_positive_i16_1 Check if a integer (16 bits) array (rank 1) is positive. procedure, private :: assert_positive_i32_1 Check if a integer (32 bits) array (rank 1) is positive. procedure, private :: assert_positive_i64_1 Check if a integer (64 bits) array (rank 1) is positive. procedure, private :: assert_positive_r32_1 Check if a real (32 bits) array (rank 1) is positive. procedure, private :: assert_positive_r64_1 Check if a real (64 bits) array (rank 1) is positive. generic, public :: assert_close => assert_close_r32, assert_close_r64, assert_close_c32, assert_close_c64, assert_close_r32_1, assert_close_r64_1, assert_close_c32_1, assert_close_c64_1 Check if two values (real or complex) are close with respect a tolerance. procedure, private :: assert_close_r32 Check if two reals (32 bits) are close with respect a tolerance. procedure, private :: assert_close_r64 Check if two reals (64 bits) are close with respect a tolerance. procedure, private :: assert_close_c32 Check if two complex numbers (32 bits) are close with respect a tolerance. procedure, private :: assert_close_c64 Check if two complex numbers (64 bits) are close with respect a tolerance. procedure, private :: assert_close_r32_1 Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. procedure, private :: assert_close_r64_1 Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. procedure, private :: assert_close_c32_1 Check if two complex (32 bits) arrays (rank 1) are close with respect a tolerance. procedure, private :: assert_close_c64_1 Check if two complex (64 bits) arrays (rank 1) are close with respect a tolerance. Subroutines private subroutine init (this, tolerance32, tolerance64) Initialize the tester. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(out) :: this The tester. real(kind=real32), intent(in), optional :: tolerance32 Real tolerance, 32 bits. real(kind=real64), intent(in), optional :: tolerance64 Real tolerance, 64 bits. private subroutine print (this, errorstop) Print tests results. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(in) :: this The tester. logical, intent(in), optional :: errorstop Flag to activate error stop if one test fails. private subroutine assert_equal_i8 (this, i1, i2) Check if two integers (8 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i1 Value to compare. integer(kind=int8), intent(in) :: i2 Value to compare. private subroutine assert_equal_i16 (this, i1, i2) Check if two integers (16 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i1 Value to compare. integer(kind=int16), intent(in) :: i2 Value to compare. private subroutine assert_equal_i32 (this, i1, i2) Check if two integers (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i1 Value to compare. integer(kind=int32), intent(in) :: i2 Value to compare. private subroutine assert_equal_i64 (this, i1, i2) Check if two integers (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i1 Value to compare. integer(kind=int64), intent(in) :: i2 Value to compare. private subroutine assert_equal_r32 (this, r1, r2) Check if two reals (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Value to compare. real(kind=real32), intent(in) :: r2 Value to compare. private subroutine assert_equal_r64 (this, r1, r2) Check if two reals (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Value to compare. real(kind=real64), intent(in) :: r2 Value to compare. private subroutine assert_equal_c32 (this, c1, c2) Check if two complex numbers (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in) :: c1 Value to compare. complex(kind=real32), intent(in) :: c2 Value to compare. private subroutine assert_equal_c64 (this, c1, c2) Check if two complex numbers (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in) :: c1 Value to compare. complex(kind=real64), intent(in) :: c2 Value to compare. private subroutine assert_equal_l (this, l1, l2) Check if two logicals are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in) :: l1 Value to compare. logical, intent(in) :: l2 Value to compare. private subroutine assert_equal_i8_1 (this, i1, i2) Check if two integer (8 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int8), intent(in), dimension(:) :: i2 Value to compare. private subroutine assert_equal_i16_1 (this, i1, i2) Check if two integer (16 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int16), intent(in), dimension(:) :: i2 Value to compare. private subroutine assert_equal_i32_1 (this, i1, i2) Check if two integer (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int32), intent(in), dimension(:) :: i2 Value to compare. private subroutine assert_equal_i64_1 (this, i1, i2) Check if two integer (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i1 Value to compare. integer(kind=int64), intent(in), dimension(:) :: i2 Value to compare. private subroutine assert_equal_r32_1 (this, r1, r2) Check if two real (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Value to compare. real(kind=real32), intent(in), dimension(:) :: r2 Value to compare. private subroutine assert_equal_r64_1 (this, r1, r2) Check if two real (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Value to compare. real(kind=real64), intent(in), dimension(:) :: r2 Value to compare. private subroutine assert_equal_c32_1 (this, c1, c2) Check if two complex (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real32), intent(in), dimension(:) :: c2 Value to compare. private subroutine assert_equal_c64_1 (this, c1, c2) Check if two complex (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real64), intent(in), dimension(:) :: c2 Value to compare. private subroutine assert_equal_l_1 (this, l1, l2) Check if two logical arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in), dimension(:) :: l1 Value to compare. logical, intent(in), dimension(:) :: l2 Value to compare. private subroutine assert_positive_i8 (this, i) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i Value to check. private subroutine assert_positive_i16 (this, i) Check if a integer (16 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i Value to check. private subroutine assert_positive_i32 (this, i) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i Value to check. private subroutine assert_positive_i64 (this, i) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i Value to check. private subroutine assert_positive_r32 (this, r) Check if a real (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r Value to check. private subroutine assert_positive_r64 (this, r) Check if a real (64 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r Value to check. private subroutine assert_positive_i8_1 (this, i) Check if a integer (8 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i Value to check. private subroutine assert_positive_i16_1 (this, i) Check if a integer (16 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i Value to check. private subroutine assert_positive_i32_1 (this, i) Check if a integer (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i Value to check. private subroutine assert_positive_i64_1 (this, i) Check if a integer (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i Value to check. private subroutine assert_positive_r32_1 (this, r) Check if a real (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r Value to check. private subroutine assert_positive_r64_1 (this, r) Check if a real (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r Value to check. private subroutine assert_close_r32 (this, r1, r2) Check if two reals (32 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Value to compare. real(kind=real32), intent(in) :: r2 Value to compare. private subroutine assert_close_r64 (this, r1, r2) Check if two reals (64 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Value to compare. real(kind=real64), intent(in) :: r2 Value to compare. private subroutine assert_close_r32_1 (this, r1, r2) Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Value to compare. real(kind=real32), intent(in), dimension(:) :: r2 Value to compare. private subroutine assert_close_r64_1 (this, r1, r2) Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Value to compare. real(kind=real64), intent(in), dimension(:) :: r2 Value to compare. private subroutine assert_close_c32 (this, c1, c2) Check if two complex numbers (32 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in) :: c1 Value to compare. complex(kind=real32), intent(in) :: c2 Value to compare. private subroutine assert_close_c64 (this, r1, c2) Check if two complex numbers (64 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in) :: r1 Value to compare. complex(kind=real64), intent(in) :: c2 Value to compare. private subroutine assert_close_c32_1 (this, c1, c2) Check if two complex (32 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real32), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real32), intent(in), dimension(:) :: c2 Value to compare. private subroutine assert_close_c64_1 (this, c1, c2) Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. complex(kind=real64), intent(in), dimension(:) :: c1 Value to compare. complex(kind=real64), intent(in), dimension(:) :: c2 Value to compare.","tags":"","loc":"module/tester.html"},{"title":"flap_object_t – FLAP","text":"Base (abstract) class upon which FLAP’s concrete classes are built. Uses penf iso_fortran_env module~~flap_object_t~~UsesGraph module~flap_object_t flap_object_t penf penf module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~flap_object_t~~UsedByGraph module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap_object_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap_command_line_interface_t->module~flap_object_t module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_argument_t->module~flap_object_t module~flap flap module~flap->module~flap_command_line_arguments_group_t module~flap->module~flap_command_line_interface_t module~flap->module~flap_command_line_argument_t program~flap_save_usage_to_markdown flap_save_usage_to_markdown program~flap_save_usage_to_markdown->module~flap program~flap_test_choices_logical flap_test_choices_logical program~flap_test_choices_logical->module~flap program~flap_save_man_page flap_save_man_page program~flap_save_man_page->module~flap program~flap_test_nested flap_test_nested program~flap_test_nested->module~flap program~flap_test_hidden flap_test_hidden program~flap_test_hidden->module~flap program~flap_test_duplicated_clas flap_test_duplicated_clas program~flap_test_duplicated_clas->module~flap program~flap_test_ansi_color_style flap_test_ansi_color_style program~flap_test_ansi_color_style->module~flap program~flap_test_ignore_unknown_clas flap_test_ignore_unknown_clas program~flap_test_ignore_unknown_clas->module~flap program~flap_test_nargs_insufficient flap_test_nargs_insufficient program~flap_test_nargs_insufficient->module~flap program~flap_test_group flap_test_group program~flap_test_group->module~flap program~flap_test_minimal flap_test_minimal program~flap_test_minimal->module~flap program~flap_test_group_examples flap_test_group_examples program~flap_test_group_examples->module~flap program~flap_test_nargs_insufficient~2 flap_test_nargs_insufficient program~flap_test_nargs_insufficient~2->module~flap program~flap_save_bash_completion flap_save_bash_completion program~flap_save_bash_completion->module~flap program~flap_test_string flap_test_string program~flap_test_string->module~flap program~flap_test_basic flap_test_basic program~flap_test_basic->module~flap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types object Subroutines free_object print_version print_error_message set_examples assign_object Derived Types type, public, abstract :: object Base (abstract) class upon which FLAP’s concrete classes are built. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_style ANSI style of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_color ANSI color of error messages. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=512), public, allocatable :: examples (:) Examples of correct usage. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages Type-Bound Procedures procedure, public, pass(self) :: free_object Free dynamic memory. procedure, public, pass(self) :: print_version Print version. procedure, public, pass(self) :: print_error_message Print meaningful error message. procedure, public, pass(self) :: set_examples Set examples of correct usage. procedure, public, pass(lhs ) :: assign_object Assignment overloading. Subroutines private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character, intent(in), optional :: pref Prefixing string. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. private subroutine set_examples (self, examples) Set examples of correct usage. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. character, intent(in), optional :: examples (1:) Examples of correct usage. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side.","tags":"","loc":"module/flap_object_t.html"},{"title":"flap_command_line_arguments_group_t – FLAP","text":"Command Line Arguments Group (CLAsG) class. Uses flap_object_t penf face flap_command_line_argument_t module~~flap_command_line_arguments_group_t~~UsesGraph module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_argument_t flap_command_line_argument_t module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t penf penf module~flap_command_line_arguments_group_t->penf module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~face->iso_fortran_env module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~face module~flap_command_line_argument_t->penf module~flap_utils_m flap_utils_m module~flap_command_line_argument_t->module~flap_utils_m module~flap_utils_m->penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~flap_command_line_arguments_group_t~~UsedByGraph module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap flap module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t program~flap_save_usage_to_markdown flap_save_usage_to_markdown program~flap_save_usage_to_markdown->module~flap program~flap_test_choices_logical flap_test_choices_logical program~flap_test_choices_logical->module~flap program~flap_save_man_page flap_save_man_page program~flap_save_man_page->module~flap program~flap_test_nested flap_test_nested program~flap_test_nested->module~flap program~flap_test_hidden flap_test_hidden program~flap_test_hidden->module~flap program~flap_test_duplicated_clas flap_test_duplicated_clas program~flap_test_duplicated_clas->module~flap program~flap_test_ansi_color_style flap_test_ansi_color_style program~flap_test_ansi_color_style->module~flap program~flap_test_ignore_unknown_clas flap_test_ignore_unknown_clas program~flap_test_ignore_unknown_clas->module~flap program~flap_test_nargs_insufficient flap_test_nargs_insufficient program~flap_test_nargs_insufficient->module~flap program~flap_test_group flap_test_group program~flap_test_group->module~flap program~flap_test_minimal flap_test_minimal program~flap_test_minimal->module~flap program~flap_test_group_examples flap_test_group_examples program~flap_test_group_examples->module~flap program~flap_test_nargs_insufficient~2 flap_test_nargs_insufficient program~flap_test_nargs_insufficient~2->module~flap program~flap_save_bash_completion flap_save_bash_completion program~flap_save_bash_completion->module~flap program~flap_test_string flap_test_string program~flap_test_string->module~flap program~flap_test_basic flap_test_basic program~flap_test_basic->module~flap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables STATUS_PRINT_V STATUS_PRINT_H ERROR_CONSISTENCY ERROR_M_EXCLUDE Derived Types command_line_arguments_group Functions is_passed is_defined usage signature Subroutines free check is_required_passed raise_error_m_exclude add parse errored check_m_exclusive sanitize_defaults clasg_assign_clasg finalize Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: STATUS_PRINT_V = -1 Print version status. integer(kind=I4P), public, parameter :: STATUS_PRINT_H = -2 Print help status. integer(kind=I4P), private, parameter :: ERROR_CONSISTENCY = 100 CLAs group consistency error. integer(kind=I4P), private, parameter :: ERROR_M_EXCLUDE = 101 Two mutually exclusive CLAs group have been called. Derived Types type, public, extends( object ) :: command_line_arguments_group Command Line Arguments Group (CLAsG) class. Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_style ANSI style of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_color ANSI color of error messages. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=512), public, allocatable :: examples (:) Examples of correct usage. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: group Group name (command). integer(kind=I4P), public :: Na = 0_I4P Number of CLA. integer(kind=I4P), private :: Na_required = 0_I4P Number of required command line arguments. integer(kind=I4P), private :: Na_optional = 0_I4P Number of optional command line arguments. type( command_line_argument ), public, allocatable :: cla (:) CLA list [1:Na]. logical, public :: is_called = .false. Flag for checking if CLAs group has been passed to CLI. Finalizations Procedures final :: finalize Free dynamic memory when finalizing. Type-Bound Procedures procedure, public, pass(self) :: free_object Free dynamic memory. procedure, public, pass(self) :: print_version Print version. procedure, public, pass(self) :: print_error_message Print meaningful error message. procedure, public, pass(self) :: set_examples Set examples of correct usage. procedure, public, pass(lhs ) :: assign_object Assignment overloading. procedure, public :: free Free dynamic memory. procedure, public :: check Check data consistency. procedure, public :: is_required_passed Check if required CLAs are passed. procedure, public :: is_passed Check if a CLA has been passed. procedure, public :: is_defined Check if a CLA has been defined. procedure, public :: raise_error_m_exclude Raise error mutually exclusive CLAs passed. procedure, public :: add Add CLA to CLAsG. procedure, public :: parse Parse CLAsG arguments. procedure, public :: usage Get correct CLAsG usage. procedure, public :: signature Get CLAsG signature. procedure, public :: sanitize_defaults Sanitize default values. procedure, private :: errored Trig error occurrence and print meaningful message. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs have been passed. procedure, private :: clasg_assign_clasg Assignment operator. generic, private :: assignment(=) => clasg_assign_clasg Assignment operator overloading. Functions private pure function is_passed (self, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. private function is_defined (self, switch, pos) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character, intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. private function usage (self, pref, no_header, markdown) Get correct CLAsG usage. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: markdown Format things form markdown. Return Value character(len=:),allocatable Usage string. private function signature (self, bash_completion, plain) Get CLAsG signature. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. logical, intent(in), optional :: bash_completion Return the signature for bash completion. logical, intent(in), optional :: plain Return the signature as plain switches list. Return Value character(len=:),allocatable Signature. Subroutines private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. private subroutine check (self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. private subroutine is_required_passed (self, pref) Check if required CLAs are passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. private subroutine raise_error_m_exclude (self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. private subroutine add (self, pref, cla) Add CLA to CLAs list. Read more… Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. type( command_line_argument ), intent(in) :: cla CLA data. private subroutine parse (self, args, ignore_unknown_clas, pref, error_unknown_clas) Parse CLAsG arguments. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in) :: args (:) Command line arguments. logical, intent(in) :: ignore_unknown_clas Disable errors-raising for passed unknown CLAs. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out) :: error_unknown_clas Error flag for passed unknown CLAs. private subroutine errored (self, error, pref, a1, a2) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. integer(kind=I4P), intent(in) :: error Error occurred. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(in), optional :: a1 First index CLAs group inconsistent. integer(kind=I4P), intent(in), optional :: a2 Second index CLAs group inconsistent. private subroutine check_m_exclusive (self, pref) Check if two mutually exclusive CLAs have been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character, intent(in), optional :: pref Prefixing string. private subroutine sanitize_defaults (self) Sanitize defaults values. Read more… Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. private elemental subroutine clasg_assign_clasg (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: lhs Left hand side. type( command_line_arguments_group ), intent(in) :: rhs Right hand side. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_arguments_group ), intent(inout) :: self CLAsG data.","tags":"","loc":"module/flap_command_line_arguments_group_t.html"},{"title":"flap – FLAP","text":"FLAP, Fortran command Line Arguments Parser for poor people FLAP FLAP, Fortran command Line Arguments Parser for poor people A KISS pure Fortran Library for building powerful, easy-to-use, elegant command line interfaces FLAP is a pure Fortran (KISS) library for building easily nice Command Line Interfaces (CLI) for modern Fortran projects; FLAP is Fortran 2003+ standard compliant; FLAP is OOP designed; FLAP is a Free, Open Source Project. Issues Compiler Support | What is FLAP? | Main features | Copyrights | Documentation | Install | What is FLAP? Modern Fortran standards (2003+) have introduced support for Command Line Arguments (CLA), thus it is possible to construct nice and effective Command Line Interfaces (CLI). FLAP is a small library designed to simplify the (repetitive) construction of complicated CLI in pure Fortran (standard 2003+). FLAP has been inspired by the python module argparse trying to mimic it. Once you have defined the arguments that are required by means of a user-friendly method of the CLI, FLAP will parse the CLAs for you. It is worthy of note that FLAP, as argparse , also automatically generates help and usage messages and issues errors when users give the program invalid arguments. Go to Top Main features FLAP is inspired by the python great module argparse , thus many features are taken from it. Here the main features are listed. [x] User-friendly methods for building flexible and effective Command Line Interfaces (CLI); [x] comprehensive Command Line Arguments (CLA) support: [x] support optional and non optional CLA; [x] support boolean CLA; [x] support positional CLA; [x] support list of allowable values for defined CLA with automatic consistency check; [x] support multiple valued (list of values, aka list-valued) CLA: [x] compiletime sized list, e.g. nargs='3' ; [x] runtime sized list with at least 1 value, e.g. nargs='+' ; [x] runtime sized list with any size, even empty, e.g. nargs='*' ; [x] support mutually exclusive CLAs; [x] self-consistency-check of CLA definition; [x] support fake CLAs input from a string; [x] support fake CLAs input from environment variables; [x] comprehensive command (group of CLAs) support: [x] support nested subcommands; [x] support mutually exclusive commands; [x] self-consistency-check of command definition; [x] automatic generation of help and usage messages; [x] consistency-check of whole CLI definition; [x] errors trapping for invalid CLI usage; [x] POSIX style compliant; [x] automatic generation of MAN PAGE using your CLI definition!; [x] replicate all the useful features of argparse ; [ ] implement docopt features. [ ] implement click features. Any feature request is welcome. Go to Top Copyrights FLAP is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FLAP is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FLAP documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of FLAP A minimal plate : program minimal type ( command_line_interface ) :: cli ! Command Line Interface (CLI). character ( 99 ) :: string ! String value. integer :: error ! Error trapping flag. call cli % init ( description = 'minimal FLAP example' ) call cli % add ( switch = '--string' , & switch_ab = '-s' , & help = 'a string' , & required = . true ., & act = 'store' , & error = error ) if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = string , error = error ) if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String = ' // trim ( adjustl ( string )) endprogram minimal That built and run provides: → ./minimal\n./minimal: error: named option \"--string\" is required!\n\nusage:  ./exe/test_minimal --string value [ --help ] [ --version ] minimal FLAP example\n\nRequired switches:\n   --string value, -s value\n    a string\n\nOptional switches:\n   --help, -h\n    Print this help message\n   --version, -v\n    Print version A nice automatic help-message, right? Executed correctly gives. → ./minimal --string 'hello world' ./exe/minimal has been called with the following argument: String = hello world For more details, see the provided tests . Nested (sub)commands FLAP fully supports nested (sub)commands or groups of command line arguments. For example a fake git toy remake can be coded as ! initializing Command Line Interface call cli % init ( progname = 'test_nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' ,& examples = [ 'test_nested                      ' ,& 'test_nested -h                   ' ,& 'test_nested init                 ' ,& 'test_nested commit -m \"fix bug-1\"' ,& 'test_nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! using Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif that when invoked without arguments prompts: cowardly you are doing nothing... try at least \"-h\" option! and invoked with -h option gives: usage: test_nested [ --authors ] [ --help ] [ --version ] { init,commit,tag } ...\n\nToy program for testing FLAP with nested commands\n\nOptional switches:\n   --authors, -a\n          default value .false.\n          Print authors names\n   --help, -h\n          Print this help message\n   --version, -v\n          Print version\n\nCommands:\n  init\n          fake init versioning\n  commit\n          fake commit changes to current branch\n  tag\n          fake tag current commit\n\nFor more detailed commands help try:\n  test_nested init -h,--help\n  test_nested commit -h,--help\n  test_nested tag -h,--help\n\nExamples:\n   test_nested\n   test_nested -h\n   test_nested init\n   test_nested commit -m \"fix bug-1\" test_nested tag -a \"v2.1.5\" For more details, see the provided example . Go to Top Install FLAP is a Fortran library composed by several modules. Before download and compile the library you must check the requirements . To download and build the project two main ways are available: exploit the install script that can be downloaded here manually download and build : download build install script FLAP ships a bash script (downloadable from here ) that is able to automatize the download and build steps. The script install.sh has the following usage: → ./install.sh\nInstall script of FLAP\nUsage:\n\ninstall.sh --help | -?\n    Print this usage output and exit install.sh --download | -d <arg> [ --verbose | -v ] Download the project\n\n    --download | -d [ arg ] Download the project, arg = git | wget to download with git or wget respectively\n    --verbose | -v         Output verbose mode activation\n\ninstall.sh --build | -b <arg> [ --verbose | -v ] Build the project\n\n    --build | -b [ arg ] Build the project, arg = fobis | make | cmake to build with FoBiS.py, GNU Make or CMake respectively\n    --verbose | -v      Output verbose mode activation\n\nExamples:\n\ninstall.sh --download git\ninstall.sh --build make\ninstall.sh --download wget --build cmake The script does not cover all possibilities. The script operation modes are 2 ( collapsible into one-single-mode): download a new fresh-clone of the latest master-release by means of: git ; wget (also curl is necessary); build a fresh-clone project as static-linked library by means of: FoBiS.py ; GNU Make ; CMake ; Fortran Package Manager ; you can mix any of the above combinations accordingly to the tools available. Typical usages are: # download and prepare the project by means of git and build with GNU Make install.sh --dowload git --build make # download and prepare the project by means of wget (curl) and build with CMake install.sh --dowload wget --build cmake # download and prepare the project by means of git and build with FoBiS.py install.sh --dowload git --build fobis manually download and build download To download all the available releases and utilities (fobos, license, readme, etc…), it can be convenient to clone whole the project: git clone https://github.com/szaghi/FLAP cd FLAP\ngit submodule update --init Alternatively, you can directly download a release from GitHub server, see the ChangeLog . build The most easy way to compile FLAP is to use FoBiS.py within the provided fobos file. Consequently, it is strongly encouraged to install FoBiS.py . | Build by means of FoBiS | Build by means of GNU Make | Build by means of CMake | build by means of FoBiS FoBiS.py is a KISS tool for automatic building of modern Fortran projects. Providing very few options, FoBiS.py is able to build almost automatically complex Fortran projects with cumbersome inter-modules dependency. This removes the necessity to write complex makefile. Moreover, providing a very simple options file (in the FoBiS.py nomenclature indicated as fobos file) FoBiS.py can substitute the (ab)use of makefile for other project stuffs (build documentations, make project archive, etc…). FLAP is shipped with a fobos file that can build the library in both static and shared forms and also build the Test_Driver program. The provided fobos file has several building modes. listing fobos building modes Typing: FoBiS.py build -lmodes the following message should be printed: The fobos file defines the following modes:\n - \"shared-gnu\" - \"static-gnu\" - \"test-driver-gnu\" - \"shared-gnu-debug\" - \"static-gnu-debug\" - \"test-driver-gnu-debug\" - \"shared-intel\" - \"static-intel\" - \"test-driver-intel\" - \"shared-intel-debug\" - \"static-intel-debug\" - \"test-driver-intel-debug\" The modes should be self-explicative: shared , static and test-driver are the modes for building (in release, optimized form) the shared and static versions of the library and the Test Driver program, respectively. The other 3 modes are the same, but in debug form instead of release one. -gnu use the GNU gfortran compiler while -intel the Intel one. building the library The shared or static directories are created accordingly to the form of the library built. The compiled objects and mod files are placed inside this directory, as well as the linked library. release shared library FoBiS.py build -mode shared-gnu release static library FoBiS.py build -mode static-gnu debug shared library FoBiS.py build -mode shared-gnu-debug debug static library FoBiS.py build -mode static-gnu-debug building the Test Driver program The Test_Driver directory is created. The compiled objects and mod files are placed inside this directory, as well as the linked program. release test driver program FoBiS.py build -mode test-driver-gnu debug test driver program FoBiS.py build -mode test-driver-gnu-debug listing fobos rules Typing: FoBiS.py rule -ls the following message should be printed: The fobos file defines the following rules:\n  - \"makedoc\" Rule for building documentation from source files Command = > rm -rf doc/html/* Command = > ford doc/main_page.md Command = > cp -r doc/html/publish/* doc/html/\n  - \"deldoc\" Rule for deleting documentation Command = > rm -rf doc/html/*\n  - \"maketar\" Rule for making tar archive of the project Command = > tar -czf FLAP.tar.gz *\n  - \"makecoverage\" Rule for performing coverage analysis Command = > FoBiS.py clean -mode test-driver-gnu Command = > FoBiS.py build -mode test-driver-gnu -coverage Command = > ./Test_Driver/Test_Driver Command = > ./Test_Driver/Test_Driver -v Command = > ./Test_Driver/Test_Driver -s 'Hello FLAP' -i 2 Command = > ./Test_Driver/Test_Driver 33 .0 -s 'Hello FLAP' --integer_list 10 -3 87 -i 3 -r 64 .123d0  --boolean --boolean_val .false.\n  - \"coverage-analysis\" Rule for performing coverage analysis and saving reports in markdown Command = > FoBiS.py clean -mode test-driver-gnu Command = > FoBiS.py build -mode test-driver-gnu -coverage Command = > ./Test_Driver/Test_Driver Command = > ./Test_Driver/Test_Driver -v Command = > ./Test_Driver/Test_Driver -s 'Hello FLAP' -i 2 Command = > ./Test_Driver/Test_Driver 33 .0 -s 'Hello FLAP' --integer_list 10 -3 87 -i 3 -r 64 .123d0  --boolean --boolean_val .false. Command = > gcov -o Test_Driver/obj/ src/* Command = > FoBiS.py rule -gcov_analyzer wiki/ Coverage-Analysis Command = > rm -f *.gcov The rules should be self-explicative. build by means of GNU Make Bad choice :-) However, a makefile (generated by FoBiS.py…) to be used with a compatible GNU Make tool is provided . It is convenient to clone the whole FLAP repository and run a standard make: git clone https://github.com/szaghi/FLAP cd FLAP\nmake -j 1 This commands build all tests (executables are in exe/ directory). To build only the library (statically linked) type: git clone https://github.com/szaghi/FLAP cd FLAP\nmake -j 1 STATIC = yes Build by means of CMake Bad choice :-) However, a CMake setup (kindly developed by victorsndvg ) is provided. It is convenient to clone the whole FLAP repository and run a standard CMake configure/build commands: git clone https://github.com/szaghi/FLAP $YOUR_FLAP_PATH mkdir build cd build\ncmake $YOUR_FLAP_PATH cmake --build . If you want to run the tests suite type: git clone https://github.com/szaghi/FLAP $YOUR_FLAP_PATH mkdir build cd build\ncmake -DFLAP_ENABLE_TESTS = ON $YOUR_FLAP_PATH cmake --build .\nctest Build by means of FPM A Fortran Package Manager manifest file is also included, so that the library and test cases can be compiled with FPM. For example: fpm build --profile release\nfpm test --profile release To use FLAP within your fpm project, add the following to your fpm.toml file: [dependencies] FLAP = { git = \"https://github.com/szaghi/FLAP.git\" } Or, to use a specific revision: [dependencies] FLAP = { git = \"https://github.com/szaghi/FLAP.git\" , rev = \"11cb276228d678c1d9ce755badf0ce82094b0852\" } Note that, when compiling with FPM, the git submodules in the src/third_party directory are not used, but FPM will download these separately, based on the versions specified in the fpm.toml file. Go to Top Uses flap_command_line_arguments_group_t flap_command_line_interface_t flap_command_line_argument_t module~~flap~~UsesGraph module~flap flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face penf penf module~flap_command_line_arguments_group_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_command_line_argument_t->penf module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~flap~~UsedByGraph module~flap flap program~flap_save_usage_to_markdown flap_save_usage_to_markdown program~flap_save_usage_to_markdown->module~flap program~flap_test_choices_logical flap_test_choices_logical program~flap_test_choices_logical->module~flap program~flap_save_man_page flap_save_man_page program~flap_save_man_page->module~flap program~flap_test_nested flap_test_nested program~flap_test_nested->module~flap program~flap_test_hidden flap_test_hidden program~flap_test_hidden->module~flap program~flap_test_duplicated_clas flap_test_duplicated_clas program~flap_test_duplicated_clas->module~flap program~flap_test_ansi_color_style flap_test_ansi_color_style program~flap_test_ansi_color_style->module~flap program~flap_test_ignore_unknown_clas flap_test_ignore_unknown_clas program~flap_test_ignore_unknown_clas->module~flap program~flap_test_nargs_insufficient flap_test_nargs_insufficient program~flap_test_nargs_insufficient->module~flap program~flap_test_group flap_test_group program~flap_test_group->module~flap program~flap_test_minimal flap_test_minimal program~flap_test_minimal->module~flap program~flap_test_group_examples flap_test_group_examples program~flap_test_group_examples->module~flap program~flap_test_nargs_insufficient~2 flap_test_nargs_insufficient program~flap_test_nargs_insufficient~2->module~flap program~flap_save_bash_completion flap_save_bash_completion program~flap_save_bash_completion->module~flap program~flap_test_string flap_test_string program~flap_test_string->module~flap program~flap_test_basic flap_test_basic program~flap_test_basic->module~flap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/flap.html"},{"title":"flap_command_line_interface_t – FLAP","text":"Command Line Interface (CLI) class. Uses flap_object_t flap_command_line_arguments_group_t flap_command_line_argument_t face penf flap_utils_m module~~flap_command_line_interface_t~~UsesGraph module~flap_command_line_interface_t flap_command_line_interface_t module~face face module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t penf penf module~flap_command_line_interface_t->penf module~flap_object_t flap_object_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m iso_fortran_env iso_fortran_env module~face->iso_fortran_env module~flap_command_line_argument_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_arguments_group_t->module~face module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_object_t module~flap_object_t->penf module~flap_object_t->iso_fortran_env module~flap_utils_m->penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~flap_command_line_interface_t~~UsedByGraph module~flap_command_line_interface_t flap_command_line_interface_t module~flap flap module~flap->module~flap_command_line_interface_t program~flap_save_usage_to_markdown flap_save_usage_to_markdown program~flap_save_usage_to_markdown->module~flap program~flap_test_choices_logical flap_test_choices_logical program~flap_test_choices_logical->module~flap program~flap_save_man_page flap_save_man_page program~flap_save_man_page->module~flap program~flap_test_nested flap_test_nested program~flap_test_nested->module~flap program~flap_test_hidden flap_test_hidden program~flap_test_hidden->module~flap program~flap_test_duplicated_clas flap_test_duplicated_clas program~flap_test_duplicated_clas->module~flap program~flap_test_ansi_color_style flap_test_ansi_color_style program~flap_test_ansi_color_style->module~flap program~flap_test_ignore_unknown_clas flap_test_ignore_unknown_clas program~flap_test_ignore_unknown_clas->module~flap program~flap_test_nargs_insufficient flap_test_nargs_insufficient program~flap_test_nargs_insufficient->module~flap program~flap_test_group flap_test_group program~flap_test_group->module~flap program~flap_test_minimal flap_test_minimal program~flap_test_minimal->module~flap program~flap_test_group_examples flap_test_group_examples program~flap_test_group_examples->module~flap program~flap_test_nargs_insufficient~2 flap_test_nargs_insufficient program~flap_test_nargs_insufficient~2->module~flap program~flap_save_bash_completion flap_save_bash_completion program~flap_save_bash_completion->module~flap program~flap_test_string flap_test_string program~flap_test_string->module~flap program~flap_test_basic flap_test_basic program~flap_test_basic->module~flap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables MAX_VAL_LEN ERROR_MISSING_CLA ERROR_MISSING_GROUP ERROR_MISSING_SELECTION_CLA ERROR_TOO_FEW_CLAS ERROR_UNKNOWN_CLAS_IGNORED Derived Types command_line_interface Functions is_passed is_defined_group is_called_group is_defined is_parsed usage signature Subroutines free init add_group set_mutually_exclusive_groups add check check_m_exclusive parse get_clasg_indexes get_args_from_string get_args_from_invocation get_cla get_cla_list get_cla_list_varying_R16P get_cla_list_varying_R8P get_cla_list_varying_R4P get_cla_list_varying_I8P get_cla_list_varying_I4P get_cla_list_varying_I2P get_cla_list_varying_I1P get_cla_list_varying_logical get_cla_list_varying_char print_usage save_bash_completion save_man_page save_usage_to_markdown errored cli_assign_cli finalize Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: MAX_VAL_LEN = 1000 Maximum number of characters of CLA value. integer(kind=I4P), public, parameter :: ERROR_MISSING_CLA = 1000 CLA not found in CLI. integer(kind=I4P), public, parameter :: ERROR_MISSING_GROUP = 1001 Group not found in CLI. integer(kind=I4P), public, parameter :: ERROR_MISSING_SELECTION_CLA = 1002 CLA selection in CLI failing. integer(kind=I4P), public, parameter :: ERROR_TOO_FEW_CLAS = 1003 Insufficient arguments for CLI. integer(kind=I4P), public, parameter :: ERROR_UNKNOWN_CLAS_IGNORED = 1004 Unknown CLAs passed, but ignored. Derived Types type, public, extends( object ) :: command_line_interface Command Line Interface (CLI) class. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_style ANSI style of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_color ANSI color of error messages. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=512), public, allocatable :: examples (:) Examples of correct usage. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages type( command_line_arguments_group ), public, allocatable :: clasg (:) CLA list [1:Na]. character(len=512), public, allocatable :: args (:) Actually passed command line arguments. logical, public :: disable_hv = .false. Disable automatic ‘help’ and ‘version’ CLAs. logical, public :: is_parsed_ = .false. Parse status. logical, public :: ignore_unknown_clas = .false. Disable errors-raising for passed unknown CLAs. integer(kind=I4P), public :: error_unknown_clas = 0_I4P Error trapping flag for unknown CLAs. Finalizations Procedures final :: finalize Free dynamic memory when finalizing. Type-Bound Procedures procedure, public, pass(self) :: free_object Free dynamic memory. procedure, public, pass(self) :: print_version Print version. procedure, public, pass(self) :: print_error_message Print meaningful error message. procedure, public, pass(self) :: set_examples Set examples of correct usage. procedure, public, pass(lhs ) :: assign_object Assignment overloading. procedure, public :: free Free dynamic memory. procedure, public :: init Initialize CLI. procedure, public :: add_group Add CLAs group CLI. procedure, public :: add Add CLA to CLI. procedure, public :: is_passed Check if a CLA has been passed. procedure, public :: is_defined_group Check if a CLAs group has been defined. procedure, public :: is_defined Check if a CLA has been defined. procedure, public :: is_parsed Check if CLI has been parsed. procedure, public :: set_mutually_exclusive_groups Set two CLAs group as mutually exclusive. procedure, public :: run_command => is_called_group Check if a CLAs group has been run. procedure, public :: parse Parse Command Line Interfaces. generic, public :: get => get_cla, get_cla_list Get CLA value(s) from CLAs list parsed. generic, public :: get_varying => get_cla_list_varying_R8P, get_cla_list_varying_R4P, get_cla_list_varying_I8P, get_cla_list_varying_I4P, get_cla_list_varying_I2P, get_cla_list_varying_I1P, get_cla_list_varying_logical, get_cla_list_varying_char Get CLA value(s) from CLAs list parsed, varying size list. procedure, public :: usage Get CLI usage. procedure, public :: signature Get CLI signature. procedure, public :: print_usage Print correct usage of CLI. procedure, public :: save_bash_completion Save bash completion script (for named CLAs only). procedure, public :: save_man_page Save CLI usage as man page. procedure, public :: save_usage_to_markdown Save CLI usage as markdown. procedure, private :: errored Trig error occurence and print meaningful message. procedure, private :: check Check data consistency. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs group have been called. procedure, private :: get_clasg_indexes Get CLAs groups indexes. generic, private :: get_args => get_args_from_string, get_args_from_invocation Get CLAs. procedure, private :: get_args_from_string Get CLAs from string. procedure, private :: get_args_from_invocation Get CLAs from CLI invocation. procedure, private :: get_cla Get CLA (single) value from CLAs list parsed. procedure, private :: get_cla_list Get CLA multiple values from CLAs list parsed. procedure, private :: get_cla_list_varying_R16P Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure, private :: get_cla_list_varying_R4P Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure, private :: get_cla_list_varying_I8P Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure, private :: get_cla_list_varying_I4P Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure, private :: get_cla_list_varying_I2P Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure, private :: get_cla_list_varying_I1P Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure, private :: get_cla_list_varying_logical Get CLA multiple values from CLAs list parsed, varying size, bool. procedure, private :: get_cla_list_varying_char Get CLA multiple values from CLAs list parsed, varying size, char. procedure, private :: cli_assign_cli CLI assignment overloading. generic, private :: assignment(=) => cli_assign_cli CLI assignment overloading. Functions private function is_passed (self, group, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. private function is_defined_group (self, group, g) result(defined) Check if a CLAs group has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. private function is_called_group (self, group) result(called) Check if a CLAs group has been run. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. private function is_defined (self, switch, group) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: switch Switch name. character, intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. private elemental function is_parsed (self) Check if CLI has been parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value logical Parsed status. private function usage (self, g, pref, no_header, no_examples, no_epilog, markdown) result(usaged) Print correct usage of CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. integer(kind=I4P), intent(in) :: g Group index. character, intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. logical, intent(in), optional :: markdown Format things with markdown Return Value character(len=:),allocatable Usage string. private function signature (self, bash_completion) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. logical, intent(in), optional :: bash_completion Return the signature for bash completion. Return Value character(len=:),allocatable Signature. Subroutines private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. private subroutine init (self, progname, version, help, description, license, authors, examples, epilog, disable_hv, usage_lun, error_lun, version_lun, error_color, error_style, ignore_unknown_clas) Initialize CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: progname Program name. character, intent(in), optional :: version Program version. character, intent(in), optional :: help Help message introducing the CLI usage. character, intent(in), optional :: description Detailed description message introducing the program. character, intent(in), optional :: license License description. character, intent(in), optional :: authors Authors list. character, intent(in), optional :: examples (1:) Examples of correct usage. character, intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of ‘help’ and ‘version’ CLAs. integer(kind=I4P), intent(in), optional :: usage_lun Unit number to print usage/help. integer(kind=I4P), intent(in), optional :: error_lun Unit number to print error info. integer(kind=I4P), intent(in), optional :: version_lun Unit number to print version/license info. character, intent(in), optional :: error_color ANSI color of error messages. character, intent(in), optional :: error_style ANSI style of error messages. logical, intent(in), optional :: ignore_unknown_clas Disable errors-raising for passed unknown CLAs. private subroutine add_group (self, help, description, exclude, examples, group) Add CLAs group to CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: help Help message. character, intent(in), optional :: description Detailed description. character, intent(in), optional :: exclude Group name of the mutually exclusive group. character, intent(in), optional :: examples (1:) Examples of correct usage of the group. character, intent(in) :: group Name of the grouped CLAs. private subroutine set_mutually_exclusive_groups (self, group1, group2) Set two CLAs group ad mutually exclusive. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in) :: group1 Name of the first grouped CLAs. character, intent(in) :: group2 Name of the second grouped CLAs. private subroutine add (self, pref, group, group_index, switch, switch_ab, help, help_markdown, help_color, help_style, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Add CLA to CLI. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character, intent(in), optional :: switch Switch name. character, intent(in), optional :: switch_ab Abbreviated switch name. character, intent(in), optional :: help Help message describing the CLA. character, intent(in), optional :: help_markdown Longer help message, markdown formatted. character, intent(in), optional :: help_color ANSI color of help messages. character, intent(in), optional :: help_style ANSI style of help messages. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character, intent(in), optional :: act CLA value action. character, intent(in), optional :: def Default value. character, intent(in), optional :: nargs Number of arguments consumed by CLA. character, intent(in), optional :: choices List of allowable values for the argument. character, intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character, intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine check (self, pref, error) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine check_m_exclusive (self, pref) Check if two mutually exclusive CLAs group have been called. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: pref Prefixing string. private subroutine parse (self, pref, args, error) Parse Command Line Interfaces by means of a previously initialized CLAs groups list. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_clasg_indexes (self, ai) Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. private subroutine get_args_from_string (self, args, ai) Get CLAs from string. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. private subroutine get_args_from_invocation (self, ai) Get CLAs from CLI invocation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. private subroutine get_cla (self, val, pref, args, group, switch, position, error) Get CLA (single) value from CLAs list parsed. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val CLA value. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val (1:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_R16P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_R8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_R4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I2P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I1P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_logical (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, logical. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. logical, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_char (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, character. Read more… Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: args String containing command line arguments. character, intent(in), optional :: group Name of group (command) of CLA. character, intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine print_usage (self, pref) Print correct usage. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in), optional :: pref Prefixing string. private subroutine save_bash_completion (self, bash_file, error) Save bash completion script (for named CLAs only). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: bash_file Output file name of bash completion script. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine save_man_page (self, man_file, error) Save CLI usage as man page. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine save_usage_to_markdown (self, markdown_file, error) Save CLI usage as markdown. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character, intent(in) :: markdown_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine errored (self, error, pref, group, switch) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self Object data. integer(kind=I4P), intent(in) :: error Error occurred. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: group Group name. character, intent(in), optional :: switch CLA switch name. private elemental subroutine cli_assign_cli (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: lhs Left hand side. type( command_line_interface ), intent(in) :: rhs Right hand side. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_interface ), intent(inout) :: self CLI data.","tags":"","loc":"module/flap_command_line_interface_t.html"},{"title":"flap_command_line_argument_t – FLAP","text":"Command Line Argument (CLA) class. Uses flap_object_t penf face flap_utils_m module~~flap_command_line_argument_t~~UsesGraph module~flap_command_line_argument_t flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_argument_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_argument_t->module~flap_utils_m module~face face module~flap_command_line_argument_t->module~face penf penf module~flap_command_line_argument_t->penf module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~flap_command_line_argument_t~~UsedByGraph module~flap_command_line_argument_t flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap flap module~flap->module~flap_command_line_argument_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t program~flap_save_usage_to_markdown flap_save_usage_to_markdown program~flap_save_usage_to_markdown->module~flap program~flap_test_choices_logical flap_test_choices_logical program~flap_test_choices_logical->module~flap program~flap_save_man_page flap_save_man_page program~flap_save_man_page->module~flap program~flap_test_nested flap_test_nested program~flap_test_nested->module~flap program~flap_test_hidden flap_test_hidden program~flap_test_hidden->module~flap program~flap_test_duplicated_clas flap_test_duplicated_clas program~flap_test_duplicated_clas->module~flap program~flap_test_ansi_color_style flap_test_ansi_color_style program~flap_test_ansi_color_style->module~flap program~flap_test_ignore_unknown_clas flap_test_ignore_unknown_clas program~flap_test_ignore_unknown_clas->module~flap program~flap_test_nargs_insufficient flap_test_nargs_insufficient program~flap_test_nargs_insufficient->module~flap program~flap_test_group flap_test_group program~flap_test_group->module~flap program~flap_test_minimal flap_test_minimal program~flap_test_minimal->module~flap program~flap_test_group_examples flap_test_group_examples program~flap_test_group_examples->module~flap program~flap_test_nargs_insufficient~2 flap_test_nargs_insufficient program~flap_test_nargs_insufficient~2->module~flap program~flap_save_bash_completion flap_save_bash_completion program~flap_save_bash_completion->module~flap program~flap_test_string flap_test_string program~flap_test_string->module~flap program~flap_test_basic flap_test_basic program~flap_test_basic->module~flap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables ACTION_STORE ACTION_STORE_STAR ACTION_STORE_TRUE ACTION_STORE_FALSE ACTION_PRINT_HELP ACTION_PRINT_VERS ARGS_SEP ERROR_OPTIONAL_NO_DEF ERROR_REQUIRED_M_EXCLUDE ERROR_POSITIONAL_M_EXCLUDE ERROR_NAMED_NO_NAME ERROR_POSITIONAL_NO_POSITION ERROR_POSITIONAL_NO_STORE ERROR_NOT_IN_CHOICES ERROR_MISSING_REQUIRED ERROR_M_EXCLUDE ERROR_CASTING_LOGICAL ERROR_CHOICES_LOGICAL ERROR_NO_LIST ERROR_NARGS_INSUFFICIENT ERROR_VALUE_MISSING ERROR_UNKNOWN ERROR_ENVVAR_POSITIONAL ERROR_ENVVAR_NOT_STORE ERROR_ENVVAR_NARGS ERROR_STORE_STAR_POSITIONAL ERROR_STORE_STAR_NARGS ERROR_STORE_STAR_ENVVAR ERROR_ACTION_UNKNOWN ERROR_DUPLICATED_CLAS Derived Types command_line_argument Functions is_required_passed usage signature has_choices check_list_size Subroutines free check raise_error_m_exclude raise_error_nargs_insufficient raise_error_value_missing raise_error_switch_unknown raise_error_duplicated_clas sanitize_defaults errored check_envvar_consistency check_action_consistency check_optional_consistency check_m_exclude_consistency check_named_consistency check_positional_consistency check_choices get_cla get_cla_from_buffer get_cla_list get_cla_list_from_buffer get_cla_list_varying_R16P get_cla_list_varying_R8P get_cla_list_varying_R4P get_cla_list_varying_I8P get_cla_list_varying_I4P get_cla_list_varying_I2P get_cla_list_varying_I1P get_cla_list_varying_logical get_cla_list_varying_char cla_assign_cla finalize Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: ACTION_STORE = 'STORE' Store value (if invoked a value must be passed). character(len=*), public, parameter :: ACTION_STORE_STAR = 'STORE*' Store value or revert on default if invoked alone. character(len=*), public, parameter :: ACTION_STORE_TRUE = 'STORE_TRUE' Store .true. without the necessity of a value. character(len=*), public, parameter :: ACTION_STORE_FALSE = 'STORE_FALSE' Store .false. without the necessity of a value. character(len=*), public, parameter :: ACTION_PRINT_HELP = 'PRINT_HELP' Print help message. character(len=*), public, parameter :: ACTION_PRINT_VERS = 'PRINT_VERSION' Print version. character(len=*), public, parameter :: ARGS_SEP = '||!||' Arguments separator for multiple valued (list) CLA. integer(kind=I4P), private, parameter :: ERROR_OPTIONAL_NO_DEF = 1 Optional CLA without default value. integer(kind=I4P), private, parameter :: ERROR_REQUIRED_M_EXCLUDE = 2 Required CLA cannot exclude others. integer(kind=I4P), private, parameter :: ERROR_POSITIONAL_M_EXCLUDE = 3 Positional CLA cannot exclude others. integer(kind=I4P), private, parameter :: ERROR_NAMED_NO_NAME = 4 Named CLA without switch name. integer(kind=I4P), private, parameter :: ERROR_POSITIONAL_NO_POSITION = 5 Positional CLA without position. integer(kind=I4P), private, parameter :: ERROR_POSITIONAL_NO_STORE = 6 Positional CLA without action_store. integer(kind=I4P), private, parameter :: ERROR_NOT_IN_CHOICES = 7 CLA value out of a specified choices. integer(kind=I4P), private, parameter :: ERROR_MISSING_REQUIRED = 8 Missing required CLA. integer(kind=I4P), private, parameter :: ERROR_M_EXCLUDE = 9 Two mutually exclusive CLAs have been passed. integer(kind=I4P), private, parameter :: ERROR_CASTING_LOGICAL = 10 Error casting CLA value to logical type. integer(kind=I4P), private, parameter :: ERROR_CHOICES_LOGICAL = 11 Error adding choices check for CLA val of logical type. integer(kind=I4P), private, parameter :: ERROR_NO_LIST = 12 Actual CLA is not list-values. integer(kind=I4P), private, parameter :: ERROR_NARGS_INSUFFICIENT = 13 Multi-valued CLA with insufficient arguments. integer(kind=I4P), private, parameter :: ERROR_VALUE_MISSING = 14 Missing value of CLA. integer(kind=I4P), public, parameter :: ERROR_UNKNOWN = 15 Unknown CLA (switch name). integer(kind=I4P), private, parameter :: ERROR_ENVVAR_POSITIONAL = 16 Envvar not allowed for positional CLA. integer(kind=I4P), private, parameter :: ERROR_ENVVAR_NOT_STORE = 17 Envvar not allowed action different from store; integer(kind=I4P), private, parameter :: ERROR_ENVVAR_NARGS = 18 Envvar not allowed for list-values CLA. integer(kind=I4P), private, parameter :: ERROR_STORE_STAR_POSITIONAL = 19 Action store* not allowed for positional CLA. integer(kind=I4P), private, parameter :: ERROR_STORE_STAR_NARGS = 20 Action store* not allowed for list-values CLA. integer(kind=I4P), private, parameter :: ERROR_STORE_STAR_ENVVAR = 21 Action store* not allowed for environment variable CLA. integer(kind=I4P), private, parameter :: ERROR_ACTION_UNKNOWN = 22 Unknown CLA (switch name). integer(kind=I4P), private, parameter :: ERROR_DUPLICATED_CLAS = 23 Duplicated CLAs passed, passed multiple instance of the same CLA. Derived Types type, public, extends( object ) :: command_line_argument Command Line Argument (CLA) class. Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_style ANSI style of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_color ANSI color of error messages. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=512), public, allocatable :: examples (:) Examples of correct usage. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: switch Switch name. character(len=:), public, allocatable :: switch_ab Abbreviated switch name. logical, public :: is_required = .false. Flag for set required argument. logical, public :: is_positional = .false. Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), public :: position = 0_I4P Position of positional CLA. logical, public :: is_passed = .false. Flag for checking if CLA has been passed to CLI. logical, public :: is_hidden = .false. Flag for hiding CLA, thus it does not compare into help. character(len=:), public, allocatable :: act CLA value action. character(len=:), public, allocatable :: def Default value. character(len=:), public, allocatable :: nargs Number of arguments consumed by CLA. character(len=:), public, allocatable :: choices List (comma separated) of allowable values for the argument. character(len=:), public, allocatable :: val CLA value. character(len=:), public, allocatable :: envvar Environment variable from which take value. Finalizations Procedures final :: finalize Free dynamic memory when finalizing. Type-Bound Procedures procedure, public, pass(self) :: free_object Free dynamic memory. procedure, public, pass(self) :: print_version Print version. procedure, public, pass(self) :: print_error_message Print meaningful error message. procedure, public, pass(self) :: set_examples Set examples of correct usage. procedure, public, pass(lhs ) :: assign_object Assignment overloading. procedure, public :: free Free dynamic memory. procedure, public :: check Check data consistency. procedure, public :: is_required_passed Check if required CLA is passed. procedure, public :: raise_error_m_exclude Raise error mutually exclusive CLAs passed. procedure, public :: raise_error_nargs_insufficient Raise error insufficient number of argument values passed. procedure, public :: raise_error_value_missing Raise error missing value. procedure, public :: raise_error_switch_unknown Raise error switch_unknown. procedure, public :: raise_error_duplicated_clas Raise error duplicated CLAs passed. generic, public :: get => get_cla, get_cla_list Get CLA value(s). generic, public :: get_varying => get_cla_list_varying_R8P, get_cla_list_varying_R4P, get_cla_list_varying_I8P, get_cla_list_varying_I4P, get_cla_list_varying_I2P, get_cla_list_varying_I1P, get_cla_list_varying_logical, get_cla_list_varying_char Get CLA value(s) from varying size list. procedure, public :: has_choices Return true if CLA has defined choices. procedure, public :: sanitize_defaults Sanitize default values. procedure, public :: signature Get signature. procedure, public :: usage Get correct usage. procedure, private :: errored Trig error occurence and print meaningful message. procedure, private :: check_envvar_consistency Check data consistency for envvar CLA. procedure, private :: check_action_consistency Check CLA action consistency. procedure, private :: check_optional_consistency Check optional CLA consistency. procedure, private :: check_m_exclude_consistency Check mutually exclusion consistency. procedure, private :: check_named_consistency Check named CLA consistency. procedure, private :: check_positional_consistency Check positional CLA consistency. procedure, private :: check_choices Check if CLA value is in allowed choices. procedure, private :: check_list_size Check CLA multiple values list size consistency. procedure, private :: get_cla Get CLA (single) value. procedure, private :: get_cla_from_buffer Get CLA (single) value from a buffer. procedure, private :: get_cla_list Get CLA multiple values. procedure, private :: get_cla_list_from_buffer Get CLA (single) value from a buffer. procedure, private :: get_cla_list_varying_R16P Get CLA multiple values, varying size, R16P. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values, varying size, R8P. procedure, private :: get_cla_list_varying_R4P Get CLA multiple values, varying size, R4P. procedure, private :: get_cla_list_varying_I8P Get CLA multiple values, varying size, I8P. procedure, private :: get_cla_list_varying_I4P Get CLA multiple values, varying size, I4P. procedure, private :: get_cla_list_varying_I2P Get CLA multiple values, varying size, I2P. procedure, private :: get_cla_list_varying_I1P Get CLA multiple values, varying size, I1P. procedure, private :: get_cla_list_varying_logical Get CLA multiple values, varying size, bool. procedure, private :: get_cla_list_varying_char Get CLA multiple values, varying size, char. procedure, private :: cla_assign_cla Assignment operator. generic, private :: assignment(=) => cla_assign_cla Assignment operator overloading. Functions private function is_required_passed (self, pref) result(is_ok) Check if required CLA is passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. Return Value logical Check result. private function usage (self, pref, markdown) Get correct usage. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLAs group data. character, intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: markdown Format for markdown Return Value character(len=:),allocatable Usage string. private function signature (self, bash_completion, plain) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLA data. logical, intent(in), optional :: bash_completion Return the signature for bash completion. logical, intent(in), optional :: plain Return the signature as plain switches list. Return Value character(len=:),allocatable Signature. private pure function has_choices (self) Return true if CLA has choices. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLA data. Return Value logical Check result. private function check_list_size (self, Nv, val, pref) result(is_ok) Check CLA multiple values list size consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character, intent(in) :: val First value. character, intent(in), optional :: pref Prefixing string. Return Value logical Check result. Subroutines private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. private subroutine check (self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. private subroutine raise_error_m_exclude (self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. private subroutine raise_error_nargs_insufficient (self, pref) Raise error insufficient number of argument values passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. private subroutine raise_error_value_missing (self, pref) Raise error missing value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. private subroutine raise_error_switch_unknown (self, switch, pref) Raise error switch_unknown. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: switch CLA switch name. character, intent(in), optional :: pref Prefixing string. private subroutine raise_error_duplicated_clas (self, switch, pref) Raise error duplicated CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: switch CLA switch name. character, intent(in), optional :: pref Prefixing string. private subroutine sanitize_defaults (self) Sanitize defaults values. Read more… Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLAsG data. private subroutine errored (self, error, pref, switch, val_str, log_value) Trig error occurence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: error Error occurred. character, intent(in), optional :: pref Prefixing string. character, intent(in), optional :: switch CLA switch name. character, intent(in), optional :: val_str Value string. character, intent(in), optional :: log_value Logical value to be casted. private subroutine check_envvar_consistency (self, pref) Check data consistency for envvar CLA. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. private subroutine check_action_consistency (self, pref) Check CLA action consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. private subroutine check_optional_consistency (self, pref) Check optional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. private subroutine check_m_exclude_consistency (self, pref) Check mutually exclusion consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. private subroutine check_named_consistency (self, pref) Check named CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. private subroutine check_positional_consistency (self, pref) Check positional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. private subroutine check_choices (self, val, pref) Check if CLA value is in allowed choices. Read more… Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(in) :: val CLA value. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla (self, val, pref) Get CLA (single) value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(inout) :: val CLA value. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_from_buffer (self, buffer, val, pref) Get CLA (single) value from parsed value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val CLA value. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list (self, pref, val) Get CLA multiple values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. private subroutine get_cla_list_from_buffer (self, buffer, val, pref) Get CLA multiple values from a buffer. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val (1:) CLA value. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_R16P (self, val, pref) Get CLA (multiple) value with varying size, real(R16P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_R8P (self, val, pref) Get CLA (multiple) value with varying size, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_R4P (self, val, pref) Get CLA (multiple) value with varying size, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I8P (self, val, pref) Get CLA (multiple) value with varying size, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I4P (self, val, pref) Get CLA (multiple) value with varying size, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I2P (self, val, pref) Get CLA (multiple) value with varying size, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I1P (self, val, pref) Get CLA (multiple) value with varying size, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_logical (self, val, pref) Get CLA (multiple) value with varying size, logical. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. logical, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_char (self, val, pref) Get CLA (multiple) value with varying size, character. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character, intent(out), allocatable :: val (:) CLA values. character, intent(in), optional :: pref Prefixing string. private elemental subroutine cla_assign_cla (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: lhs Left hand side. type( command_line_argument ), intent(in) :: rhs Rigth hand side. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_argument ), intent(inout) :: self CLA data.","tags":"","loc":"module/flap_command_line_argument_t.html"},{"title":"flap_utils_m – FLAP","text":"FLAP utils. Uses penf module~~flap_utils_m~~UsesGraph module~flap_utils_m flap_utils_m penf penf module~flap_utils_m->penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~flap_utils_m~~UsedByGraph module~flap_utils_m flap_utils_m module~flap_command_line_argument_t flap_command_line_argument_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_interface_t flap_command_line_interface_t module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap flap module~flap->module~flap_command_line_argument_t module~flap->module~flap_command_line_interface_t module~flap->module~flap_command_line_arguments_group_t program~flap_save_usage_to_markdown flap_save_usage_to_markdown program~flap_save_usage_to_markdown->module~flap program~flap_test_choices_logical flap_test_choices_logical program~flap_test_choices_logical->module~flap program~flap_save_man_page flap_save_man_page program~flap_save_man_page->module~flap program~flap_test_nested flap_test_nested program~flap_test_nested->module~flap program~flap_test_hidden flap_test_hidden program~flap_test_hidden->module~flap program~flap_test_duplicated_clas flap_test_duplicated_clas program~flap_test_duplicated_clas->module~flap program~flap_test_ansi_color_style flap_test_ansi_color_style program~flap_test_ansi_color_style->module~flap program~flap_test_ignore_unknown_clas flap_test_ignore_unknown_clas program~flap_test_ignore_unknown_clas->module~flap program~flap_test_nargs_insufficient flap_test_nargs_insufficient program~flap_test_nargs_insufficient->module~flap program~flap_test_group flap_test_group program~flap_test_group->module~flap program~flap_test_minimal flap_test_minimal program~flap_test_minimal->module~flap program~flap_test_group_examples flap_test_group_examples program~flap_test_group_examples->module~flap program~flap_test_nargs_insufficient~2 flap_test_nargs_insufficient program~flap_test_nargs_insufficient~2->module~flap program~flap_save_bash_completion flap_save_bash_completion program~flap_save_bash_completion->module~flap program~flap_test_string flap_test_string program~flap_test_string->module~flap program~flap_test_basic flap_test_basic program~flap_test_basic->module~flap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces count Functions count_substring replace replace_all unique upper_case wstrip Subroutines tokenize Interfaces public interface count Overload intrinsic function count for counting substring occurences into strings. private elemental function count_substring (string, substring) result(No) Count the number of occurences of a substring into a string. Arguments Type Intent Optional Attributes Name character, intent(in) :: string String. character, intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Functions private elemental function count_substring (string, substring) result(No) Count the number of occurences of a substring into a string. Arguments Type Intent Optional Attributes Name character, intent(in) :: string String. character, intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. public pure function replace (string, substring, restring) result(newstring) Replace substring (only first occurrence) into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. character(len=*), intent(in) :: substring Substring to be replaced. character(len=*), intent(in) :: restring String to be inserted. Return Value character(len=:),allocatable New modified string. public pure function replace_all (string, substring, restring) result(newstring) Replace substring (all occurrences) into a string. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. character(len=*), intent(in) :: substring Substring to be replaced. character(len=*), intent(in) :: restring String to be inserted. Return Value character(len=:),allocatable New modified string. public elemental function unique (string, substring) result(uniq) Reduce to one (unique) multiple (sequential) occurrences of a characters substring into a string. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be parsed. character(len=*), intent(in) :: substring Substring which multiple occurences must be reduced to one. Return Value character(len=len) String parsed. public elemental function upper_case (string) Convert the lower case characters of a string to upper case one. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be converted. Return Value character(len=len) Converted string. public pure function wstrip (string) result(newstring) Strip out leading and trailing white spaces from a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. Return Value character(len=:),allocatable New modified string. Subroutines public pure subroutine tokenize (strin, delimiter, toks, Nt) Tokenize a string in order to parse it. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strin String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len), intent(out), allocatable :: toks (:) Tokens. integer(kind=I4P), intent(out), optional :: Nt Number of tokens.","tags":"","loc":"module/flap_utils_m.html"},{"title":"face_test_colors – FLAP","text":"Uses face program~~face_test_colors~~UsesGraph program~face_test_colors face_test_colors module~face face program~face_test_colors->module~face iso_fortran_env iso_fortran_env module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. FACE test. Calls program~~face_test_colors~~CallsGraph program~face_test_colors face_test_colors interface~colorize colorize program~face_test_colors->interface~colorize proc~colorize_default colorize_default interface~colorize->proc~colorize_default proc~color_index color_index proc~colorize_default->proc~color_index proc~upper upper proc~colorize_default->proc~upper proc~style_index style_index proc~colorize_default->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code face_test_colors Source Code program face_test_colors !< FACE test. use face implicit none print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'black' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'red' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'green' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'yellow' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'magenta' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'cyan' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'white' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'default' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'black_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'red_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'green_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'yellow_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'magenta_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'cyan_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'white_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'black' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'red' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'green' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'yellow' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'blue' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'magenta' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'cyan' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'white' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'default' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'black_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'red_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'green_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'yellow_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'blue_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'magenta_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'cyan_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'white_intense' ) endprogram face_test_colors","tags":"","loc":"program/face_test_colors.html"},{"title":"face_test_ucs4 – FLAP","text":"Uses face program~~face_test_ucs4~~UsesGraph program~face_test_ucs4 face_test_ucs4 module~face face program~face_test_ucs4->module~face iso_fortran_env iso_fortran_env module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. FACE test. Contents Source Code face_test_ucs4 Source Code program face_test_ucs4 !< FACE test. use face implicit none #ifdef UCS4_SUPPORTED character ( kind = UCS4 , len = :), allocatable :: string_1 !< A string. character ( kind = UCS4 , len = :), allocatable :: string_2 !< A string. character ( kind = UCS4 , len = :), allocatable :: string_3 !< A string. string_1 = colorize ( 'Hello' , color_fg = 'blue' ) string_2 = colorize ( UCS4_ ' ÜÇŞ4' , color_fg = 'red' ) string_3 = colorize ( ' World' , color_fg = 'blue' ) print '(A)' , string_1 // string_2 // string_3 #endif endprogram face_test_ucs4","tags":"","loc":"program/face_test_ucs4.html"},{"title":"face_test_basic – FLAP","text":"Uses face program~~face_test_basic~~UsesGraph program~face_test_basic face_test_basic module~face face program~face_test_basic->module~face iso_fortran_env iso_fortran_env module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. FACE test. Calls program~~face_test_basic~~CallsGraph program~face_test_basic face_test_basic proc~colors_samples colors_samples program~face_test_basic->proc~colors_samples proc~styles_samples styles_samples program~face_test_basic->proc~styles_samples interface~colorize colorize proc~colors_samples->interface~colorize proc~styles_samples->interface~colorize proc~colorize_default colorize_default interface~colorize->proc~colorize_default proc~color_index color_index proc~colorize_default->proc~color_index proc~upper upper proc~colorize_default->proc~upper proc~style_index style_index proc~colorize_default->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code face_test_basic Source Code program face_test_basic !< FACE test. use face implicit none call colors_samples call styles_samples endprogram face_test_basic","tags":"","loc":"program/face_test_basic.html"},{"title":"face_test_styles – FLAP","text":"Uses face program~~face_test_styles~~UsesGraph program~face_test_styles face_test_styles module~face face program~face_test_styles->module~face iso_fortran_env iso_fortran_env module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. FACE test. Calls program~~face_test_styles~~CallsGraph program~face_test_styles face_test_styles interface~colorize colorize program~face_test_styles->interface~colorize proc~colorize_default colorize_default interface~colorize->proc~colorize_default proc~color_index color_index proc~colorize_default->proc~color_index proc~upper upper proc~colorize_default->proc~upper proc~style_index style_index proc~colorize_default->proc~style_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code face_test_styles Source Code program face_test_styles !< FACE test. use face implicit none print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'bold_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'italics_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'underline_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'inverse_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'strikethrough_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'framed_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'encircled_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'overlined_on' ) endprogram face_test_styles","tags":"","loc":"program/face_test_styles.html"},{"title":"test_tester_1 – FLAP","text":"Uses tester program~~test_tester_1~~UsesGraph program~test_tester_1 test_tester_1 module~tester tester program~test_tester_1->module~tester iso_fortran_env iso_fortran_env module~tester->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables rk x y a b c d test Source Code test_tester_1 Variables Type Attributes Name Initial integer, parameter :: rk = selected_real_kind(15) complex(kind=rk) :: x complex(kind=rk) :: y complex(kind=rk) :: a (5) complex(kind=rk) :: b (5) complex :: c (3) complex :: d (3) type( tester_t ) :: test Source Code program test_tester_1 use tester implicit none integer , parameter :: rk = selected_real_kind ( 15 ) complex ( kind = rk ) :: x , y complex ( kind = rk ) :: a ( 5 ), b ( 5 ) complex :: c ( 3 ), d ( 3 ) type ( tester_t ) :: test call test % init () call test % assert_equal (( 1234 , - 1234 ), ( 1234 , - 1234 )) call test % assert_close (( 1._rk , 0._rk ), ( 1._rk , 0._rk )) call test % assert_close ( cmplx ( 1. , epsilon ( 0. )), ( 1. , 0. )) x = ( 0._rk , 1._rk ) y = cmplx ( epsilon ( 0._rk ), 1._rk , kind = rk ) call test % assert_close ( x , y ) x = cmplx ( - 115 8.1181871905803291 , 77 9.0494065373754893 ) y = cmplx ( - 115 8.1181871905803291 , 77 9.0494065373754893 ) call test % assert_equal ( x , y ) c = 1 d = 1 d = d + cmplx ( 0 , epsilon ( 0. )) call test % assert_close ( c , d ) c = cmplx ( 115427 4.4026509234681726 , - 46108 7.8365501734078862 ) d = cmplx ( 115427 4.4026509234681726 , - 46108 7.8365501734078862 ) call test % assert_equal ( c , d ) a = - 10 b = - 10 call test % assert_equal ( a , b ) a = 0 b = epsilon ( 0._rk ) call test % assert_close ( a , b ) b ( 1 ) = b ( 1 ) + cmplx ( 0._rk , epsilon ( real ( b ( 1 ))), kind = rk ) call test % assert_close ( a , b ) call test % print () end program test_tester_1","tags":"","loc":"program/test_tester_1.html"},{"title":"test_tester_05 – FLAP","text":"Uses tester program~~test_tester_05~~UsesGraph program~test_tester_05 test_tester_05 module~tester tester program~test_tester_05->module~tester iso_fortran_env iso_fortran_env module~tester->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables i_k1 test Source Code test_tester_05 Variables Type Attributes Name Initial integer, parameter :: i_k1 = selected_int_kind(3) type( tester_t ) :: test Source Code program test_tester_05 use tester implicit none integer , parameter :: i_k1 = selected_int_kind ( 3 ) type ( tester_t ) :: test call test % init () call test % assert_equal ( 8765_i_k1 , 8765_i_k1 ) call test % assert_equal ( & [ - 3261_i_k1 , - 1169_i_k1 , 2967_i_k1 , - 3736_i_k1 , 3504_i_k1 ], & [ - 3261_i_k1 , - 1169_i_k1 , 2967_i_k1 , - 3736_i_k1 , 3504_i_k1 ]) call test % assert_positive ( 1982_i_k1 ) call test % assert_positive ([ 6987_i_k1 , 0_i_k1 ]) call test % print () end program test_tester_05","tags":"","loc":"program/test_tester_05.html"},{"title":"test_tester_2 – FLAP","text":"Uses tester program~~test_tester_2~~UsesGraph program~test_tester_2 test_tester_2 module~tester tester program~test_tester_2->module~tester iso_fortran_env iso_fortran_env module~tester->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables test Source Code test_tester_2 Variables Type Attributes Name Initial type( tester_t ) :: test Source Code program test_tester_2 use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal ( 1 , 2 ) call test % print () end program test_tester_2","tags":"","loc":"program/test_tester_2.html"},{"title":"test_tester_3 – FLAP","text":"Uses tester program~~test_tester_3~~UsesGraph program~test_tester_3 test_tester_3 module~tester tester program~test_tester_3->module~tester iso_fortran_env iso_fortran_env module~tester->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables test Source Code test_tester_3 Variables Type Attributes Name Initial type( tester_t ) :: test Source Code program test_tester_3 use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal ([. false ., . true .], [ 1 > 2 , 2 > 1 ]) call test % print () end program test_tester_3","tags":"","loc":"program/test_tester_3.html"},{"title":"test_tester_1 – FLAP","text":"Uses tester program~~test_tester_1~2~~UsesGraph program~test_tester_1~2 test_tester_1 module~tester tester program~test_tester_1~2->module~tester iso_fortran_env iso_fortran_env module~tester->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables long_k pi test Source Code test_tester_1 Variables Type Attributes Name Initial integer, parameter :: long_k = selected_int_kind(18) double precision :: pi = 4*atan(1.d0) type( tester_t ) :: test Source Code program test_tester_1 use tester implicit none integer , parameter :: long_k = selected_int_kind ( 18 ) double precision :: pi = 4 * atan ( 1.d0 ) type ( tester_t ) :: test call test % init () call test % assert_equal ( - 121 , - 11 ** 2 ) call test % assert_equal ([ 1 , - 10 , 1899010 ], [ 1 , - 10 , 1899010 ]) call test % assert_equal ([ 0.2420243742417814d0 , 0.4924788296716989d0 , & 0.8541147722227219d0 , 0.267520651034313d0 , 0.6948550035165076d0 ], & [ 0.2420243742417814d0 , 0.4924788296716989d0 , & 0.8541147722227219d0 , 0.267520651034313d0 , 0.6948550035165076d0 ]) call test % assert_close ( 0.d0 , sin ( pi )) call test % assert_equal ( 0.d0 , 0 * 1.d0 ) call test % assert_equal (. true ., 2 > 1 ) call test % assert_equal ( 1.0 , 1.0 ) call test % assert_equal ( & [ 7.2936402920067644 , 3.0975232096437191 , 9.2077205929200456 , & 9.0014871205366358 ], & [ 7.2936402920067644 , 3.0975232096437191 , 9.2077205929200456 , & 9.0014871205366358 ]) call test % assert_close ( 1.d0 , ( 1.d0 + 1.d-16 )) call test % assert_close ( 1. , ( 1. + 1.e-7 )) call test % assert_close ([ 0.58557761 , 0.04035789 , 0.30463428 , & 0.57437861 , 0.4879709 , 0.00986957 ], & [ 0.58557761 + epsilon ( 1.0 ), 0.04035789 , 0.30463428 + 2 * epsilon ( 1.0 ), & 0.57437861 , 0.4879709 , 0.00986957 - epsilon ( 1.0 )]) call test % assert_close ([ 1.d0 , 2.d0 ], [ 1.d0 , 2.d0 ]) call test % assert_positive ( epsilon ( 1. )) call test % assert_positive ( 0.1 ) call test % assert_positive ( 0.1d0 ) call test % assert_positive ([ 1. , 2. , 0. ]) call test % assert_positive ([ 1.d0 , huge ( 1.d0 )]) call test % assert_equal ( 1 , 1 ) call test % assert_equal ( 1_long_k , 1_long_k ) call test % assert_equal ([ 1 , - huge ( 1 ), huge ( 1 ), 0 ], [ 1 , - huge ( 1 ), huge ( 1 ), 0 ]) call test % assert_equal ([ 1_long_k , - huge ( 1_long_k ), huge ( 1_long_k ), 0_long_k ], & [ 1_long_k , - huge ( 1_long_k ), huge ( 1_long_k ), 0_long_k ]) call test % assert_positive ( 2 ** 30 ) call test % assert_positive ( 2_long_k ** 62 ) call test % assert_positive ([ 2 ** 30 , 1 , 0 ]) call test % assert_positive ([ 2_long_k ** 62 , 1_long_k , 0_long_k ]) call test % print () end program test_tester_1","tags":"","loc":"program/test_tester_1~2.html"},{"title":"test_tester_7 – FLAP","text":"Uses tester program~~test_tester_7~~UsesGraph program~test_tester_7 test_tester_7 module~tester tester program~test_tester_7->module~tester iso_fortran_env iso_fortran_env module~tester->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables test Source Code test_tester_7 Variables Type Attributes Name Initial type( tester_t ) :: test Source Code program test_tester_7 use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal ([ 1 , 2 , huge ( 1 )], [ 0 , 2 , huge ( 1 )]) call test % print () end program test_tester_7","tags":"","loc":"program/test_tester_7.html"},{"title":"test_tester_4 – FLAP","text":"Uses tester program~~test_tester_4~~UsesGraph program~test_tester_4 test_tester_4 module~tester tester program~test_tester_4->module~tester iso_fortran_env iso_fortran_env module~tester->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables test Source Code test_tester_4 Variables Type Attributes Name Initial type( tester_t ) :: test Source Code program test_tester_4 use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal (. true ., 1 > 2 ) call test % print () end program test_tester_4","tags":"","loc":"program/test_tester_4.html"},{"title":"test_tester_8 – FLAP","text":"Uses tester program~~test_tester_8~~UsesGraph program~test_tester_8 test_tester_8 module~tester tester program~test_tester_8->module~tester iso_fortran_env iso_fortran_env module~tester->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables test long_k Source Code test_tester_8 Variables Type Attributes Name Initial type( tester_t ) :: test integer, parameter :: long_k = selected_int_kind(18) Source Code program test_tester_8 use tester implicit none type ( tester_t ) :: test integer , parameter :: long_k = selected_int_kind ( 18 ) call test % init () call test % assert_equal ([ 1_long_k , 2_long_k , huge ( 1_long_k )], [ 0_long_k , 2_long_k , huge ( 1_long_k )]) call test % print () end program test_tester_8","tags":"","loc":"program/test_tester_8.html"},{"title":"test_tester_6 – FLAP","text":"Uses tester program~~test_tester_6~~UsesGraph program~test_tester_6 test_tester_6 module~tester tester program~test_tester_6->module~tester iso_fortran_env iso_fortran_env module~tester->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables rk pi test Source Code test_tester_6 Variables Type Attributes Name Initial integer, parameter :: rk = selected_real_kind(15) real(kind=rk), parameter :: pi = 4*atan(1._rk) type( tester_t ) :: test Source Code program test_tester_6 use tester implicit none integer , parameter :: rk = selected_real_kind ( 15 ) real ( kind = rk ), parameter :: pi = 4 * atan ( 1._rk ) type ( tester_t ) :: test call test % init () call test % assert_close ( sin ( 2 * pi ), 0._rk ) call test % assert_close ( sin ( 2 * 3.1415927 ), 0. ) call test % print () end program test_tester_6","tags":"","loc":"program/test_tester_6.html"},{"title":"flap_test_nargs_insufficient – FLAP","text":"Uses penf flap program~~flap_test_nargs_insufficient~~UsesGraph program~flap_test_nargs_insufficient flap_test_nargs_insufficient penf penf program~flap_test_nargs_insufficient->penf module~flap flap program~flap_test_nargs_insufficient->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage See usage instructions . Calls program~~flap_test_nargs_insufficient~~CallsGraph program~flap_test_nargs_insufficient flap_test_nargs_insufficient str str program~flap_test_nargs_insufficient->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables cli rval error Source Code flap_test_nargs_insufficient Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). real(kind=R8P) :: rval (3) Real value. integer(kind=I4P) :: error Error trapping flag. Source Code program flap_test_nargs_insufficient !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<### Usage !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). real ( R8P ) :: rval ( 3 ) !< Real value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'test_nargs_insufficient' , description = 'Test insufficient nargs' ) call cli % add ( switch = '-i' , help = 'Real list input' , required = . true ., act = 'store' , nargs = '3' , error = error ) call cli % get ( switch = '-i' , val = rval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Real list input = ' // trim ( str ( n = rval )) endprogram flap_test_nargs_insufficient","tags":"","loc":"program/flap_test_nargs_insufficient.html"},{"title":"flap_test_group_examples – FLAP","text":"Uses penf flap program~~flap_test_group_examples~~UsesGraph program~flap_test_group_examples flap_test_group_examples penf penf program~flap_test_group_examples->penf module~flap flap program~flap_test_group_examples->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~flap_test_group_examples~~CallsGraph program~flap_test_group_examples flap_test_group_examples str str program~flap_test_group_examples->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables cli a_string int_value f_value error Source Code flap_test_group_examples Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: a_string String value. integer(kind=I4P) :: int_value Integer value. real(kind=R4P) :: f_value Float value. integer(kind=I4P) :: error Error trapping flag. Source Code program flap_test_group_examples !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: a_string !< String value. integer ( I4P ) :: int_value !< Integer value. real ( R4P ) :: f_value !< Float value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( description = 'group examples usage FLAP example' , & examples = [ \"flap_test_group_examples -s 'test string'      \" , & \"flap_test_group_examples --string 'test string'\" ]) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . false ., act = 'store' , def = 'test' , error = error ) call cli % add_group ( group = 'gwe' , description = 'Group with examples' , & examples = [ \"flap_test_group_examples gwe --integer 32\" , & \"flap_test_group_examples gwe -i 12       \" ]) call cli % add ( group = \"gwe\" , & switch = '--integer' , switch_ab = '-i' , help = 'Integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) call cli % add_group ( group = 'gne' , description = 'Group without examples' ) call cli % add ( group = 'gne' , & switch = '--float' , switch_ab = '-f' , help = 'Float input' , required = . false ., act = 'store' , def = '-1.0' , error = error ) print '(A)' , cli % progname // ' has been called with the following arguments:' call cli % get ( switch = '-s' , val = a_string , error = error ) print '(A)' , 'String       = ' // trim ( adjustl ( a_string )) if ( cli % run_command ( 'gwe' )) then call cli % get ( group = 'gwe' , switch = '-i' , val = int_value , error = error ) print '(A)' , 'Integer      = ' // trim ( str ( int_value )) endif if ( cli % run_command ( 'gne' )) then call cli % get ( group = 'gne' , switch = '-f' , val = f_value , error = error ) print '(A)' , 'Float        = ' // trim ( str ( f_value )) endif print '(A,I0)' , 'Error code   = ' , error endprogram flap_test_group_examples","tags":"","loc":"program/flap_test_group_examples.html"},{"title":"flap_test_group – FLAP","text":"Uses tester penf flap program~~flap_test_group~~UsesGraph program~flap_test_group flap_test_group module~tester tester program~flap_test_group->module~tester module~flap flap program~flap_test_group->module~flap penf penf program~flap_test_group->penf iso_fortran_env iso_fortran_env module~tester->iso_fortran_env module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~face face module~flap_command_line_interface_t->module~face module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_object_t flap_object_t module~flap_command_line_interface_t->module~flap_object_t module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~face module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->module~face module~flap_command_line_arguments_group_t->module~flap_object_t module~face->iso_fortran_env module~flap_utils_m->penf module~flap_object_t->penf module~flap_object_t->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~flap_test_group~~CallsGraph program~flap_test_group flap_test_group proc~fake_call fake_call program~flap_test_group->proc~fake_call Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables crash_test_dummy switch_value_domain switch_value_grid switch_value_spectrum Subroutines fake_call Source Code flap_test_group Variables Type Attributes Name Initial type( tester_t ) :: crash_test_dummy Tests handler. logical :: switch_value_domain Switch sentinel. logical :: switch_value_grid Switch sentinel. logical :: switch_value_spectrum Switch sentinel. Subroutines subroutine fake_call (args, spectrum, domain, grid) Wrapper for fake calls. Arguments Type Intent Optional Attributes Name character, intent(in) :: args Fake arguments. logical, intent(out) :: spectrum Spectrum value. logical, intent(out) :: domain Domain value. logical, intent(out) :: grid Grid value. Source Code program flap_test_group !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf use tester implicit none type ( tester_t ) :: crash_test_dummy !< Tests handler. logical :: switch_value_domain !< Switch sentinel. logical :: switch_value_grid !< Switch sentinel. logical :: switch_value_spectrum !< Switch sentinel. call crash_test_dummy % init call fake_call ( args = '' , spectrum = switch_value_spectrum , domain = switch_value_domain , grid = switch_value_grid ) print * , 'test_group' print * , 'spectrum = ' , switch_value_spectrum print * , 'domain   = ' , switch_value_domain print * , 'grid     = ' , switch_value_grid call crash_test_dummy % assert_equal ( switch_value_spectrum , . false .) call crash_test_dummy % assert_equal ( switch_value_domain , . false .) call crash_test_dummy % assert_equal ( switch_value_grid , . false .) call fake_call ( args = 'new -s' , spectrum = switch_value_spectrum , domain = switch_value_domain , grid = switch_value_grid ) print * , 'test_group new -s' print * , 'spectrum = ' , switch_value_spectrum print * , 'domain   = ' , switch_value_domain print * , 'grid     = ' , switch_value_grid call crash_test_dummy % assert_equal ( switch_value_spectrum , . true .) call crash_test_dummy % assert_equal ( switch_value_domain , . false .) call crash_test_dummy % assert_equal ( switch_value_grid , . false .) call fake_call ( args = 'new -d' , spectrum = switch_value_spectrum , domain = switch_value_domain , grid = switch_value_grid ) print * , 'test_group new -d' print * , 'spectrum = ' , switch_value_spectrum print * , 'domain   = ' , switch_value_domain print * , 'grid     = ' , switch_value_grid call crash_test_dummy % assert_equal ( switch_value_spectrum , . false .) call crash_test_dummy % assert_equal ( switch_value_domain , . true .) call crash_test_dummy % assert_equal ( switch_value_grid , . false .) call fake_call ( args = 'new -g' , spectrum = switch_value_spectrum , domain = switch_value_domain , grid = switch_value_grid ) print * , 'test_group new -g' print * , 'spectrum = ' , switch_value_spectrum print * , 'domain   = ' , switch_value_domain print * , 'grid     = ' , switch_value_grid call crash_test_dummy % assert_equal ( switch_value_spectrum , . false .) call crash_test_dummy % assert_equal ( switch_value_domain , . false .) call crash_test_dummy % assert_equal ( switch_value_grid , . true .) call crash_test_dummy % print contains subroutine fake_call ( args , spectrum , domain , grid ) !--------------------------------------------------------------------------------------------------------------------------------- !< Wrapper for fake calls. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: args !< Fake arguments. logical , intent ( out ) :: spectrum !< Spectrum value. logical , intent ( out ) :: domain !< Domain value. logical , intent ( out ) :: grid !< Grid value. type ( command_line_interface ) :: cli !< Command Line Interface (CLI). integer ( I4P ) :: error !< Error trapping flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % init call cli % add_group ( group = 'new' , description = 'create new instance' ) call cli % add ( group = 'new' , switch = '--spectrum' , switch_ab = '-s' , & help = 'Create new spectrum' , required = . false ., def = '.false.' , & act = 'store_true' , error = error ) if ( error /= 0 ) stop call cli % add ( group = 'new' , switch = '--domain' , switch_ab = '-d' , & help = 'Create new domain' , required = . false ., def = '.false.' , & act = 'store_true' , error = error ) if ( error /= 0 ) stop call cli % add ( group = 'new' , switch = '--grid' , switch_ab = '-g' , & help = 'Create new grid' , required = . false ., def = '.false.' , & act = 'store_true' , error = error ) if ( error /= 0 ) stop call cli % parse ( args = args , error = error ) if ( error /= 0 ) stop call cli % get ( group = 'new' , switch = '--spectrum' , val = spectrum , error = error ) if ( error /= 0 ) stop call cli % get ( group = 'new' , switch = '--domain' , val = domain , error = error ) if ( error /= 0 ) stop call cli % get ( group = 'new' , switch = '--grid' , val = grid , error = error ) if ( error /= 0 ) stop !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine fake_call endprogram flap_test_group","tags":"","loc":"program/flap_test_group.html"},{"title":"flap_test_minimal – FLAP","text":"Uses penf flap program~~flap_test_minimal~~UsesGraph program~flap_test_minimal flap_test_minimal penf penf program~flap_test_minimal->penf module~flap flap program~flap_test_minimal->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Note The minimal steps for using a FLAP CLI are:\n+ init the CLI;\n+ add at least one CLA to the CLI;\n+ get the CLAs defined into the CLI; Note that get automatically calls parse method beacuse it is not explicitely called. Contents Variables cli string error Source Code flap_test_minimal Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: string String value. integer(kind=I4P) :: error Error trapping flag. Source Code program flap_test_minimal !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !< !< @note The minimal steps for using a FLAP CLI are: !<+ `init` the CLI; !<+ `add` at least one CLA to the CLI; !<+ `get` the CLAs defined into the CLI; !< !<Note that `get` automatically calls `parse` method beacuse it is not explicitely called. use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: string !< String value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( description = 'minimal FLAP example' ) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'a string' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = string , error = error ) ; if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String = ' // trim ( adjustl ( string )) endprogram flap_test_minimal","tags":"","loc":"program/flap_test_minimal.html"},{"title":"flap_test_nargs_insufficient – FLAP","text":"Uses penf flap program~~flap_test_nargs_insufficient~2~~UsesGraph program~flap_test_nargs_insufficient~2 flap_test_nargs_insufficient penf penf program~flap_test_nargs_insufficient~2->penf module~flap flap program~flap_test_nargs_insufficient~2->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage See usage instructions . Calls program~~flap_test_nargs_insufficient~2~~CallsGraph program~flap_test_nargs_insufficient~2 flap_test_nargs_insufficient str str program~flap_test_nargs_insufficient~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables cli rval error Source Code flap_test_nargs_insufficient Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). real(kind=R8P) :: rval Real value. integer(kind=I4P) :: error Error trapping flag. Source Code program flap_test_nargs_insufficient !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<### Usage !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). real ( R8P ) :: rval !< Real value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'test_value_missing' , description = 'Test missing value' ) call cli % add ( switch = '-i' , help = 'Real input' , required = . true ., act = 'store' , error = error ) call cli % get ( switch = '-i' , val = rval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Real input = ' // trim ( str ( n = rval )) endprogram flap_test_nargs_insufficient","tags":"","loc":"program/flap_test_nargs_insufficient~2.html"},{"title":"flap_save_usage_to_markdown – FLAP","text":"Uses penf flap program~~flap_save_usage_to_markdown~~UsesGraph program~flap_save_usage_to_markdown flap_save_usage_to_markdown penf penf program~flap_save_usage_to_markdown->penf module~flap flap program~flap_save_usage_to_markdown->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Test save_usage_to_markdown method. Contents Variables cli md i r Source Code flap_save_usage_to_markdown Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: md Markdown file name. integer(kind=I4P) :: i Integer input. real(kind=R8P) :: r Real input. Source Code program flap_save_usage_to_markdown !< Test `save_usage_to_markdown` method. use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: md !< Markdown file name. integer ( I4P ) :: i !< Integer input. real ( R8P ) :: r !< Real input. call cli % init ( progname = 'flap_save_usage_to_markdown' , & version = '1.1.2' , & authors = 'Batman and Robin' , & license = 'GPL v3' , & description = 'FLAP test save man page' , & examples = [ 'flap_save_usage_to_markdown                       ' , & 'flap_save_usage_to_markdown -m test.md -i 4       ' , & 'flap_save_usage_to_markdown 3.2 -m test.md        ' , & 'flap_save_usage_to_markdown -1.5 -m test.md -i 102' ]) call cli % add ( switch = '--md' , switch_ab = '-m' , help = 'markdown file name' , required = . false ., act = 'store' , def = 'test.md' ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'a integer' , required = . false ., act = 'store' , def = '2' ) call cli % add ( positional = . true ., position = 1 , help = 'a positional real' , required = . false ., def = '1.0' ) call cli % get ( switch = '-m' , val = md ) call cli % save_usage_to_markdown ( markdown_file = trim ( md )) endprogram flap_save_usage_to_markdown","tags":"","loc":"program/flap_save_usage_to_markdown.html"},{"title":"flap_save_man_page – FLAP","text":"Uses penf flap program~~flap_save_man_page~~UsesGraph program~flap_save_man_page flap_save_man_page penf penf program~flap_save_man_page->penf module~flap flap program~flap_save_man_page->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Test save_man_page method. Contents Variables cli man i r Source Code flap_save_man_page Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: man Man page file name. integer(kind=I4P) :: i Integer input. real(kind=R8P) :: r Real input. Source Code program flap_save_man_page !< Test `save_man_page` method. use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: man !< Man page file name. integer ( I4P ) :: i !< Integer input. real ( R8P ) :: r !< Real input. call cli % init ( progname = 'flap_save_man_page' , & version = '1.1.2' , & authors = 'Batman and Robin' , & license = 'GPL v3' , & description = 'FLAP test save man page' , & examples = [ 'flap_save_man_page                        ' , & 'flap_save_man_page -m test.man -i 4       ' , & 'flap_save_man_page 3.2 -m test.man        ' , & 'flap_save_man_page -1.5 -m test.man -i 102' ]) call cli % add ( switch = '--man' , switch_ab = '-m' , help = 'man page file name' , required = . false ., act = 'store' , def = 'test.man' ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'a integer' , required = . false ., act = 'store' , def = '2' ) call cli % add ( positional = . true ., position = 1 , help = 'a positional real' , required = . false ., def = '1.0' ) call cli % get ( switch = '-m' , val = man ) call cli % save_man_page ( man_file = trim ( man )) endprogram flap_save_man_page","tags":"","loc":"program/flap_save_man_page.html"},{"title":"flap_save_bash_completion – FLAP","text":"Uses penf flap program~~flap_save_bash_completion~~UsesGraph program~flap_save_bash_completion flap_save_bash_completion penf penf program~flap_save_bash_completion->penf module~flap flap program~flap_save_bash_completion->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Test save_bash_completion method. Contents Variables cli bash_file Source Code flap_save_bash_completion Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=37) :: bash_file = 'flap_test_save_bash_completion.bash' Bash script file name. Source Code program flap_save_bash_completion !< Test `save_bash_completion` method. use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 37 ) :: bash_file = 'flap_test_save_bash_completion.bash' !< Bash script file name. call cli % init ( progname = 'flap_test_save_bash_completion' ) call cli % add ( switch_ab = '-b' , required = . false ., act = 'store' , def = 'no' , choices = 'yes,no' ) call cli % add_group ( group = 'compile' , description = 'compile sources' ) call cli % add_group ( group = 'clean' , description = 'clean compiled objects' ) call cli % add ( group = 'compile' , switch = '--compiler' , switch_ab = '-c' , required = . false ., act = 'store' , def = 'gnu' ) call cli % add ( group = 'compile' , switch = '--flags' , switch_ab = '-f' , required = . false ., act = 'store' , def = '-O2' ) call cli % add ( group = 'clean' , switch = '--clean' , switch_ab = '-c' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( group = 'clean' , switch = '--clean-all' , switch_ab = '-ca' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( group = 'compile' , positional = . true ., position = 1 , required = . false ., def = '1.0' ) call cli % add ( group = 'compile' , switch = '--integer' , switch_ab = '-i' , required = . false ., act = 'store' , def = '1' , choices = '1,3,5' ) call cli % add ( group = 'compile' , switch = '--real' , required = . false ., act = 'store' , def = '1.0' , choices = '1.,2.' ) call cli % parse call cli % save_bash_completion ( bash_file = trim ( bash_file )) endprogram flap_save_bash_completion","tags":"","loc":"program/flap_save_bash_completion.html"},{"title":"flap_test_string – FLAP","text":"Uses penf flap program~~flap_test_string~~UsesGraph program~flap_test_string flap_test_string penf penf program~flap_test_string->penf module~flap flap program~flap_test_string->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~flap_test_string~~CallsGraph program~flap_test_string flap_test_string str str program~flap_test_string->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables cli sval rval prval ival ieval bval vbval ilist error l Source Code flap_test_string Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: sval String value. real(kind=R8P) :: rval Real value. real(kind=R8P) :: prval Positional real value. integer(kind=I4P) :: ival Integer value. integer(kind=I4P) :: ieval Exclusive integer value. logical :: bval Boolean value. logical :: vbval Valued-boolean value. integer(kind=I8P) :: ilist (1:3) Integer list values. integer(kind=I4P) :: error Error trapping flag. integer(kind=I4P) :: l Counter. Source Code program flap_test_string !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. ! initialize Command Line Interface call cli % init ( progname = 'test_sting' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with a fake string input' , & examples = [ \"test_sting -s 'Hello FLAP'                               \" , & \"test_sting -s 'Hello FLAP' -i -2 # printing error...     \" , & \"test_sting -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"test_sting -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"test_sting -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"test_sting 33.0 -s 'Hello FLAP' -i 5                     \" , & \"test_sting --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! set Command Line Arguments call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) ! parse Command Line Interface call cli % parse ( args = \"-s 'FAKE INVOCATION FROM STRING' --integer_list 10 -3 87\" , error = error ) if ( error /= 0 ) stop ! use Command Line Interface data to set test_string behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'test_string has been called with the following arguments values:' print '(A)' , 'String            input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real              input = ' // str ( n = rval ) print '(A)' , 'Integer           input = ' // str ( n = ival ) print '(A)' , 'Exclusive integer input = ' // str ( n = ieval ) print '(A,L1)' , 'Boolean           input = ' , bval print '(A,L1)' , 'Valued boolean    input = ' , vbval print '(A)' , 'Positional real   input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , 'Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = ilist ( l ))) enddo endprogram flap_test_string","tags":"","loc":"program/flap_test_string.html"},{"title":"flap_test_choices_logical – FLAP","text":"Uses penf flap program~~flap_test_choices_logical~~UsesGraph program~flap_test_choices_logical flap_test_choices_logical penf penf program~flap_test_choices_logical->penf module~flap flap program~flap_test_choices_logical->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Test FLAP for bad usage of choices option with logical Calls program~~flap_test_choices_logical~~CallsGraph program~flap_test_choices_logical flap_test_choices_logical str str program~flap_test_choices_logical->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables cli vbval error Source Code flap_test_choices_logical Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). logical :: vbval Valued-boolean value. integer(kind=I4P) :: error Error trapping flag. Source Code program flap_test_choices_logical !< Test FLAP for bad usage of choices option with logical use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). logical :: vbval !< Valued-boolean value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'test_choices_logical' ) call cli % add ( switch = '--boolean-value' , switch_ab = '-bv' , help = 'A help message' , & required = . false ., def = '.false.' , choices = '.True.,.False.' , act = 'store' , error = error ) call cli % parse ( error = error ) call cli % get ( switch = '-bv' , val = vbval , error = error ) print \"(A)\" , \"Error code: \" // trim ( str ( error , . true .)) endprogram flap_test_choices_logical","tags":"","loc":"program/flap_test_choices_logical.html"},{"title":"flap_test_hidden – FLAP","text":"Uses penf flap program~~flap_test_hidden~~UsesGraph program~flap_test_hidden flap_test_hidden penf penf program~flap_test_hidden->penf module~flap flap program~flap_test_hidden->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~flap_test_hidden~~CallsGraph program~flap_test_hidden flap_test_hidden str str program~flap_test_hidden->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables cli a_string g_string a_integer error Source Code flap_test_hidden Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: a_string String value. character(len=99) :: g_string Ghost string value. integer(kind=I4P) :: a_integer Integer value. integer(kind=I4P) :: error Error trapping flag. Source Code program flap_test_hidden !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: a_string !< String value. character ( 99 ) :: g_string !< Ghost string value. integer ( I4P ) :: a_integer !< Integer value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( description = 'hiddens usage FLAP example' ) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'a string' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % add ( switch = '--hidden' , switch_ab = '-hi' , help = 'ghost string' , required = . false ., def = 'gstring not passed' , & hidden = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'a integer' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = a_string , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-hi' , val = g_string , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = a_integer , error = error ) ; if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String       = ' // trim ( adjustl ( a_string )) print '(A)' , 'Ghost string = ' // trim ( adjustl ( g_string )) print '(A)' , 'Integer      = ' // trim ( adjustl ( str ( a_integer , . true .))) endprogram flap_test_hidden","tags":"","loc":"program/flap_test_hidden.html"},{"title":"flap_test_basic – FLAP","text":"Uses penf flap program~~flap_test_basic~~UsesGraph program~flap_test_basic flap_test_basic penf penf program~flap_test_basic->penf module~flap flap program~flap_test_basic->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~flap_test_basic~~CallsGraph program~flap_test_basic flap_test_basic str str program~flap_test_basic->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables cli sval rval prval ival ieval envi bval vbval ilist vlistR8P vlistR4P vlistI8P vlistI4P vlistI2P vlistI1P vlistBool vlistChar garbage error l Source Code flap_test_basic Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: sval String value. real(kind=R8P) :: rval Real value. real(kind=R8P) :: prval Positional real value. integer(kind=I4P) :: ival Integer value. integer(kind=I4P) :: ieval Exclusive integer value. integer(kind=I4P) :: envi Environment set integer value. logical :: bval Boolean value. logical :: vbval Valued-boolean value. integer(kind=I8P) :: ilist (1:3) Integer list values. real(kind=R8P), allocatable :: vlistR8P (:) Varying size real list values. real(kind=R4P), allocatable :: vlistR4P (:) Varying size real list values. integer(kind=I8P), allocatable :: vlistI8P (:) Varying size integer list values. integer(kind=I4P), allocatable :: vlistI4P (:) Varying size integer list values. integer(kind=I2P), allocatable :: vlistI2P (:) Varying size integer list values. integer(kind=I1P), allocatable :: vlistI1P (:) Varying size integer list values. logical, allocatable :: vlistBool (:) Varying size boolean list values. character(len=10), allocatable :: vlistChar (:) Varying size character list values. character(len=99), allocatable :: garbage (:) Varying size character list for trailing garbage values. integer(kind=I4P) :: error Error trapping flag. integer(kind=I4P) :: l Counter. Source Code program flap_test_basic !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. integer ( I4P ) :: envi !< Environment set integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. real ( R8P ), allocatable :: vlistR8P (:) !< Varying size real list values. real ( R4P ), allocatable :: vlistR4P (:) !< Varying size real list values. integer ( I8P ), allocatable :: vlistI8P (:) !< Varying size integer list values. integer ( I4P ), allocatable :: vlistI4P (:) !< Varying size integer list values. integer ( I2P ), allocatable :: vlistI2P (:) !< Varying size integer list values. integer ( I1P ), allocatable :: vlistI1P (:) !< Varying size integer list values. logical , allocatable :: vlistBool (:) !< Varying size boolean list values. character ( 10 ), allocatable :: vlistChar (:) !< Varying size character list values. character ( 99 ), allocatable :: garbage (:) !< Varying size character list for trailing garbage values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. ! initialize Command Line Interface call cli % init ( progname = 'test_basic' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & help = 'Usage: ' , & description = 'Toy program for testing FLAP' , & examples = [ \"test_basic -s 'Hello FLAP'                               \" , & \"test_basic -s 'Hello FLAP' -i -2 # printing error...     \" , & \"test_basic -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"test_basic -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"test_basic -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"test_basic -s 'Hello FLAP' --man_file FLAP.1             \" , & \"test_basic 33.0 -s 'Hello FLAP' -i 5                     \" , & \"test_basic --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! set Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) if ( error /= 0 ) stop call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--env' , switch_ab = '-e' , help = 'Environment input' , required = . false ., act = 'store' , def = '-1' , envvar = 'FLAP_NUM_INT' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--man_file' , help = 'Save manual into man_file' , required = . false ., act = 'store' , def = 'test_basic.1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR8P' , switch_ab = '-vlR8P' , help = 'Varying size real R8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR4P' , switch_ab = '-vlR4P' , help = 'Varying size real R4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI8P' , switch_ab = '-vlI8P' , help = 'Varying size integer I8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4 5 6 7 8' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI4P' , switch_ab = '-vlI4P' , help = 'Varying size integer I4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI2P' , switch_ab = '-vlI2P' , help = 'Varying size integer I2P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI1P' , switch_ab = '-vlI1P' , help = 'Varying size integer I1P list input' , required = . false ., act = 'store' ,& nargs = '+' , def = '1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listBool' , switch_ab = '-vlBool' , help = 'Varying size boolean list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'T F T T F' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listChar' , switch_ab = '-vlChar' , help = 'Varying size character list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'foo bar baz' , error = error ) if ( error /= 0 ) stop ! parse Command Line Interface ! this is optional: if skipped the first call to cli%get will automatically call cli%parse call cli % parse ( error = error ) if ( error /= 0 ) stop ! use Command Line Interface data to set test_basic behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-e' , val = envi , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR8P' , val = vlistR8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR4P' , val = vlistR4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI8P' , val = vlistI8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI4P' , val = vlistI4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI2P' , val = vlistI2P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI1P' , val = vlistI1P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlBool' , val = vlistBool , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlChar' , val = vlistChar , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '--' , val = garbage , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'test_basic has been called with the following arguments values:' print '(A)' , 'String              input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real                input = ' // str ( n = rval ) print '(A)' , 'Integer             input = ' // str ( n = ival ) print '(A)' , 'Exclusive   integer input = ' // str ( n = ieval ) print '(A)' , 'Environment integer input = ' // str ( n = envi ) print '(A,L1)' , 'Boolean             input = ' , bval print '(A,L1)' , 'Valued boolean      input = ' , vbval print '(A)' , 'Positional real     input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = ilist ( l ))) enddo if ( allocated ( vlistR8P )) then print '(A)' , 'Varying size real R8P list inputs:' do l = 1 , size ( vlistR8P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistR8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R8P list!' endif if ( allocated ( vlistR4P )) then print '(A)' , 'Varying size real R4P list inputs:' do l = 1 , size ( vlistR4P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistR4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R4P list!' endif if ( allocated ( vlistI8P )) then print '(A)' , 'Varying size integer I8P list inputs:' do l = 1 , size ( vlistI8P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I8P list!' endif if ( allocated ( vlistI4P )) then print '(A)' , 'Varying size integer I4P list inputs:' do l = 1 , size ( vlistI4P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I4P list!' endif if ( allocated ( vlistI2P )) then print '(A)' , 'Varying size integer I2P list inputs:' do l = 1 , size ( vlistI2P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI2P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I2P list!' endif if ( allocated ( vlistI1P )) then print '(A)' , 'Varying size integer I1P list inputs:' do l = 1 , size ( vlistI1P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI1P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I1P list!' endif if ( allocated ( vlistBool )) then print '(A)' , 'Varying size boolean list inputs:' do l = 1 , size ( vlistBool ) print '(A,L1)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' , vlistBool ( l ) enddo else print '(A)' , 'Problems occuour with varying size boolean list!' endif if ( allocated ( vlistChar )) then print '(A)' , 'Varying size character list inputs:' do l = 1 , size ( vlistChar ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // vlistChar ( l ) enddo else print '(A)' , 'Problems occuour with varying size character list!' endif if ( allocated ( garbage )) then print '(A)' , 'You have used implicit \"--\" option for collecting list of \"trailing garbage\" values that are:' do l = 1 , size ( garbage ) print '(A)' , '  Garbage(' // trim ( str ( l , . true .)) // ') = ' // garbage ( l ) enddo endif if ( cli % is_passed ( switch = '--man_file' )) then call cli % get ( switch = '--man_file' , val = sval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Saving man page' call cli % save_man_page ( error = error , man_file = trim ( adjustl ( sval ))) endif endprogram flap_test_basic","tags":"","loc":"program/flap_test_basic.html"},{"title":"flap_test_nested – FLAP","text":"Uses penf flap program~~flap_test_nested~~UsesGraph program~flap_test_nested flap_test_nested penf penf program~flap_test_nested->penf module~flap flap program~flap_test_nested->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~flap_test_nested~~CallsGraph program~flap_test_nested flap_test_nested str str program~flap_test_nested->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables cli authors_print message error Source Code flap_test_nested Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). logical :: authors_print Boolean value. character(len=500) :: message Message value. integer(kind=I4P) :: error Error trapping flag. Source Code program flap_test_nested !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). logical :: authors_print !< Boolean value. character ( 500 ) :: message !< Message value. integer ( I4P ) :: error !< Error trapping flag. authors_print = . false . ! initialize Command Line Interface call cli % init ( progname = 'test_nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' , & examples = [ 'test_nested                      ' , & 'test_nested -h                   ' , & 'test_nested init                 ' , & 'test_nested commit -m \"fix bug-1\"' , & 'test_nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) call cli % set_mutually_exclusive_groups ( group1 = 'init' , group2 = 'commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parse Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! use Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif endprogram flap_test_nested","tags":"","loc":"program/flap_test_nested.html"},{"title":"flap_test_duplicated_clas – FLAP","text":"Uses penf flap program~~flap_test_duplicated_clas~~UsesGraph program~flap_test_duplicated_clas flap_test_duplicated_clas penf penf program~flap_test_duplicated_clas->penf module~flap flap program~flap_test_duplicated_clas->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~flap_test_duplicated_clas~~CallsGraph program~flap_test_duplicated_clas flap_test_duplicated_clas str str program~flap_test_duplicated_clas->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables cli rval error Source Code flap_test_duplicated_clas Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). real(kind=R8P) :: rval Real value. integer(kind=I4P) :: error Error trapping flag. Source Code program flap_test_duplicated_clas !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). real ( R8P ) :: rval !< Real value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'test_duplicated_clas' , description = 'Test passed duplicated CLAS' ) call cli % add ( switch = '--i' , switch_ab = '-i' , help = 'input' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = rval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Input = ' // trim ( str ( n = rval )) endprogram flap_test_duplicated_clas","tags":"","loc":"program/flap_test_duplicated_clas.html"},{"title":"flap_test_ignore_unknown_clas – FLAP","text":"Uses penf flap program~~flap_test_ignore_unknown_clas~~UsesGraph program~flap_test_ignore_unknown_clas flap_test_ignore_unknown_clas penf penf program~flap_test_ignore_unknown_clas->penf module~flap flap program~flap_test_ignore_unknown_clas->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Contents Variables cli a_string error Source Code flap_test_ignore_unknown_clas Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: a_string String value. integer(kind=I4P) :: error Error trapping flag. Source Code program flap_test_ignore_unknown_clas !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface , ERROR_UNKNOWN_CLAS_IGNORED use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: a_string !< String value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( description = 'ignore unknown CLAs usage FLAP example' , ignore_unknown_clas = . true .) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'a string' , required = . true ., act = 'store' , error = error ) call cli % get ( switch = '-s' , val = a_string , error = error ) ! if (error /= ERROR_UNKNOWN_CLAS_IGNORED) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String       = ' // trim ( adjustl ( a_string )) print '(A,I5)' , 'Error code   = ' , error endprogram flap_test_ignore_unknown_clas","tags":"","loc":"program/flap_test_ignore_unknown_clas.html"},{"title":"flap_test_ansi_color_style – FLAP","text":"Uses penf flap program~~flap_test_ansi_color_style~~UsesGraph program~flap_test_ansi_color_style flap_test_ansi_color_style penf penf program~flap_test_ansi_color_style->penf module~flap flap program~flap_test_ansi_color_style->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t->penf module~flap_command_line_arguments_group_t->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_command_line_arguments_group_t->module~flap_object_t module~face face module~flap_command_line_arguments_group_t->module~face module~flap_command_line_interface_t->penf module~flap_command_line_interface_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap_command_line_argument_t module~flap_command_line_interface_t->module~flap_object_t module~flap_utils_m flap_utils_m module~flap_command_line_interface_t->module~flap_utils_m module~flap_command_line_interface_t->module~face module~flap_command_line_argument_t->penf module~flap_command_line_argument_t->module~flap_object_t module~flap_command_line_argument_t->module~flap_utils_m module~flap_command_line_argument_t->module~face module~flap_object_t->penf iso_fortran_env iso_fortran_env module~flap_object_t->iso_fortran_env module~flap_utils_m->penf module~face->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Contents Variables cli string error Source Code flap_test_ansi_color_style Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: string String value. integer(kind=I4P) :: error Error trapping flag. Source Code program flap_test_ansi_color_style !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: string !< String value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( description = 'ANSI colored-styled FLAP example' , error_color = 'red' , error_style = 'underline_on' ) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'a string' , & help_color = 'blue' , help_style = 'italics_on' , & required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % add ( switch = '--optional' , switch_ab = '-opt' , help = 'an optional string' , & help_color = 'green' , help_style = 'italics_on' , & required = . false ., act = 'store' , def = 'hello' , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = string , error = error ) ; if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following arguments:' print '(A)' , 'string = ' // trim ( adjustl ( string )) call cli % get ( switch = '-opt' , val = string , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'optional = ' // trim ( adjustl ( string )) endprogram flap_test_ansi_color_style","tags":"","loc":"program/flap_test_ansi_color_style.html"},{"title":"face_test_colors.f90 – FLAP","text":"FACE test. This file depends on sourcefile~~face_test_colors.f90~~EfferentGraph sourcefile~face_test_colors.f90 face_test_colors.f90 sourcefile~face.f90 face.F90 sourcefile~face_test_colors.f90->sourcefile~face.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs face_test_colors Source Code face_test_colors.f90 Source Code !< FACE test. program face_test_colors !< FACE test. use face implicit none print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'black' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'red' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'green' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'yellow' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'magenta' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'cyan' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'white' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'default' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'black_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'red_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'green_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'yellow_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'magenta_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'cyan_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'white_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'black' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'red' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'green' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'yellow' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'blue' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'magenta' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'cyan' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'white' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'default' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'black_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'red_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'green_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'yellow_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'blue_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'magenta_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'cyan_intense' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_bg = 'white_intense' ) endprogram face_test_colors","tags":"","loc":"sourcefile/face_test_colors.f90.html"},{"title":"face_test_ucs4.F90 – FLAP","text":"FACE test. This file depends on sourcefile~~face_test_ucs4.f90~~EfferentGraph sourcefile~face_test_ucs4.f90 face_test_ucs4.F90 sourcefile~face.f90 face.F90 sourcefile~face_test_ucs4.f90->sourcefile~face.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs face_test_ucs4 Source Code face_test_ucs4.F90 Source Code !< FACE test. program face_test_ucs4 !< FACE test. use face implicit none #ifdef UCS4_SUPPORTED character ( kind = UCS4 , len = :), allocatable :: string_1 !< A string. character ( kind = UCS4 , len = :), allocatable :: string_2 !< A string. character ( kind = UCS4 , len = :), allocatable :: string_3 !< A string. string_1 = colorize ( 'Hello' , color_fg = 'blue' ) string_2 = colorize ( UCS4_ ' ÜÇŞ4' , color_fg = 'red' ) string_3 = colorize ( ' World' , color_fg = 'blue' ) print '(A)' , string_1 // string_2 // string_3 #endif endprogram face_test_ucs4","tags":"","loc":"sourcefile/face_test_ucs4.f90.html"},{"title":"face_test_basic.f90 – FLAP","text":"FACE test. This file depends on sourcefile~~face_test_basic.f90~~EfferentGraph sourcefile~face_test_basic.f90 face_test_basic.f90 sourcefile~face.f90 face.F90 sourcefile~face_test_basic.f90->sourcefile~face.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs face_test_basic Source Code face_test_basic.f90 Source Code !< FACE test. program face_test_basic !< FACE test. use face implicit none call colors_samples call styles_samples endprogram face_test_basic","tags":"","loc":"sourcefile/face_test_basic.f90.html"},{"title":"face_test_styles.f90 – FLAP","text":"FACE test. This file depends on sourcefile~~face_test_styles.f90~~EfferentGraph sourcefile~face_test_styles.f90 face_test_styles.f90 sourcefile~face.f90 face.F90 sourcefile~face_test_styles.f90->sourcefile~face.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs face_test_styles Source Code face_test_styles.f90 Source Code !< FACE test. program face_test_styles !< FACE test. use face implicit none print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'bold_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'italics_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'underline_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'inverse_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'strikethrough_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'framed_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'encircled_on' ) print '(A)' , colorize ( 'Hello' , color_fg = 'red' ) // colorize ( ' World' , color_fg = 'blue' , style = 'overlined_on' ) endprogram face_test_styles","tags":"","loc":"sourcefile/face_test_styles.f90.html"},{"title":"face.F90 – FLAP","text":"FACE, Fortran Ansi Colors Environment. Files dependent on this one sourcefile~~face.f90~~AfferentGraph sourcefile~face.f90 face.F90 sourcefile~face_test_colors.f90 face_test_colors.f90 sourcefile~face_test_colors.f90->sourcefile~face.f90 sourcefile~face_test_basic.f90 face_test_basic.f90 sourcefile~face_test_basic.f90->sourcefile~face.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~face_test_styles.f90 face_test_styles.f90 sourcefile~face_test_styles.f90->sourcefile~face.f90 sourcefile~face_test_ucs4.f90 face_test_ucs4.F90 sourcefile~face_test_ucs4.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_test_group.f90 flap_test_group.f90 sourcefile~flap_test_group.f90->sourcefile~flap.f90 sourcefile~flap_test_string.f90 flap_test_string.f90 sourcefile~flap_test_string.f90->sourcefile~flap.f90 sourcefile~flap_test_hidden.f90 flap_test_hidden.f90 sourcefile~flap_test_hidden.f90->sourcefile~flap.f90 sourcefile~flap_test_ansi_color_style.f90 flap_test_ansi_color_style.f90 sourcefile~flap_test_ansi_color_style.f90->sourcefile~flap.f90 sourcefile~flap_test_ignore_unknown_clas.f90 flap_test_ignore_unknown_clas.f90 sourcefile~flap_test_ignore_unknown_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_duplicated_clas.f90 flap_test_duplicated_clas.f90 sourcefile~flap_test_duplicated_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_nargs_insufficient.f90 flap_test_nargs_insufficient.f90 sourcefile~flap_test_nargs_insufficient.f90->sourcefile~flap.f90 sourcefile~flap_test_minimal.f90 flap_test_minimal.f90 sourcefile~flap_test_minimal.f90->sourcefile~flap.f90 sourcefile~flap_test_group_examples.f90 flap_test_group_examples.f90 sourcefile~flap_test_group_examples.f90->sourcefile~flap.f90 sourcefile~flap_test_value_missing.f90 flap_test_value_missing.f90 sourcefile~flap_test_value_missing.f90->sourcefile~flap.f90 sourcefile~flap_test_save_usage_to_markdown.f90 flap_test_save_usage_to_markdown.f90 sourcefile~flap_test_save_usage_to_markdown.f90->sourcefile~flap.f90 sourcefile~flap_test_save_man_page.f90 flap_test_save_man_page.f90 sourcefile~flap_test_save_man_page.f90->sourcefile~flap.f90 sourcefile~flap_test_save_bash_completion.f90 flap_test_save_bash_completion.f90 sourcefile~flap_test_save_bash_completion.f90->sourcefile~flap.f90 sourcefile~flap_test_choices_logical.f90 flap_test_choices_logical.f90 sourcefile~flap_test_choices_logical.f90->sourcefile~flap.f90 sourcefile~flap_test_basic.f90 flap_test_basic.f90 sourcefile~flap_test_basic.f90->sourcefile~flap.f90 sourcefile~flap_test_nested.f90 flap_test_nested.f90 sourcefile~flap_test_nested.f90->sourcefile~flap.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules face Source Code face.F90 Source Code !< FACE, Fortran Ansi Colors Environment. module face !< FACE, Fortran Ansi Colors Environment. use , intrinsic :: iso_fortran_env , only : int32 implicit none private public :: colorize public :: colors_samples public :: styles_samples public :: ASCII public :: UCS4 interface colorize #if defined ASCII_SUPPORTED && defined ASCII_NEQ_DEFAULT module procedure colorize_ascii module procedure colorize_default #else module procedure colorize_default #endif #ifdef UCS4_SUPPORTED module procedure colorize_ucs4 #endif endinterface ! kind parameters #ifdef ASCII_SUPPORTED integer , parameter :: ASCII = selected_char_kind ( 'ascii' ) !< ASCII character set kind. #else integer , parameter :: ASCII = selected_char_kind ( 'default' ) !< ASCII character set kind. #endif #ifdef UCS4_SUPPORTED integer , parameter :: UCS4 = selected_char_kind ( 'iso_10646' ) !< Unicode character set kind. #else integer , parameter :: UCS4 = selected_char_kind ( 'default' ) !< Unicode character set kind. #endif ! parameters character ( 26 ), parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( 26 ), parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. character ( 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. character ( 1 ), parameter :: ESCAPE = achar ( 27 ) !< \"\\\" character. ! codes character ( 2 ), parameter :: CODE_START = ESCAPE // '[' !< Start ansi code, \"\". character ( 1 ), parameter :: CODE_END = 'm' !< End ansi code, \"m\". character ( 4 ), parameter :: CODE_CLEAR = CODE_START // '0' // CODE_END !< Clear all styles, \"0m\". ! styles codes character ( 17 ), parameter :: STYLES ( 1 : 2 , 1 : 16 ) = reshape ([& 'BOLD_ON          ' , '1                ' , & !  Bold on. 'ITALICS_ON       ' , '3                ' , & !  Italics on. 'UNDERLINE_ON     ' , '4                ' , & !  Underline on. 'INVERSE_ON       ' , '7                ' , & !  Inverse on: reverse foreground and background colors. 'STRIKETHROUGH_ON ' , '9                ' , & !  Strikethrough on. 'BOLD_OFF         ' , '22               ' , & !  Bold off. 'ITALICS_OFF      ' , '23               ' , & !  Italics off. 'UNDERLINE_OFF    ' , '24               ' , & !  Underline off. 'INVERSE_OFF      ' , '27               ' , & !  Inverse off: reverse foreground and background colors. 'STRIKETHROUGH_OFF' , '29               ' , & !  Strikethrough off. 'FRAMED_ON        ' , '51               ' , & !  Framed on. 'ENCIRCLED_ON     ' , '52               ' , & !  Encircled on. 'OVERLINED_ON     ' , '53               ' , & !  Overlined on. 'FRAMED_OFF       ' , '54               ' , & !  Framed off. 'ENCIRCLED_OFF    ' , '54               ' , & !  Encircled off. 'OVERLINED_OFF    ' , '55               ' & !  Overlined off. ], [ 2 , 16 ]) !< Styles. ! colors codes character ( 15 ), parameter :: COLORS_FG ( 1 : 2 , 1 : 17 ) = reshape ([& 'BLACK          ' , '30             ' , & !  Black. 'RED            ' , '31             ' , & !  Red. 'GREEN          ' , '32             ' , & !  Green. 'YELLOW         ' , '33             ' , & !  Yellow. 'BLUE           ' , '34             ' , & !  Blue. 'MAGENTA        ' , '35             ' , & !  Magenta. 'CYAN           ' , '36             ' , & !  Cyan. 'WHITE          ' , '37             ' , & !  White. 'DEFAULT        ' , '39             ' , & !  Default (white). 'BLACK_INTENSE  ' , '90             ' , & !  Black intense. 'RED_INTENSE    ' , '91             ' , & !  Red intense. 'GREEN_INTENSE  ' , '92             ' , & !  Green intense. 'YELLOW_INTENSE ' , '93             ' , & !  Yellow intense. 'BLUE_INTENSE   ' , '94             ' , & !  Blue intense. 'MAGENTA_INTENSE' , '95             ' , & !  Magenta intense. 'CYAN_INTENSE   ' , '96             ' , & !  Cyan intense. 'WHITE_INTENSE  ' , '97             ' & !  White intense. ], [ 2 , 17 ]) !< Foreground colors. character ( 15 ), parameter :: COLORS_BG ( 1 : 2 , 1 : 17 ) = reshape ([& 'BLACK          ' , '40             ' , & !  Black. 'RED            ' , '41             ' , & !  Red. 'GREEN          ' , '42             ' , & !  Green. 'YELLOW         ' , '43             ' , & !  Yellow. 'BLUE           ' , '44             ' , & !  Blue. 'MAGENTA        ' , '45             ' , & !  Magenta. 'CYAN           ' , '46             ' , & !  Cyan. 'WHITE          ' , '47             ' , & !  White. 'DEFAULT        ' , '49             ' , & !  Default (black). 'BLACK_INTENSE  ' , '100            ' , & !  Black intense. 'RED_INTENSE    ' , '101            ' , & !  Red intense. 'GREEN_INTENSE  ' , '102            ' , & !  Green intense. 'YELLOW_INTENSE ' , '103            ' , & !  Yellow intense. 'BLUE_INTENSE   ' , '104            ' , & !  Blue intense. 'MAGENTA_INTENSE' , '105            ' , & !  Magenta intense. 'CYAN_INTENSE   ' , '106            ' , & !  Cyan intense. 'WHITE_INTENSE  ' , '107            ' & !  White intense. ], [ 2 , 17 ]) !< Background colors. contains ! public procedures subroutine colors_samples () !< Print to standard output all colors samples. integer ( int32 ) :: c !< Counter. print '(A)' , colorize ( 'Foreground colors samples' , color_fg = 'red_intense' ) do c = 1 , size ( COLORS_FG , dim = 2 ) print '(A)' , '  colorize(\"' // COLORS_FG ( 1 , c ) // '\", color_fg=\"' // COLORS_FG ( 1 , c ) // '\") => ' // & colorize ( COLORS_FG ( 1 , c ), color_fg = COLORS_FG ( 1 , c )) // & ' code: ' // colorize ( trim ( COLORS_FG ( 2 , c )), color_fg = COLORS_FG ( 1 , c ), style = 'inverse_on' ) enddo print '(A)' , colorize ( 'Background colors samples' , color_fg = 'red_intense' ) do c = 1 , size ( COLORS_BG , dim = 2 ) print '(A)' , '  colorize(\"' // COLORS_BG ( 1 , c ) // '\", color_bg=\"' // COLORS_BG ( 1 , c ) // '\") => ' // & colorize ( COLORS_BG ( 1 , c ), color_bg = COLORS_BG ( 1 , c )) // & ' code: ' // colorize ( trim ( COLORS_BG ( 2 , c )), color_bg = COLORS_BG ( 1 , c ), style = 'inverse_on' ) enddo endsubroutine colors_samples subroutine styles_samples () !< Print to standard output all styles samples. integer ( int32 ) :: s !< Counter. print '(A)' , colorize ( 'Styles samples' , color_fg = 'red_intense' ) do s = 1 , size ( STYLES , dim = 2 ) print '(A)' , '  colorize(\"' // STYLES ( 1 , s ) // '\", style=\"' // STYLES ( 1 , s ) // '\") => ' // & colorize ( STYLES ( 1 , s ), style = STYLES ( 1 , s )) // & ' code: ' // colorize ( trim ( STYLES ( 2 , s )), color_fg = 'magenta' , style = 'inverse_on' ) enddo endsubroutine styles_samples ! private procedures pure function colorize_ascii ( string , color_fg , color_bg , style ) result ( colorized ) !< Colorize and stylize strings, ASCII kind. character ( len =* , kind = ASCII ), intent ( in ) :: string !< Input string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :, kind = ASCII ), allocatable :: colorized !< Colorized string. character ( len = :, kind = ASCII ), allocatable :: buffer !< Temporary buffer. integer ( int32 ) :: i !< Counter. colorized = string if ( present ( color_fg )) then i = color_index ( upper ( color_fg )) if ( i > 0 ) then buffer = CODE_START // trim ( COLORS_FG ( 2 , i )) // CODE_END colorized = buffer // colorized buffer = CODE_CLEAR colorized = colorized // buffer endif endif if ( present ( color_bg )) then i = color_index ( upper ( color_bg )) if ( i > 0 ) then buffer = CODE_START // trim ( COLORS_BG ( 2 , i )) // CODE_END colorized = buffer // colorized buffer = CODE_CLEAR colorized = colorized // buffer endif endif if ( present ( style )) then i = style_index ( upper ( style )) if ( i > 0 ) then buffer = CODE_START // trim ( STYLES ( 2 , i )) // CODE_END colorized = buffer // colorized buffer = CODE_CLEAR colorized = colorized // buffer endif endif endfunction colorize_ascii pure function colorize_default ( string , color_fg , color_bg , style ) result ( colorized ) !< Colorize and stylize strings, DEFAULT kind. character ( len =* ), intent ( in ) :: string !< Input string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :), allocatable :: colorized !< Colorized string. integer ( int32 ) :: i !< Counter. colorized = string if ( present ( color_fg )) then i = color_index ( upper ( color_fg )) if ( i > 0 ) colorized = CODE_START // trim ( COLORS_FG ( 2 , i )) // CODE_END // colorized // CODE_CLEAR endif if ( present ( color_bg )) then i = color_index ( upper ( color_bg )) if ( i > 0 ) colorized = CODE_START // trim ( COLORS_BG ( 2 , i )) // CODE_END // colorized // CODE_CLEAR endif if ( present ( style )) then i = style_index ( upper ( style )) if ( i > 0 ) colorized = CODE_START // trim ( STYLES ( 2 , i )) // CODE_END // colorized // CODE_CLEAR endif endfunction colorize_default pure function colorize_ucs4 ( string , color_fg , color_bg , style ) result ( colorized ) !< Colorize and stylize strings, UCS4 kind. character ( len =* , kind = UCS4 ), intent ( in ) :: string !< Input string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :, kind = UCS4 ), allocatable :: colorized !< Colorized string. character ( len = :, kind = UCS4 ), allocatable :: buffer !< Temporary buffer. integer ( int32 ) :: i !< Counter. colorized = string if ( present ( color_fg )) then i = color_index ( upper ( color_fg )) if ( i > 0 ) then buffer = CODE_START // trim ( COLORS_FG ( 2 , i )) // CODE_END colorized = buffer // colorized buffer = CODE_CLEAR colorized = colorized // buffer endif endif if ( present ( color_bg )) then i = color_index ( upper ( color_bg )) if ( i > 0 ) then buffer = CODE_START // trim ( COLORS_BG ( 2 , i )) // CODE_END colorized = buffer // colorized buffer = CODE_CLEAR colorized = colorized // buffer endif endif if ( present ( style )) then i = style_index ( upper ( style )) if ( i > 0 ) then buffer = CODE_START // trim ( STYLES ( 2 , i )) // CODE_END colorized = buffer // colorized buffer = CODE_CLEAR colorized = colorized // buffer endif endif endfunction colorize_ucs4 elemental function color_index ( color ) !< Return the array-index corresponding to the queried color. !< !< @note Because Foreground and backround colors lists share the same name, no matter what array is used to find the color index. !< Thus, the foreground array is used. character ( len =* ), intent ( in ) :: color !< Color definition. integer ( int32 ) :: color_index !< Index into the colors arrays. integer ( int32 ) :: c !< Counter. color_index = 0 do c = 1 , size ( COLORS_FG , dim = 2 ) if ( trim ( COLORS_FG ( 1 , c )) == trim ( adjustl ( color ))) then color_index = c exit endif enddo endfunction color_index elemental function style_index ( style ) !< Return the array-index corresponding to the queried style. character ( len =* ), intent ( in ) :: style !< Style definition. integer ( int32 ) :: style_index !< Index into the styles array. integer ( int32 ) :: s !< Counter. style_index = 0 do s = 1 , size ( STYLES , dim = 2 ) if ( trim ( STYLES ( 1 , s )) == trim ( adjustl ( style ))) then style_index = s exit endif enddo endfunction style_index elemental function upper ( string ) !< Return a string with all uppercase characters. character ( len =* ), intent ( in ) :: string !< Input string. character ( len = len ( string )) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. upper = string do n1 = 1 , len ( string ) n2 = index ( LOWER_ALPHABET , string ( n1 : n1 )) if ( n2 > 0 ) upper ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endfunction upper endmodule face","tags":"","loc":"sourcefile/face.f90.html"},{"title":"test_tester_03.f90 – FLAP","text":"This file depends on sourcefile~~test_tester_03.f90~~EfferentGraph sourcefile~test_tester_03.f90 test_tester_03.f90 sourcefile~tester.f90 tester.f90 sourcefile~test_tester_03.f90->sourcefile~tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_tester_1 Source Code test_tester_03.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 2018 Pierre de Buyl ! License: BSD program test_tester_1 use tester implicit none integer , parameter :: rk = selected_real_kind ( 15 ) complex ( kind = rk ) :: x , y complex ( kind = rk ) :: a ( 5 ), b ( 5 ) complex :: c ( 3 ), d ( 3 ) type ( tester_t ) :: test call test % init () call test % assert_equal (( 1234 , - 1234 ), ( 1234 , - 1234 )) call test % assert_close (( 1._rk , 0._rk ), ( 1._rk , 0._rk )) call test % assert_close ( cmplx ( 1. , epsilon ( 0. )), ( 1. , 0. )) x = ( 0._rk , 1._rk ) y = cmplx ( epsilon ( 0._rk ), 1._rk , kind = rk ) call test % assert_close ( x , y ) x = cmplx ( - 115 8.1181871905803291 , 77 9.0494065373754893 ) y = cmplx ( - 115 8.1181871905803291 , 77 9.0494065373754893 ) call test % assert_equal ( x , y ) c = 1 d = 1 d = d + cmplx ( 0 , epsilon ( 0. )) call test % assert_close ( c , d ) c = cmplx ( 115427 4.4026509234681726 , - 46108 7.8365501734078862 ) d = cmplx ( 115427 4.4026509234681726 , - 46108 7.8365501734078862 ) call test % assert_equal ( c , d ) a = - 10 b = - 10 call test % assert_equal ( a , b ) a = 0 b = epsilon ( 0._rk ) call test % assert_close ( a , b ) b ( 1 ) = b ( 1 ) + cmplx ( 0._rk , epsilon ( real ( b ( 1 ))), kind = rk ) call test % assert_close ( a , b ) call test % print () end program test_tester_1","tags":"","loc":"sourcefile/test_tester_03.f90.html"},{"title":"test_tester_05.f90 – FLAP","text":"This file depends on sourcefile~~test_tester_05.f90~~EfferentGraph sourcefile~test_tester_05.f90 test_tester_05.f90 sourcefile~tester.f90 tester.f90 sourcefile~test_tester_05.f90->sourcefile~tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_tester_05 Source Code test_tester_05.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 Pierre de Buyl ! License: BSD program test_tester_05 use tester implicit none integer , parameter :: i_k1 = selected_int_kind ( 3 ) type ( tester_t ) :: test call test % init () call test % assert_equal ( 8765_i_k1 , 8765_i_k1 ) call test % assert_equal ( & [ - 3261_i_k1 , - 1169_i_k1 , 2967_i_k1 , - 3736_i_k1 , 3504_i_k1 ], & [ - 3261_i_k1 , - 1169_i_k1 , 2967_i_k1 , - 3736_i_k1 , 3504_i_k1 ]) call test % assert_positive ( 1982_i_k1 ) call test % assert_positive ([ 6987_i_k1 , 0_i_k1 ]) call test % print () end program test_tester_05","tags":"","loc":"sourcefile/test_tester_05.f90.html"},{"title":"test_fail_01.f90 – FLAP","text":"This file depends on sourcefile~~test_fail_01.f90~~EfferentGraph sourcefile~test_fail_01.f90 test_fail_01.f90 sourcefile~tester.f90 tester.f90 sourcefile~test_fail_01.f90->sourcefile~tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_tester_2 Source Code test_fail_01.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 Pierre de Buyl ! License: BSD program test_tester_2 use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal ( 1 , 2 ) call test % print () end program test_tester_2","tags":"","loc":"sourcefile/test_fail_01.f90.html"},{"title":"test_tester_02.f90 – FLAP","text":"This file depends on sourcefile~~test_tester_02.f90~~EfferentGraph sourcefile~test_tester_02.f90 test_tester_02.f90 sourcefile~tester.f90 tester.f90 sourcefile~test_tester_02.f90->sourcefile~tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_tester_3 Source Code test_tester_02.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 Pierre de Buyl ! License: BSD program test_tester_3 use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal ([. false ., . true .], [ 1 > 2 , 2 > 1 ]) call test % print () end program test_tester_3","tags":"","loc":"sourcefile/test_tester_02.f90.html"},{"title":"test_tester_01.f90 – FLAP","text":"This file depends on sourcefile~~test_tester_01.f90~~EfferentGraph sourcefile~test_tester_01.f90 test_tester_01.f90 sourcefile~tester.f90 tester.f90 sourcefile~test_tester_01.f90->sourcefile~tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_tester_1 Source Code test_tester_01.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 Pierre de Buyl ! License: BSD program test_tester_1 use tester implicit none integer , parameter :: long_k = selected_int_kind ( 18 ) double precision :: pi = 4 * atan ( 1.d0 ) type ( tester_t ) :: test call test % init () call test % assert_equal ( - 121 , - 11 ** 2 ) call test % assert_equal ([ 1 , - 10 , 1899010 ], [ 1 , - 10 , 1899010 ]) call test % assert_equal ([ 0.2420243742417814d0 , 0.4924788296716989d0 , & 0.8541147722227219d0 , 0.267520651034313d0 , 0.6948550035165076d0 ], & [ 0.2420243742417814d0 , 0.4924788296716989d0 , & 0.8541147722227219d0 , 0.267520651034313d0 , 0.6948550035165076d0 ]) call test % assert_close ( 0.d0 , sin ( pi )) call test % assert_equal ( 0.d0 , 0 * 1.d0 ) call test % assert_equal (. true ., 2 > 1 ) call test % assert_equal ( 1.0 , 1.0 ) call test % assert_equal ( & [ 7.2936402920067644 , 3.0975232096437191 , 9.2077205929200456 , & 9.0014871205366358 ], & [ 7.2936402920067644 , 3.0975232096437191 , 9.2077205929200456 , & 9.0014871205366358 ]) call test % assert_close ( 1.d0 , ( 1.d0 + 1.d-16 )) call test % assert_close ( 1. , ( 1. + 1.e-7 )) call test % assert_close ([ 0.58557761 , 0.04035789 , 0.30463428 , & 0.57437861 , 0.4879709 , 0.00986957 ], & [ 0.58557761 + epsilon ( 1.0 ), 0.04035789 , 0.30463428 + 2 * epsilon ( 1.0 ), & 0.57437861 , 0.4879709 , 0.00986957 - epsilon ( 1.0 )]) call test % assert_close ([ 1.d0 , 2.d0 ], [ 1.d0 , 2.d0 ]) call test % assert_positive ( epsilon ( 1. )) call test % assert_positive ( 0.1 ) call test % assert_positive ( 0.1d0 ) call test % assert_positive ([ 1. , 2. , 0. ]) call test % assert_positive ([ 1.d0 , huge ( 1.d0 )]) call test % assert_equal ( 1 , 1 ) call test % assert_equal ( 1_long_k , 1_long_k ) call test % assert_equal ([ 1 , - huge ( 1 ), huge ( 1 ), 0 ], [ 1 , - huge ( 1 ), huge ( 1 ), 0 ]) call test % assert_equal ([ 1_long_k , - huge ( 1_long_k ), huge ( 1_long_k ), 0_long_k ], & [ 1_long_k , - huge ( 1_long_k ), huge ( 1_long_k ), 0_long_k ]) call test % assert_positive ( 2 ** 30 ) call test % assert_positive ( 2_long_k ** 62 ) call test % assert_positive ([ 2 ** 30 , 1 , 0 ]) call test % assert_positive ([ 2_long_k ** 62 , 1_long_k , 0_long_k ]) call test % print () end program test_tester_1","tags":"","loc":"sourcefile/test_tester_01.f90.html"},{"title":"test_fail_03.f90 – FLAP","text":"This file depends on sourcefile~~test_fail_03.f90~~EfferentGraph sourcefile~test_fail_03.f90 test_fail_03.f90 sourcefile~tester.f90 tester.f90 sourcefile~test_fail_03.f90->sourcefile~tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_tester_7 Source Code test_fail_03.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 Pierre de Buyl ! License: BSD program test_tester_7 use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal ([ 1 , 2 , huge ( 1 )], [ 0 , 2 , huge ( 1 )]) call test % print () end program test_tester_7","tags":"","loc":"sourcefile/test_fail_03.f90.html"},{"title":"test_fail_02.f90 – FLAP","text":"This file depends on sourcefile~~test_fail_02.f90~~EfferentGraph sourcefile~test_fail_02.f90 test_fail_02.f90 sourcefile~tester.f90 tester.f90 sourcefile~test_fail_02.f90->sourcefile~tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_tester_4 Source Code test_fail_02.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 Pierre de Buyl ! License: BSD program test_tester_4 use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal (. true ., 1 > 2 ) call test % print () end program test_tester_4","tags":"","loc":"sourcefile/test_fail_02.f90.html"},{"title":"test_fail_04.f90 – FLAP","text":"This file depends on sourcefile~~test_fail_04.f90~~EfferentGraph sourcefile~test_fail_04.f90 test_fail_04.f90 sourcefile~tester.f90 tester.f90 sourcefile~test_fail_04.f90->sourcefile~tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_tester_8 Source Code test_fail_04.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 Pierre de Buyl ! License: BSD program test_tester_8 use tester implicit none type ( tester_t ) :: test integer , parameter :: long_k = selected_int_kind ( 18 ) call test % init () call test % assert_equal ([ 1_long_k , 2_long_k , huge ( 1_long_k )], [ 0_long_k , 2_long_k , huge ( 1_long_k )]) call test % print () end program test_tester_8","tags":"","loc":"sourcefile/test_fail_04.f90.html"},{"title":"test_tester_04.f90 – FLAP","text":"This file depends on sourcefile~~test_tester_04.f90~~EfferentGraph sourcefile~test_tester_04.f90 test_tester_04.f90 sourcefile~tester.f90 tester.f90 sourcefile~test_tester_04.f90->sourcefile~tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_tester_6 Source Code test_tester_04.f90 Source Code ! This file is part of fortran_tester ! Copyright 2018 Pierre de Buyl ! License: BSD program test_tester_6 use tester implicit none integer , parameter :: rk = selected_real_kind ( 15 ) real ( kind = rk ), parameter :: pi = 4 * atan ( 1._rk ) type ( tester_t ) :: test call test % init () call test % assert_close ( sin ( 2 * pi ), 0._rk ) call test % assert_close ( sin ( 2 * 3.1415927 ), 0. ) call test % print () end program test_tester_6","tags":"","loc":"sourcefile/test_tester_04.f90.html"},{"title":"tester.f90 – FLAP","text":"Files dependent on this one sourcefile~~tester.f90~~AfferentGraph sourcefile~tester.f90 tester.f90 sourcefile~test_tester_03.f90 test_tester_03.f90 sourcefile~test_tester_03.f90->sourcefile~tester.f90 sourcefile~test_tester_04.f90 test_tester_04.f90 sourcefile~test_tester_04.f90->sourcefile~tester.f90 sourcefile~flap_test_group.f90 flap_test_group.f90 sourcefile~flap_test_group.f90->sourcefile~tester.f90 sourcefile~test_tester_01.f90 test_tester_01.f90 sourcefile~test_tester_01.f90->sourcefile~tester.f90 sourcefile~test_fail_03.f90 test_fail_03.f90 sourcefile~test_fail_03.f90->sourcefile~tester.f90 sourcefile~test_tester_02.f90 test_tester_02.f90 sourcefile~test_tester_02.f90->sourcefile~tester.f90 sourcefile~test_tester_05.f90 test_tester_05.f90 sourcefile~test_tester_05.f90->sourcefile~tester.f90 sourcefile~test_fail_01.f90 test_fail_01.f90 sourcefile~test_fail_01.f90->sourcefile~tester.f90 sourcefile~test_fail_02.f90 test_fail_02.f90 sourcefile~test_fail_02.f90->sourcefile~tester.f90 sourcefile~test_fail_04.f90 test_fail_04.f90 sourcefile~test_fail_04.f90->sourcefile~tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules tester Source Code tester.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015-2020 Pierre de Buyl and contributors ! License: BSD !> Routines to test Fortran programs !! !! fortran_tester is a pure-Fortran module. It provides a datatype to hold test results and !! routines to test for equality, closeness, and positivity of variables. The routines are !! overloaded and the resulting interface consists of a small number of names. module tester use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 implicit none private public :: tester_t !> The main **tester** class. type :: tester_t integer ( int32 ) :: n_errors = 0_int32 !< Number of errors. integer ( int32 ) :: n_tests = 0_int32 !< Number of tests. real ( real32 ) :: tolerance32 = 2._real32 * epsilon ( 1._real32 ) !< Real tolerance, 32 bits. real ( real64 ) :: tolerance64 = 2._real64 * epsilon ( 1._real64 ) !< Real tolerance, 64 bits. contains procedure :: init !< Initialize the tester. procedure :: print !< Print tests results. generic , public :: assert_equal => & assert_equal_i8 , & assert_equal_i16 , & assert_equal_i32 , & assert_equal_i64 , & assert_equal_r32 , & assert_equal_r64 , & assert_equal_c32 , & assert_equal_c64 , & assert_equal_l , & assert_equal_i8_1 , & assert_equal_i16_1 , & assert_equal_i32_1 , & assert_equal_i64_1 , & assert_equal_r32_1 , & assert_equal_r64_1 , & assert_equal_c32_1 , & assert_equal_c64_1 , & assert_equal_l_1 !< Check if two values (integer, real, complex or logical) are equal. procedure , private :: assert_equal_i8 !< Check if two integers (8  bits) are equal. procedure , private :: assert_equal_i16 !< Check if two integers (16 bits) are equal. procedure , private :: assert_equal_i32 !< Check if two integers (32 bits) are equal. procedure , private :: assert_equal_i64 !< Check if two integers (64 bits) are equal. procedure , private :: assert_equal_r32 !< Check if two reals (32 bits) are equal. procedure , private :: assert_equal_r64 !< Check if two reals (64 bits) are equal. procedure , private :: assert_equal_c32 !< Check if two complex numbers (32 bits) are equal. procedure , private :: assert_equal_c64 !< Check if two complex numbers (64 bits) are equal. procedure , private :: assert_equal_l !< Check if two logicals are equal. procedure , private :: assert_equal_i8_1 !< Check if two integer (8  bits) arrays (rank 1) are equal. procedure , private :: assert_equal_i16_1 !< Check if two integer (16 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_i32_1 !< Check if two integer (32 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_i64_1 !< Check if two integer (64 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_r32_1 !< Check if two real (32 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_r64_1 !< Check if two real (64 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_c32_1 !< Check if two complex (32 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_c64_1 !< Check if two complex (64 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_l_1 !< Check if two logical arrays (rank 1) are equal. generic , public :: assert_positive => & assert_positive_i8 , & assert_positive_i16 , & assert_positive_i32 , & assert_positive_i64 , & assert_positive_r32 , & assert_positive_r64 , & assert_positive_i8_1 , & assert_positive_i16_1 , & assert_positive_i32_1 , & assert_positive_i64_1 , & assert_positive_r32_1 , & assert_positive_r64_1 !< Check if a number (integer or real) is positive. procedure , private :: assert_positive_i8 !< Check if a integer (8  bits) is positive. procedure , private :: assert_positive_i16 !< Check if a integer (16 bits) is positive. procedure , private :: assert_positive_i32 !< Check if a integer (32 bits) is positive. procedure , private :: assert_positive_i64 !< Check if a integer (64 bits) is positive. procedure , private :: assert_positive_r32 !< Check if a real (32 bits) is positive. procedure , private :: assert_positive_r64 !< Check if a real (64 bits) is positive. procedure , private :: assert_positive_i8_1 !< Check if a integer (8  bits) array (rank 1) is positive. procedure , private :: assert_positive_i16_1 !< Check if a integer (16 bits) array (rank 1) is positive. procedure , private :: assert_positive_i32_1 !< Check if a integer (32 bits) array (rank 1) is positive. procedure , private :: assert_positive_i64_1 !< Check if a integer (64 bits) array (rank 1) is positive. procedure , private :: assert_positive_r32_1 !< Check if a real (32 bits) array (rank 1) is positive. procedure , private :: assert_positive_r64_1 !< Check if a real (64 bits) array (rank 1) is positive. generic , public :: assert_close => & assert_close_r32 , & assert_close_r64 , & assert_close_c32 , & assert_close_c64 , & assert_close_r32_1 , & assert_close_r64_1 , & assert_close_c32_1 , & assert_close_c64_1 !< Check if two values (real or complex) are close with respect a tolerance. procedure , private :: assert_close_r32 !< Check if two reals (32 bits) are close with respect a tolerance. procedure , private :: assert_close_r64 !< Check if two reals (64 bits) are close with respect a tolerance. procedure , private :: assert_close_c32 !< Check if two complex numbers (32 bits) are close with respect a tolerance. procedure , private :: assert_close_c64 !< Check if two complex numbers (64 bits) are close with respect a tolerance. procedure , private :: assert_close_r32_1 !< Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. procedure , private :: assert_close_r64_1 !< Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. procedure , private :: assert_close_c32_1 !< Check if two complex (32 bits) arrays (rank 1) are close with respect a tolerance. procedure , private :: assert_close_c64_1 !< Check if two complex (64 bits) arrays (rank 1) are close with respect a tolerance. end type tester_t contains !> Initialize the tester. subroutine init ( this , tolerance32 , tolerance64 ) class ( tester_t ), intent ( out ) :: this !< The tester. real ( real32 ), intent ( in ), optional :: tolerance32 !< Real tolerance, 32 bits. real ( real64 ), intent ( in ), optional :: tolerance64 !< Real tolerance, 64 bits. this % n_errors = 0 this % n_tests = 0 if ( present ( tolerance64 )) then this % tolerance64 = tolerance64 else this % tolerance64 = 2._real64 * epsilon ( 1._real64 ) end if if ( present ( tolerance32 )) then this % tolerance32 = tolerance32 else this % tolerance32 = 2._real32 * epsilon ( 1._real32 ) end if end subroutine init !> Print tests results. subroutine print ( this , errorstop ) class ( tester_t ), intent ( in ) :: this !< The tester. logical , intent ( in ), optional :: errorstop !< Flag to activate error stop if one test fails. logical :: do_errorstop if ( present ( errorstop )) then do_errorstop = errorstop else do_errorstop = . true . end if write ( * , * ) 'fortran_tester:' , this % n_errors , ' error(s) for' , this % n_tests , 'test(s)' if ( this % n_errors == 0 ) then write ( * , * ) 'fortran_tester: all tests succeeded' else write ( * , * ) 'fortran_tester: tests failed' if ( do_errorstop ) then stop 1 end if end if end subroutine print !> Check if two integers (8 bits) are equal. subroutine assert_equal_i8 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), intent ( in ) :: i1 !< Value to compare. integer ( int8 ), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_i8 !> Check if two integers (16 bits) are equal. subroutine assert_equal_i16 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), intent ( in ) :: i1 !< Value to compare. integer ( int16 ), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_i16 !> Check if two integers (32 bits) are equal. subroutine assert_equal_i32 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), intent ( in ) :: i1 !< Value to compare. integer ( int32 ), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_i32 !> Check if two integers (64 bits) are equal. subroutine assert_equal_i64 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), intent ( in ) :: i1 !< Value to compare. integer ( int64 ), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_i64 !> Check if two reals (32 bits) are equal. subroutine assert_equal_r32 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ) :: r1 !< Value to compare. real ( real32 ), intent ( in ) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( r1 . ne . r2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_r32 !> Check if two reals (64 bits) are equal. subroutine assert_equal_r64 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ) :: r1 !< Value to compare. real ( real64 ), intent ( in ) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( r1 . ne . r2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_r64 !> Check if two complex numbers (32 bits) are equal. subroutine assert_equal_c32 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real32 ), intent ( in ) :: c1 !< Value to compare. complex ( real32 ), intent ( in ) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( c1 . ne . c2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_c32 !> Check if two complex numbers (64 bits) are equal. subroutine assert_equal_c64 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real64 ), intent ( in ) :: c1 !< Value to compare. complex ( real64 ), intent ( in ) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( c1 . ne . c2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_c64 !> Check if two logicals are equal. subroutine assert_equal_l ( this , l1 , l2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. logical , intent ( in ) :: l1 !< Value to compare. logical , intent ( in ) :: l2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( l1 . neqv . l2 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_equal_l !> Check if two integer (8 bits) arrays (rank 1) are equal. subroutine assert_equal_i8_1 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), dimension (:), intent ( in ) :: i1 !< Value to compare. integer ( int8 ), dimension (:), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( i1 - i2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i8_1 !> Check if two integer (16 bits) arrays (rank 1) are equal. subroutine assert_equal_i16_1 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), dimension (:), intent ( in ) :: i1 !< Value to compare. integer ( int16 ), dimension (:), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( i1 - i2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i16_1 !> Check if two integer (32 bits) arrays (rank 1) are equal. subroutine assert_equal_i32_1 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), dimension (:), intent ( in ) :: i1 !< Value to compare. integer ( int32 ), dimension (:), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( i1 - i2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i32_1 !> Check if two integer (64 bits) arrays (rank 1) are equal. subroutine assert_equal_i64_1 ( this , i1 , i2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), dimension (:), intent ( in ) :: i1 !< Value to compare. integer ( int64 ), dimension (:), intent ( in ) :: i2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( i1 - i2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i64_1 !> Check if two real (32 bits) arrays (rank 1) are equal. subroutine assert_equal_r32_1 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), dimension (:), intent ( in ) :: r1 !< Value to compare. real ( real32 ), dimension (:), intent ( in ) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( r1 - r2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_r32_1 !> Check if two real (64 bits) arrays (rank 1) are equal. subroutine assert_equal_r64_1 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), dimension (:), intent ( in ) :: r1 !< Value to compare. real ( real64 ), dimension (:), intent ( in ) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( r1 - r2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_r64_1 !> Check if two complex (32 bits) arrays (rank 1) are equal. subroutine assert_equal_c32_1 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real32 ), dimension (:), intent ( in ) :: c1 !< Value to compare. complex ( real32 ), dimension (:), intent ( in ) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( c1 ) . ne . size ( c2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( c1 - c2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_c32_1 !> Check if two complex (64 bits) arrays (rank 1) are equal. subroutine assert_equal_c64_1 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real64 ), dimension (:), intent ( in ) :: c1 !< Value to compare. complex ( real64 ), dimension (:), intent ( in ) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( c1 ) . ne . size ( c2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( c1 - c2 )) > 0 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_c64_1 !> Check if two logical arrays (rank 1) are equal. subroutine assert_equal_l_1 ( this , l1 , l2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. logical , intent ( in ), dimension (:) :: l1 !< Value to compare. logical , intent ( in ), dimension (:) :: l2 !< Value to compare. integer :: k this % n_tests = this % n_tests + 1 if ( size ( l1 ) . ne . size ( l2 ) ) then this % n_errors = this % n_errors + 1 else do k = 1 , size ( l1 ) if ( l1 ( k ) . neqv . l2 ( k )) then this % n_errors = this % n_errors + 1 exit end if end do end if end subroutine assert_equal_l_1 !> Check if a integer (32 bits) is positive. subroutine assert_positive_i8 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( i < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i8 !> Check if a integer (16 bits) is positive. subroutine assert_positive_i16 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( i < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i16 !> Check if a integer (32 bits) is positive. subroutine assert_positive_i32 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( i < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i32 !> Check if a integer (32 bits) is positive. subroutine assert_positive_i64 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( i < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i64 !> Check if a real (32 bits) is positive. subroutine assert_positive_r32 ( this , r ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ) :: r !< Value to check. this % n_tests = this % n_tests + 1 if ( r < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_r32 !> Check if a real (64 bits) is positive. subroutine assert_positive_r64 ( this , r ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ) :: r !< Value to check. this % n_tests = this % n_tests + 1 if ( r < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_r64 !> Check if a integer (8 bits) array (rank 1) is positive. subroutine assert_positive_i8_1 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), dimension (:), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i8_1 !> Check if a integer (16 bits) array (rank 1) is positive. subroutine assert_positive_i16_1 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), dimension (:), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i16_1 !> Check if a integer (32 bits) array (rank 1) is positive. subroutine assert_positive_i32_1 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), dimension (:), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i32_1 !> Check if a integer (64 bits) array (rank 1) is positive. subroutine assert_positive_i64_1 ( this , i ) class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), dimension (:), intent ( in ) :: i !< Value to check. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_i64_1 !> Check if a real (32 bits) array (rank 1) is positive. subroutine assert_positive_r32_1 ( this , r ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), dimension (:), intent ( in ) :: r !< Value to check. this % n_tests = this % n_tests + 1 if ( minval ( r ) < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_r32_1 !> Check if a real (64 bits) array (rank 1) is positive. subroutine assert_positive_r64_1 ( this , r ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), dimension (:), intent ( in ) :: r !< Value to check. this % n_tests = this % n_tests + 1 if ( minval ( r ) < 0 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_positive_r64_1 !> Check if two reals (32 bits) are close with respect a tolerance. subroutine assert_close_r32 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ) :: r1 !< Value to compare. real ( real32 ), intent ( in ) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( abs ( r1 - r2 ) > this % tolerance32 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_close_r32 !> Check if two reals (64 bits) are close with respect a tolerance. subroutine assert_close_r64 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ) :: r1 !< Value to compare. real ( real64 ), intent ( in ) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( abs ( r1 - r2 ) > this % tolerance64 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_close_r64 !> Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. subroutine assert_close_r32_1 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ), dimension (:) :: r1 !< Value to compare. real ( real32 ), intent ( in ), dimension (:) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( r1 - r2 )) > this % tolerance32 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_close_r32_1 !> Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. subroutine assert_close_r64_1 ( this , r1 , r2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ), dimension (:) :: r1 !< Value to compare. real ( real64 ), intent ( in ), dimension (:) :: r2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( r1 - r2 )) > this % tolerance64 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_close_r64_1 !> Check if two complex numbers (32 bits) are close with respect a tolerance. subroutine assert_close_c32 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real32 ), intent ( in ) :: c1 !< Value to compare. complex ( real32 ), intent ( in ) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( abs ( c1 - c2 ) > this % tolerance32 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_close_c32 !> Check if two complex numbers (64 bits) are close with respect a tolerance. subroutine assert_close_c64 ( this , r1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real64 ), intent ( in ) :: r1 !< Value to compare. complex ( real64 ), intent ( in ) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( abs ( r1 - c2 ) > this % tolerance64 ) then this % n_errors = this % n_errors + 1 end if end subroutine assert_close_c64 !> Check if two complex (32 bits) arrays (rank 1) are close with respect a tolerance. subroutine assert_close_c32_1 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real32 ), intent ( in ), dimension (:) :: c1 !< Value to compare. complex ( real32 ), intent ( in ), dimension (:) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( c1 ) . ne . size ( c2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( c1 - c2 )) > this % tolerance32 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_close_c32_1 !> Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. subroutine assert_close_c64_1 ( this , c1 , c2 ) class ( tester_t ), intent ( inout ) :: this !< The tester. complex ( real64 ), intent ( in ), dimension (:) :: c1 !< Value to compare. complex ( real64 ), intent ( in ), dimension (:) :: c2 !< Value to compare. this % n_tests = this % n_tests + 1 if ( size ( c1 ) . ne . size ( c2 ) ) then this % n_errors = this % n_errors + 1 else if ( maxval ( abs ( c1 - c2 )) > this % tolerance64 ) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_close_c64_1 end module tester","tags":"","loc":"sourcefile/tester.f90.html"},{"title":"flap_test_nargs_insufficient.f90 – FLAP","text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap_test_nargs_insufficient.f90~~EfferentGraph sourcefile~flap_test_nargs_insufficient.f90 flap_test_nargs_insufficient.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_nargs_insufficient.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_nargs_insufficient Source Code flap_test_nargs_insufficient.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program flap_test_nargs_insufficient !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<### Usage !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). real ( R8P ) :: rval ( 3 ) !< Real value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'test_nargs_insufficient' , description = 'Test insufficient nargs' ) call cli % add ( switch = '-i' , help = 'Real list input' , required = . true ., act = 'store' , nargs = '3' , error = error ) call cli % get ( switch = '-i' , val = rval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Real list input = ' // trim ( str ( n = rval )) endprogram flap_test_nargs_insufficient","tags":"","loc":"sourcefile/flap_test_nargs_insufficient.f90.html"},{"title":"flap_test_group_examples.f90 – FLAP","text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap_test_group_examples.f90~~EfferentGraph sourcefile~flap_test_group_examples.f90 flap_test_group_examples.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_group_examples.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_group_examples Source Code flap_test_group_examples.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program flap_test_group_examples !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: a_string !< String value. integer ( I4P ) :: int_value !< Integer value. real ( R4P ) :: f_value !< Float value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( description = 'group examples usage FLAP example' , & examples = [ \"flap_test_group_examples -s 'test string'      \" , & \"flap_test_group_examples --string 'test string'\" ]) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . false ., act = 'store' , def = 'test' , error = error ) call cli % add_group ( group = 'gwe' , description = 'Group with examples' , & examples = [ \"flap_test_group_examples gwe --integer 32\" , & \"flap_test_group_examples gwe -i 12       \" ]) call cli % add ( group = \"gwe\" , & switch = '--integer' , switch_ab = '-i' , help = 'Integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) call cli % add_group ( group = 'gne' , description = 'Group without examples' ) call cli % add ( group = 'gne' , & switch = '--float' , switch_ab = '-f' , help = 'Float input' , required = . false ., act = 'store' , def = '-1.0' , error = error ) print '(A)' , cli % progname // ' has been called with the following arguments:' call cli % get ( switch = '-s' , val = a_string , error = error ) print '(A)' , 'String       = ' // trim ( adjustl ( a_string )) if ( cli % run_command ( 'gwe' )) then call cli % get ( group = 'gwe' , switch = '-i' , val = int_value , error = error ) print '(A)' , 'Integer      = ' // trim ( str ( int_value )) endif if ( cli % run_command ( 'gne' )) then call cli % get ( group = 'gne' , switch = '-f' , val = f_value , error = error ) print '(A)' , 'Float        = ' // trim ( str ( f_value )) endif print '(A,I0)' , 'Error code   = ' , error endprogram flap_test_group_examples","tags":"","loc":"sourcefile/flap_test_group_examples.f90.html"},{"title":"flap_test_group.f90 – FLAP","text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap_test_group.f90~~EfferentGraph sourcefile~flap_test_group.f90 flap_test_group.f90 sourcefile~tester.f90 tester.f90 sourcefile~flap_test_group.f90->sourcefile~tester.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_group.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_group Source Code flap_test_group.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program flap_test_group !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf use tester implicit none type ( tester_t ) :: crash_test_dummy !< Tests handler. logical :: switch_value_domain !< Switch sentinel. logical :: switch_value_grid !< Switch sentinel. logical :: switch_value_spectrum !< Switch sentinel. call crash_test_dummy % init call fake_call ( args = '' , spectrum = switch_value_spectrum , domain = switch_value_domain , grid = switch_value_grid ) print * , 'test_group' print * , 'spectrum = ' , switch_value_spectrum print * , 'domain   = ' , switch_value_domain print * , 'grid     = ' , switch_value_grid call crash_test_dummy % assert_equal ( switch_value_spectrum , . false .) call crash_test_dummy % assert_equal ( switch_value_domain , . false .) call crash_test_dummy % assert_equal ( switch_value_grid , . false .) call fake_call ( args = 'new -s' , spectrum = switch_value_spectrum , domain = switch_value_domain , grid = switch_value_grid ) print * , 'test_group new -s' print * , 'spectrum = ' , switch_value_spectrum print * , 'domain   = ' , switch_value_domain print * , 'grid     = ' , switch_value_grid call crash_test_dummy % assert_equal ( switch_value_spectrum , . true .) call crash_test_dummy % assert_equal ( switch_value_domain , . false .) call crash_test_dummy % assert_equal ( switch_value_grid , . false .) call fake_call ( args = 'new -d' , spectrum = switch_value_spectrum , domain = switch_value_domain , grid = switch_value_grid ) print * , 'test_group new -d' print * , 'spectrum = ' , switch_value_spectrum print * , 'domain   = ' , switch_value_domain print * , 'grid     = ' , switch_value_grid call crash_test_dummy % assert_equal ( switch_value_spectrum , . false .) call crash_test_dummy % assert_equal ( switch_value_domain , . true .) call crash_test_dummy % assert_equal ( switch_value_grid , . false .) call fake_call ( args = 'new -g' , spectrum = switch_value_spectrum , domain = switch_value_domain , grid = switch_value_grid ) print * , 'test_group new -g' print * , 'spectrum = ' , switch_value_spectrum print * , 'domain   = ' , switch_value_domain print * , 'grid     = ' , switch_value_grid call crash_test_dummy % assert_equal ( switch_value_spectrum , . false .) call crash_test_dummy % assert_equal ( switch_value_domain , . false .) call crash_test_dummy % assert_equal ( switch_value_grid , . true .) call crash_test_dummy % print contains subroutine fake_call ( args , spectrum , domain , grid ) !--------------------------------------------------------------------------------------------------------------------------------- !< Wrapper for fake calls. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: args !< Fake arguments. logical , intent ( out ) :: spectrum !< Spectrum value. logical , intent ( out ) :: domain !< Domain value. logical , intent ( out ) :: grid !< Grid value. type ( command_line_interface ) :: cli !< Command Line Interface (CLI). integer ( I4P ) :: error !< Error trapping flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % init call cli % add_group ( group = 'new' , description = 'create new instance' ) call cli % add ( group = 'new' , switch = '--spectrum' , switch_ab = '-s' , & help = 'Create new spectrum' , required = . false ., def = '.false.' , & act = 'store_true' , error = error ) if ( error /= 0 ) stop call cli % add ( group = 'new' , switch = '--domain' , switch_ab = '-d' , & help = 'Create new domain' , required = . false ., def = '.false.' , & act = 'store_true' , error = error ) if ( error /= 0 ) stop call cli % add ( group = 'new' , switch = '--grid' , switch_ab = '-g' , & help = 'Create new grid' , required = . false ., def = '.false.' , & act = 'store_true' , error = error ) if ( error /= 0 ) stop call cli % parse ( args = args , error = error ) if ( error /= 0 ) stop call cli % get ( group = 'new' , switch = '--spectrum' , val = spectrum , error = error ) if ( error /= 0 ) stop call cli % get ( group = 'new' , switch = '--domain' , val = domain , error = error ) if ( error /= 0 ) stop call cli % get ( group = 'new' , switch = '--grid' , val = grid , error = error ) if ( error /= 0 ) stop !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine fake_call endprogram flap_test_group","tags":"","loc":"sourcefile/flap_test_group.f90.html"},{"title":"flap_test_minimal.f90 – FLAP","text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap_test_minimal.f90~~EfferentGraph sourcefile~flap_test_minimal.f90 flap_test_minimal.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_minimal.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_minimal Source Code flap_test_minimal.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program flap_test_minimal !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !< !< @note The minimal steps for using a FLAP CLI are: !<+ `init` the CLI; !<+ `add` at least one CLA to the CLI; !<+ `get` the CLAs defined into the CLI; !< !<Note that `get` automatically calls `parse` method beacuse it is not explicitely called. use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: string !< String value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( description = 'minimal FLAP example' ) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'a string' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = string , error = error ) ; if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String = ' // trim ( adjustl ( string )) endprogram flap_test_minimal","tags":"","loc":"sourcefile/flap_test_minimal.f90.html"},{"title":"flap_test_value_missing.f90 – FLAP","text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap_test_value_missing.f90~~EfferentGraph sourcefile~flap_test_value_missing.f90 flap_test_value_missing.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_value_missing.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_nargs_insufficient Source Code flap_test_value_missing.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program flap_test_nargs_insufficient !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<### Usage !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). real ( R8P ) :: rval !< Real value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'test_value_missing' , description = 'Test missing value' ) call cli % add ( switch = '-i' , help = 'Real input' , required = . true ., act = 'store' , error = error ) call cli % get ( switch = '-i' , val = rval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Real input = ' // trim ( str ( n = rval )) endprogram flap_test_nargs_insufficient","tags":"","loc":"sourcefile/flap_test_value_missing.f90.html"},{"title":"flap_test_save_usage_to_markdown.f90 – FLAP","text":"Test save_usage_to_markdown method. This file depends on sourcefile~~flap_test_save_usage_to_markdown.f90~~EfferentGraph sourcefile~flap_test_save_usage_to_markdown.f90 flap_test_save_usage_to_markdown.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_save_usage_to_markdown.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_save_usage_to_markdown Source Code flap_test_save_usage_to_markdown.f90 Source Code !< Test `save_usage_to_markdown` method. program flap_save_usage_to_markdown !< Test `save_usage_to_markdown` method. use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: md !< Markdown file name. integer ( I4P ) :: i !< Integer input. real ( R8P ) :: r !< Real input. call cli % init ( progname = 'flap_save_usage_to_markdown' , & version = '1.1.2' , & authors = 'Batman and Robin' , & license = 'GPL v3' , & description = 'FLAP test save man page' , & examples = [ 'flap_save_usage_to_markdown                       ' , & 'flap_save_usage_to_markdown -m test.md -i 4       ' , & 'flap_save_usage_to_markdown 3.2 -m test.md        ' , & 'flap_save_usage_to_markdown -1.5 -m test.md -i 102' ]) call cli % add ( switch = '--md' , switch_ab = '-m' , help = 'markdown file name' , required = . false ., act = 'store' , def = 'test.md' ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'a integer' , required = . false ., act = 'store' , def = '2' ) call cli % add ( positional = . true ., position = 1 , help = 'a positional real' , required = . false ., def = '1.0' ) call cli % get ( switch = '-m' , val = md ) call cli % save_usage_to_markdown ( markdown_file = trim ( md )) endprogram flap_save_usage_to_markdown","tags":"","loc":"sourcefile/flap_test_save_usage_to_markdown.f90.html"},{"title":"flap_test_save_man_page.f90 – FLAP","text":"Test save_man_page method. This file depends on sourcefile~~flap_test_save_man_page.f90~~EfferentGraph sourcefile~flap_test_save_man_page.f90 flap_test_save_man_page.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_save_man_page.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_save_man_page Source Code flap_test_save_man_page.f90 Source Code !< Test `save_man_page` method. program flap_save_man_page !< Test `save_man_page` method. use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: man !< Man page file name. integer ( I4P ) :: i !< Integer input. real ( R8P ) :: r !< Real input. call cli % init ( progname = 'flap_save_man_page' , & version = '1.1.2' , & authors = 'Batman and Robin' , & license = 'GPL v3' , & description = 'FLAP test save man page' , & examples = [ 'flap_save_man_page                        ' , & 'flap_save_man_page -m test.man -i 4       ' , & 'flap_save_man_page 3.2 -m test.man        ' , & 'flap_save_man_page -1.5 -m test.man -i 102' ]) call cli % add ( switch = '--man' , switch_ab = '-m' , help = 'man page file name' , required = . false ., act = 'store' , def = 'test.man' ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'a integer' , required = . false ., act = 'store' , def = '2' ) call cli % add ( positional = . true ., position = 1 , help = 'a positional real' , required = . false ., def = '1.0' ) call cli % get ( switch = '-m' , val = man ) call cli % save_man_page ( man_file = trim ( man )) endprogram flap_save_man_page","tags":"","loc":"sourcefile/flap_test_save_man_page.f90.html"},{"title":"flap_test_save_bash_completion.f90 – FLAP","text":"Test save_bash_completion method. This file depends on sourcefile~~flap_test_save_bash_completion.f90~~EfferentGraph sourcefile~flap_test_save_bash_completion.f90 flap_test_save_bash_completion.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_save_bash_completion.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_save_bash_completion Source Code flap_test_save_bash_completion.f90 Source Code !< Test `save_bash_completion` method. program flap_save_bash_completion !< Test `save_bash_completion` method. use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 37 ) :: bash_file = 'flap_test_save_bash_completion.bash' !< Bash script file name. call cli % init ( progname = 'flap_test_save_bash_completion' ) call cli % add ( switch_ab = '-b' , required = . false ., act = 'store' , def = 'no' , choices = 'yes,no' ) call cli % add_group ( group = 'compile' , description = 'compile sources' ) call cli % add_group ( group = 'clean' , description = 'clean compiled objects' ) call cli % add ( group = 'compile' , switch = '--compiler' , switch_ab = '-c' , required = . false ., act = 'store' , def = 'gnu' ) call cli % add ( group = 'compile' , switch = '--flags' , switch_ab = '-f' , required = . false ., act = 'store' , def = '-O2' ) call cli % add ( group = 'clean' , switch = '--clean' , switch_ab = '-c' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( group = 'clean' , switch = '--clean-all' , switch_ab = '-ca' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( group = 'compile' , positional = . true ., position = 1 , required = . false ., def = '1.0' ) call cli % add ( group = 'compile' , switch = '--integer' , switch_ab = '-i' , required = . false ., act = 'store' , def = '1' , choices = '1,3,5' ) call cli % add ( group = 'compile' , switch = '--real' , required = . false ., act = 'store' , def = '1.0' , choices = '1.,2.' ) call cli % parse call cli % save_bash_completion ( bash_file = trim ( bash_file )) endprogram flap_save_bash_completion","tags":"","loc":"sourcefile/flap_test_save_bash_completion.f90.html"},{"title":"flap_test_string.f90 – FLAP","text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap_test_string.f90~~EfferentGraph sourcefile~flap_test_string.f90 flap_test_string.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_string.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_string Source Code flap_test_string.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program flap_test_string !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. ! initialize Command Line Interface call cli % init ( progname = 'test_sting' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with a fake string input' , & examples = [ \"test_sting -s 'Hello FLAP'                               \" , & \"test_sting -s 'Hello FLAP' -i -2 # printing error...     \" , & \"test_sting -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"test_sting -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"test_sting -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"test_sting 33.0 -s 'Hello FLAP' -i 5                     \" , & \"test_sting --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! set Command Line Arguments call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) ! parse Command Line Interface call cli % parse ( args = \"-s 'FAKE INVOCATION FROM STRING' --integer_list 10 -3 87\" , error = error ) if ( error /= 0 ) stop ! use Command Line Interface data to set test_string behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'test_string has been called with the following arguments values:' print '(A)' , 'String            input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real              input = ' // str ( n = rval ) print '(A)' , 'Integer           input = ' // str ( n = ival ) print '(A)' , 'Exclusive integer input = ' // str ( n = ieval ) print '(A,L1)' , 'Boolean           input = ' , bval print '(A,L1)' , 'Valued boolean    input = ' , vbval print '(A)' , 'Positional real   input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , 'Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = ilist ( l ))) enddo endprogram flap_test_string","tags":"","loc":"sourcefile/flap_test_string.f90.html"},{"title":"flap_test_choices_logical.f90 – FLAP","text":"Test FLAP for bad usage of choices option with logical This file depends on sourcefile~~flap_test_choices_logical.f90~~EfferentGraph sourcefile~flap_test_choices_logical.f90 flap_test_choices_logical.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_choices_logical.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_choices_logical Source Code flap_test_choices_logical.f90 Source Code !< Test FLAP for bad usage of choices option with logical program flap_test_choices_logical !< Test FLAP for bad usage of choices option with logical use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). logical :: vbval !< Valued-boolean value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'test_choices_logical' ) call cli % add ( switch = '--boolean-value' , switch_ab = '-bv' , help = 'A help message' , & required = . false ., def = '.false.' , choices = '.True.,.False.' , act = 'store' , error = error ) call cli % parse ( error = error ) call cli % get ( switch = '-bv' , val = vbval , error = error ) print \"(A)\" , \"Error code: \" // trim ( str ( error , . true .)) endprogram flap_test_choices_logical","tags":"","loc":"sourcefile/flap_test_choices_logical.f90.html"},{"title":"flap_test_hidden.f90 – FLAP","text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap_test_hidden.f90~~EfferentGraph sourcefile~flap_test_hidden.f90 flap_test_hidden.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_hidden.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_hidden Source Code flap_test_hidden.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program flap_test_hidden !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: a_string !< String value. character ( 99 ) :: g_string !< Ghost string value. integer ( I4P ) :: a_integer !< Integer value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( description = 'hiddens usage FLAP example' ) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'a string' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % add ( switch = '--hidden' , switch_ab = '-hi' , help = 'ghost string' , required = . false ., def = 'gstring not passed' , & hidden = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'a integer' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = a_string , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-hi' , val = g_string , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = a_integer , error = error ) ; if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String       = ' // trim ( adjustl ( a_string )) print '(A)' , 'Ghost string = ' // trim ( adjustl ( g_string )) print '(A)' , 'Integer      = ' // trim ( adjustl ( str ( a_integer , . true .))) endprogram flap_test_hidden","tags":"","loc":"sourcefile/flap_test_hidden.f90.html"},{"title":"flap_test_basic.f90 – FLAP","text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap_test_basic.f90~~EfferentGraph sourcefile~flap_test_basic.f90 flap_test_basic.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_basic.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_basic Source Code flap_test_basic.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program flap_test_basic !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. integer ( I4P ) :: envi !< Environment set integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. real ( R8P ), allocatable :: vlistR8P (:) !< Varying size real list values. real ( R4P ), allocatable :: vlistR4P (:) !< Varying size real list values. integer ( I8P ), allocatable :: vlistI8P (:) !< Varying size integer list values. integer ( I4P ), allocatable :: vlistI4P (:) !< Varying size integer list values. integer ( I2P ), allocatable :: vlistI2P (:) !< Varying size integer list values. integer ( I1P ), allocatable :: vlistI1P (:) !< Varying size integer list values. logical , allocatable :: vlistBool (:) !< Varying size boolean list values. character ( 10 ), allocatable :: vlistChar (:) !< Varying size character list values. character ( 99 ), allocatable :: garbage (:) !< Varying size character list for trailing garbage values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. ! initialize Command Line Interface call cli % init ( progname = 'test_basic' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & help = 'Usage: ' , & description = 'Toy program for testing FLAP' , & examples = [ \"test_basic -s 'Hello FLAP'                               \" , & \"test_basic -s 'Hello FLAP' -i -2 # printing error...     \" , & \"test_basic -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"test_basic -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"test_basic -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"test_basic -s 'Hello FLAP' --man_file FLAP.1             \" , & \"test_basic 33.0 -s 'Hello FLAP' -i 5                     \" , & \"test_basic --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! set Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) if ( error /= 0 ) stop call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--env' , switch_ab = '-e' , help = 'Environment input' , required = . false ., act = 'store' , def = '-1' , envvar = 'FLAP_NUM_INT' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--man_file' , help = 'Save manual into man_file' , required = . false ., act = 'store' , def = 'test_basic.1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR8P' , switch_ab = '-vlR8P' , help = 'Varying size real R8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR4P' , switch_ab = '-vlR4P' , help = 'Varying size real R4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI8P' , switch_ab = '-vlI8P' , help = 'Varying size integer I8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4 5 6 7 8' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI4P' , switch_ab = '-vlI4P' , help = 'Varying size integer I4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI2P' , switch_ab = '-vlI2P' , help = 'Varying size integer I2P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI1P' , switch_ab = '-vlI1P' , help = 'Varying size integer I1P list input' , required = . false ., act = 'store' ,& nargs = '+' , def = '1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listBool' , switch_ab = '-vlBool' , help = 'Varying size boolean list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'T F T T F' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listChar' , switch_ab = '-vlChar' , help = 'Varying size character list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'foo bar baz' , error = error ) if ( error /= 0 ) stop ! parse Command Line Interface ! this is optional: if skipped the first call to cli%get will automatically call cli%parse call cli % parse ( error = error ) if ( error /= 0 ) stop ! use Command Line Interface data to set test_basic behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-e' , val = envi , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR8P' , val = vlistR8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR4P' , val = vlistR4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI8P' , val = vlistI8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI4P' , val = vlistI4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI2P' , val = vlistI2P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI1P' , val = vlistI1P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlBool' , val = vlistBool , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlChar' , val = vlistChar , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '--' , val = garbage , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'test_basic has been called with the following arguments values:' print '(A)' , 'String              input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real                input = ' // str ( n = rval ) print '(A)' , 'Integer             input = ' // str ( n = ival ) print '(A)' , 'Exclusive   integer input = ' // str ( n = ieval ) print '(A)' , 'Environment integer input = ' // str ( n = envi ) print '(A,L1)' , 'Boolean             input = ' , bval print '(A,L1)' , 'Valued boolean      input = ' , vbval print '(A)' , 'Positional real     input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = ilist ( l ))) enddo if ( allocated ( vlistR8P )) then print '(A)' , 'Varying size real R8P list inputs:' do l = 1 , size ( vlistR8P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistR8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R8P list!' endif if ( allocated ( vlistR4P )) then print '(A)' , 'Varying size real R4P list inputs:' do l = 1 , size ( vlistR4P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistR4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R4P list!' endif if ( allocated ( vlistI8P )) then print '(A)' , 'Varying size integer I8P list inputs:' do l = 1 , size ( vlistI8P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I8P list!' endif if ( allocated ( vlistI4P )) then print '(A)' , 'Varying size integer I4P list inputs:' do l = 1 , size ( vlistI4P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I4P list!' endif if ( allocated ( vlistI2P )) then print '(A)' , 'Varying size integer I2P list inputs:' do l = 1 , size ( vlistI2P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI2P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I2P list!' endif if ( allocated ( vlistI1P )) then print '(A)' , 'Varying size integer I1P list inputs:' do l = 1 , size ( vlistI1P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI1P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I1P list!' endif if ( allocated ( vlistBool )) then print '(A)' , 'Varying size boolean list inputs:' do l = 1 , size ( vlistBool ) print '(A,L1)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' , vlistBool ( l ) enddo else print '(A)' , 'Problems occuour with varying size boolean list!' endif if ( allocated ( vlistChar )) then print '(A)' , 'Varying size character list inputs:' do l = 1 , size ( vlistChar ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // vlistChar ( l ) enddo else print '(A)' , 'Problems occuour with varying size character list!' endif if ( allocated ( garbage )) then print '(A)' , 'You have used implicit \"--\" option for collecting list of \"trailing garbage\" values that are:' do l = 1 , size ( garbage ) print '(A)' , '  Garbage(' // trim ( str ( l , . true .)) // ') = ' // garbage ( l ) enddo endif if ( cli % is_passed ( switch = '--man_file' )) then call cli % get ( switch = '--man_file' , val = sval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Saving man page' call cli % save_man_page ( error = error , man_file = trim ( adjustl ( sval ))) endif endprogram flap_test_basic","tags":"","loc":"sourcefile/flap_test_basic.f90.html"},{"title":"flap_test_nested.f90 – FLAP","text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap_test_nested.f90~~EfferentGraph sourcefile~flap_test_nested.f90 flap_test_nested.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_nested.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_nested Source Code flap_test_nested.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program flap_test_nested !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). logical :: authors_print !< Boolean value. character ( 500 ) :: message !< Message value. integer ( I4P ) :: error !< Error trapping flag. authors_print = . false . ! initialize Command Line Interface call cli % init ( progname = 'test_nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' , & examples = [ 'test_nested                      ' , & 'test_nested -h                   ' , & 'test_nested init                 ' , & 'test_nested commit -m \"fix bug-1\"' , & 'test_nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) call cli % set_mutually_exclusive_groups ( group1 = 'init' , group2 = 'commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parse Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! use Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif endprogram flap_test_nested","tags":"","loc":"sourcefile/flap_test_nested.f90.html"},{"title":"flap_test_duplicated_clas.f90 – FLAP","text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap_test_duplicated_clas.f90~~EfferentGraph sourcefile~flap_test_duplicated_clas.f90 flap_test_duplicated_clas.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_duplicated_clas.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_duplicated_clas Source Code flap_test_duplicated_clas.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program flap_test_duplicated_clas !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). real ( R8P ) :: rval !< Real value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( progname = 'test_duplicated_clas' , description = 'Test passed duplicated CLAS' ) call cli % add ( switch = '--i' , switch_ab = '-i' , help = 'input' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = rval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Input = ' // trim ( str ( n = rval )) endprogram flap_test_duplicated_clas","tags":"","loc":"sourcefile/flap_test_duplicated_clas.f90.html"},{"title":"flap_test_ignore_unknown_clas.f90 – FLAP","text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap_test_ignore_unknown_clas.f90~~EfferentGraph sourcefile~flap_test_ignore_unknown_clas.f90 flap_test_ignore_unknown_clas.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_ignore_unknown_clas.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_ignore_unknown_clas Source Code flap_test_ignore_unknown_clas.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program flap_test_ignore_unknown_clas !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). use flap , only : command_line_interface , ERROR_UNKNOWN_CLAS_IGNORED use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: a_string !< String value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( description = 'ignore unknown CLAs usage FLAP example' , ignore_unknown_clas = . true .) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'a string' , required = . true ., act = 'store' , error = error ) call cli % get ( switch = '-s' , val = a_string , error = error ) ! if (error /= ERROR_UNKNOWN_CLAS_IGNORED) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String       = ' // trim ( adjustl ( a_string )) print '(A,I5)' , 'Error code   = ' , error endprogram flap_test_ignore_unknown_clas","tags":"","loc":"sourcefile/flap_test_ignore_unknown_clas.f90.html"},{"title":"flap_test_ansi_color_style.f90 – FLAP","text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap_test_ansi_color_style.f90~~EfferentGraph sourcefile~flap_test_ansi_color_style.f90 flap_test_ansi_color_style.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_test_ansi_color_style.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs flap_test_ansi_color_style Source Code flap_test_ansi_color_style.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program flap_test_ansi_color_style !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people use flap , only : command_line_interface use penf implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: string !< String value. integer ( I4P ) :: error !< Error trapping flag. call cli % init ( description = 'ANSI colored-styled FLAP example' , error_color = 'red' , error_style = 'underline_on' ) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'a string' , & help_color = 'blue' , help_style = 'italics_on' , & required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % add ( switch = '--optional' , switch_ab = '-opt' , help = 'an optional string' , & help_color = 'green' , help_style = 'italics_on' , & required = . false ., act = 'store' , def = 'hello' , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = string , error = error ) ; if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following arguments:' print '(A)' , 'string = ' // trim ( adjustl ( string )) call cli % get ( switch = '-opt' , val = string , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'optional = ' // trim ( adjustl ( string )) endprogram flap_test_ansi_color_style","tags":"","loc":"sourcefile/flap_test_ansi_color_style.f90.html"},{"title":"flap_object_t.F90 – FLAP","text":"Base (abstract) class upon which FLAP’s concrete classes are built. Files dependent on this one sourcefile~~flap_object_t.f90~~AfferentGraph sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_test_group.f90 flap_test_group.f90 sourcefile~flap_test_group.f90->sourcefile~flap.f90 sourcefile~flap_test_string.f90 flap_test_string.f90 sourcefile~flap_test_string.f90->sourcefile~flap.f90 sourcefile~flap_test_hidden.f90 flap_test_hidden.f90 sourcefile~flap_test_hidden.f90->sourcefile~flap.f90 sourcefile~flap_test_ansi_color_style.f90 flap_test_ansi_color_style.f90 sourcefile~flap_test_ansi_color_style.f90->sourcefile~flap.f90 sourcefile~flap_test_ignore_unknown_clas.f90 flap_test_ignore_unknown_clas.f90 sourcefile~flap_test_ignore_unknown_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_duplicated_clas.f90 flap_test_duplicated_clas.f90 sourcefile~flap_test_duplicated_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_nargs_insufficient.f90 flap_test_nargs_insufficient.f90 sourcefile~flap_test_nargs_insufficient.f90->sourcefile~flap.f90 sourcefile~flap_test_minimal.f90 flap_test_minimal.f90 sourcefile~flap_test_minimal.f90->sourcefile~flap.f90 sourcefile~flap_test_group_examples.f90 flap_test_group_examples.f90 sourcefile~flap_test_group_examples.f90->sourcefile~flap.f90 sourcefile~flap_test_value_missing.f90 flap_test_value_missing.f90 sourcefile~flap_test_value_missing.f90->sourcefile~flap.f90 sourcefile~flap_test_save_usage_to_markdown.f90 flap_test_save_usage_to_markdown.f90 sourcefile~flap_test_save_usage_to_markdown.f90->sourcefile~flap.f90 sourcefile~flap_test_save_man_page.f90 flap_test_save_man_page.f90 sourcefile~flap_test_save_man_page.f90->sourcefile~flap.f90 sourcefile~flap_test_save_bash_completion.f90 flap_test_save_bash_completion.f90 sourcefile~flap_test_save_bash_completion.f90->sourcefile~flap.f90 sourcefile~flap_test_choices_logical.f90 flap_test_choices_logical.f90 sourcefile~flap_test_choices_logical.f90->sourcefile~flap.f90 sourcefile~flap_test_basic.f90 flap_test_basic.f90 sourcefile~flap_test_basic.f90->sourcefile~flap.f90 sourcefile~flap_test_nested.f90 flap_test_nested.f90 sourcefile~flap_test_nested.f90->sourcefile~flap.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules flap_object_t Source Code flap_object_t.F90 Source Code !< Base (abstract) class upon which FLAP's concrete classes are built. module flap_object_t !< Base (abstract) class upon which FLAP's concrete classes are built. use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stderr => error_unit use penf implicit none private save type , abstract , public :: object !< Base (abstract) class upon which FLAP's concrete classes are built. character ( len = :), allocatable :: progname !< Program name. character ( len = :), allocatable :: version !< Program version. character ( len = :), allocatable :: help !< Help message. character ( len = :), allocatable :: help_color !< ANSI color of help messages. character ( len = :), allocatable :: help_style !< ANSI style of help messages. character ( len = :), allocatable :: help_markdown !< Longer help message, markdown formatted. character ( len = :), allocatable :: description !< Detailed description. character ( len = :), allocatable :: license !< License description. character ( len = :), allocatable :: authors !< Authors list. character ( len = :), allocatable :: epilog !< Epilogue message. character ( len = :), allocatable :: m_exclude !< Mutually exclude other CLA(s group). character ( len = :), allocatable :: error_message !< Meaningful error message to standard-error. character ( len = :), allocatable :: error_color !< ANSI color of error messages. character ( len = :), allocatable :: error_style !< ANSI style of error messages. #ifdef __GFORTRAN__ character ( 512 ), allocatable :: examples (:) !< Examples of correct usage. #else character ( len = :), allocatable :: examples (:) !< Examples of correct usage. #endif integer ( I4P ) :: error = 0_I4P !< Error trapping flag. integer ( I4P ) :: usage_lun = stderr !< Output unit to print help/usage messages integer ( I4P ) :: version_lun = stdout !< Output unit to print version message integer ( I4P ) :: error_lun = stderr !< Error unit to print error messages contains ! public methods procedure , pass ( self ) :: free_object !< Free dynamic memory. procedure , pass ( self ) :: print_version !< Print version. procedure , pass ( self ) :: print_error_message !< Print meaningful error message. procedure , pass ( self ) :: set_examples !< Set examples of correct usage. procedure , pass ( lhs ) :: assign_object !< Assignment overloading. endtype object contains ! public methods elemental subroutine free_object ( self ) !< Free dynamic memory. class ( object ), intent ( inout ) :: self !< Object data. if ( allocated ( self % progname )) deallocate ( self % progname ) if ( allocated ( self % version )) deallocate ( self % version ) if ( allocated ( self % help )) deallocate ( self % help ) if ( allocated ( self % help_color )) deallocate ( self % help_color ) if ( allocated ( self % help_style )) deallocate ( self % help_style ) if ( allocated ( self % help_markdown )) deallocate ( self % help_markdown ) if ( allocated ( self % description )) deallocate ( self % description ) if ( allocated ( self % license )) deallocate ( self % license ) if ( allocated ( self % authors )) deallocate ( self % authors ) if ( allocated ( self % epilog )) deallocate ( self % epilog ) if ( allocated ( self % m_exclude )) deallocate ( self % m_exclude ) if ( allocated ( self % error_message )) deallocate ( self % error_message ) if ( allocated ( self % error_color )) deallocate ( self % error_color ) if ( allocated ( self % error_style )) deallocate ( self % error_style ) self % error = 0_I4P self % usage_lun = stderr self % version_lun = stdout self % error_lun = stderr endsubroutine free_object subroutine print_version ( self , pref ) !< Print version. class ( object ), intent ( in ) :: self !< Object data. character ( * ), intent ( in ), optional :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. prefd = '' ; if ( present ( pref )) prefd = pref write ( self % version_lun , '(A)' ) prefd // self % progname // ' version ' // self % version if ( self % license /= '' ) then write ( self % version_lun , '(A)' ) prefd // self % license endif if ( self % authors /= '' ) then write ( self % version_lun , '(A)' ) prefd // self % authors endif endsubroutine print_version subroutine print_error_message ( self ) !< Print meaningful error message to standard-error. class ( object ), intent ( in ) :: self !< Object data. write ( self % error_lun , '(A)' ) self % error_message write ( self % error_lun , '(A)' ) endsubroutine print_error_message subroutine set_examples ( self , examples ) !< Set examples of correct usage. class ( object ), intent ( inout ) :: self !< Object data. character ( * ), optional , intent ( in ) :: examples ( 1 :) !< Examples of correct usage. if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( self % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: self % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif self % examples = examples endif endsubroutine set_examples elemental subroutine assign_object ( lhs , rhs ) !< Assign two abstract objects. class ( object ), intent ( inout ) :: lhs !< Left hand side. class ( object ), intent ( in ) :: rhs !< Rigth hand side. if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % help_color )) lhs % help_color = rhs % help_color if ( allocated ( rhs % help_style )) lhs % help_style = rhs % help_style if ( allocated ( rhs % help_markdown )) lhs % help_markdown = rhs % help_markdown if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude if ( allocated ( rhs % error_message )) lhs % error_message = rhs % error_message if ( allocated ( rhs % error_color )) lhs % error_color = rhs % error_color if ( allocated ( rhs % error_style )) lhs % error_style = rhs % error_style lhs % error = rhs % error lhs % usage_lun = rhs % usage_lun lhs % version_lun = rhs % version_lun lhs % error_lun = rhs % error_lun endsubroutine assign_object endmodule flap_object_t","tags":"","loc":"sourcefile/flap_object_t.f90.html"},{"title":"flap_command_line_arguments_group_t.f90 – FLAP","text":"Command Line Arguments Group (CLAsG) class. This file depends on sourcefile~~flap_command_line_arguments_group_t.f90~~EfferentGraph sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~flap_command_line_arguments_group_t.f90~~AfferentGraph sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_test_group.f90 flap_test_group.f90 sourcefile~flap_test_group.f90->sourcefile~flap.f90 sourcefile~flap_test_string.f90 flap_test_string.f90 sourcefile~flap_test_string.f90->sourcefile~flap.f90 sourcefile~flap_test_hidden.f90 flap_test_hidden.f90 sourcefile~flap_test_hidden.f90->sourcefile~flap.f90 sourcefile~flap_test_ansi_color_style.f90 flap_test_ansi_color_style.f90 sourcefile~flap_test_ansi_color_style.f90->sourcefile~flap.f90 sourcefile~flap_test_ignore_unknown_clas.f90 flap_test_ignore_unknown_clas.f90 sourcefile~flap_test_ignore_unknown_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_duplicated_clas.f90 flap_test_duplicated_clas.f90 sourcefile~flap_test_duplicated_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_nargs_insufficient.f90 flap_test_nargs_insufficient.f90 sourcefile~flap_test_nargs_insufficient.f90->sourcefile~flap.f90 sourcefile~flap_test_minimal.f90 flap_test_minimal.f90 sourcefile~flap_test_minimal.f90->sourcefile~flap.f90 sourcefile~flap_test_group_examples.f90 flap_test_group_examples.f90 sourcefile~flap_test_group_examples.f90->sourcefile~flap.f90 sourcefile~flap_test_value_missing.f90 flap_test_value_missing.f90 sourcefile~flap_test_value_missing.f90->sourcefile~flap.f90 sourcefile~flap_test_save_usage_to_markdown.f90 flap_test_save_usage_to_markdown.f90 sourcefile~flap_test_save_usage_to_markdown.f90->sourcefile~flap.f90 sourcefile~flap_test_save_man_page.f90 flap_test_save_man_page.f90 sourcefile~flap_test_save_man_page.f90->sourcefile~flap.f90 sourcefile~flap_test_save_bash_completion.f90 flap_test_save_bash_completion.f90 sourcefile~flap_test_save_bash_completion.f90->sourcefile~flap.f90 sourcefile~flap_test_choices_logical.f90 flap_test_choices_logical.f90 sourcefile~flap_test_choices_logical.f90->sourcefile~flap.f90 sourcefile~flap_test_basic.f90 flap_test_basic.f90 sourcefile~flap_test_basic.f90->sourcefile~flap.f90 sourcefile~flap_test_nested.f90 flap_test_nested.f90 sourcefile~flap_test_nested.f90->sourcefile~flap.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules flap_command_line_arguments_group_t Source Code flap_command_line_arguments_group_t.f90 Source Code !< Command Line Arguments Group (CLAsG) class. module flap_command_line_arguments_group_t !< Command Line Arguments Group (CLAsG) class. use face , only : colorize use flap_command_line_argument_t , only : command_line_argument , & ACTION_PRINT_HELP , & ACTION_PRINT_VERS , & ACTION_STORE , & ACTION_STORE_STAR , & ARGS_SEP use flap_object_t , only : object use penf implicit none private save public :: command_line_arguments_group public :: STATUS_PRINT_V public :: STATUS_PRINT_H type , extends ( object ) :: command_line_arguments_group !< Command Line Arguments Group (CLAsG) class. !< !< CLAsG are useful for building nested commands. private character ( len = :), allocatable , public :: group !< Group name (command). integer ( I4P ), public :: Na = 0_I4P !< Number of CLA. integer ( I4P ) :: Na_required = 0_I4P !< Number of required command line arguments. integer ( I4P ) :: Na_optional = 0_I4P !< Number of optional command line arguments. type ( command_line_argument ), allocatable , public :: cla (:) !< CLA list [1:Na]. logical , public :: is_called = . false . !< Flag for checking if CLAs group has been passed to CLI. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: check !< Check data consistency. procedure , public :: is_required_passed !< Check if required CLAs are passed. procedure , public :: is_passed !< Check if a CLA has been passed. procedure , public :: is_defined !< Check if a CLA has been defined. procedure , public :: raise_error_m_exclude !< Raise error mutually exclusive CLAs passed. procedure , public :: add !< Add CLA to CLAsG. procedure , public :: parse !< Parse CLAsG arguments. procedure , public :: usage !< Get correct CLAsG usage. procedure , public :: signature !< Get CLAsG signature. procedure , public :: sanitize_defaults !< Sanitize default values. ! private methods procedure , private :: errored !< Trig error occurrence and print meaningful message. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs have been passed. procedure , private :: clasg_assign_clasg !< Assignment operator. generic , private :: assignment ( = ) => clasg_assign_clasg !< Assignment operator overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_arguments_group ! status codes integer ( I4P ), parameter :: STATUS_PRINT_V = - 1 !< Print version status. integer ( I4P ), parameter :: STATUS_PRINT_H = - 2 !< Print help status. ! errors codes integer ( I4P ), parameter :: ERROR_CONSISTENCY = 100 !< CLAs group consistency error. integer ( I4P ), parameter :: ERROR_M_EXCLUDE = 101 !< Two mutually exclusive CLAs group have been called. contains ! public methods elemental subroutine free ( self ) !< Free dynamic memory. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. ! object members call self % free_object ! command_line_arguments_group members if ( allocated ( self % group )) deallocate ( self % group ) if ( allocated ( self % cla )) then call self % cla % free deallocate ( self % cla ) endif self % Na = 0_I4P self % Na_required = 0_I4P self % Na_optional = 0_I4P self % is_called = . false . endsubroutine free subroutine check ( self , pref ) !< Check data consistency. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. ! verify if CLAs switches are unique CLA_unique : do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then do aa = 1 , self % Na if (( a /= aa ). and .(. not . self % cla ( aa )% is_positional )) then if (( self % cla ( a )% switch == self % cla ( aa )% switch ). or .( self % cla ( a )% switch_ab == self % cla ( aa )% switch ). or .& ( self % cla ( a )% switch == self % cla ( aa )% switch_ab ). or .( self % cla ( a )% switch_ab == self % cla ( aa )% switch_ab )) then call self % errored ( pref = pref , error = ERROR_CONSISTENCY , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! update mutually exclusive relations CLA_exclude : do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if ( self % cla ( a )% m_exclude /= '' ) then if ( self % is_defined ( switch = self % cla ( a )% m_exclude , pos = aa )) then self % cla ( aa )% m_exclude = self % cla ( a )% switch endif endif endif enddo CLA_exclude endsubroutine check subroutine is_required_passed ( self , pref ) !< Check if required CLAs are passed. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. if ( self % is_called ) then do a = 1 , self % Na if (. not . self % cla ( a )% is_required_passed ( pref = pref )) then self % error = self % cla ( a )% error write ( self % usage_lun , '(A)' ) self % usage ( pref = pref ) return endif enddo endif endsubroutine is_required_passed pure function is_passed ( self , switch , position ) !< Check if a CLA has been passed. class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical :: is_passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. is_passed = . false . if ( self % Na > 0 ) then if ( present ( switch )) then do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if (( self % cla ( a )% switch == switch ). or .( self % cla ( a )% switch_ab == switch )) then is_passed = self % cla ( a )% is_passed exit endif endif enddo elseif ( present ( position )) then is_passed = self % cla ( position )% is_passed endif endif endfunction is_passed function is_defined ( self , switch , pos ) !< Check if a CLA has been defined. class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( out ) :: pos !< CLA position. logical :: is_defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. is_defined = . false . if ( present ( pos )) pos = 0 if ( self % Na > 0 ) then do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if (( self % cla ( a )% switch == switch ). or .( self % cla ( a )% switch_ab == switch )) then is_defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif endfunction is_defined subroutine raise_error_m_exclude ( self , pref ) !< Raise error mutually exclusive CLAs passed. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_M_EXCLUDE ) endsubroutine raise_error_m_exclude subroutine add ( self , pref , cla ) !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. type ( command_line_argument ), intent ( in ) :: cla !< CLA data. type ( command_line_argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. integer ( I4P ) :: c !< Counter. if ( self % Na > 0_I4P ) then if (. not . cla % is_positional ) then allocate ( cla_list_new ( 1 : self % Na + 1 )) do c = 1 , self % Na cla_list_new ( c ) = self % cla ( c ) enddo cla_list_new ( self % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : self % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = self % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , self % Na + 1 cla_list_new ( c ) = self % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = self % cla ) self % Na = self % Na + 1 if ( cla % is_required ) then self % Na_required = self % Na_required + 1 else self % Na_optional = self % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) call self % check ( pref = pref ) endsubroutine add subroutine parse ( self , args , ignore_unknown_clas , pref , error_unknown_clas ) !< Parse CLAsG arguments. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), intent ( in ) :: args (:) !< Command line arguments. logical , intent ( in ) :: ignore_unknown_clas !< Disable errors-raising for passed unknown CLAs. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), intent ( out ) :: error_unknown_clas !< Error flag for passed unknown CLAs. type ( command_line_argument ) :: cla !< CLA data. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. error_unknown_clas = 0 if ( self % is_called ) then arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , self % Na ! loop over CLAs group clas named options if (. not . self % cla ( a )% is_positional ) then if ( trim ( adjustl ( self % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( self % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( self % cla ( a )% is_passed ) then ! current CLA has been already passed, raise an error call self % cla ( arg )% raise_error_duplicated_clas ( pref = pref , switch = trim ( adjustl ( args ( arg )))) self % error = self % cla ( arg )% error endif found_val = . false . if ( self % cla ( a )% act == action_store ) then if ( allocated ( self % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . self % is_defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = self % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then self % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( self % cla ( a )% def )) then self % cla ( a )% val = self % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( self % cla ( a )% nargs )) then self % cla ( a )% val = '' select case ( self % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . self % is_defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call self % cla ( a )% raise_error_nargs_insufficient ( pref = pref ) self % error = self % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . self % is_defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( self % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call self % cla ( a )% raise_error_nargs_insufficient ( pref = pref ) self % error = self % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) enddo found_val = . true . arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call self % cla ( a )% raise_error_value_missing ( pref = pref ) self % error = self % cla ( a )% error return endif arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( self % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . self % is_defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! flush default to val if default is set if ( allocated ( self % cla ( a )% def )) self % cla ( a )% val = self % cla ( a )% def endif elseif ( self % cla ( a )% act == action_print_help ) then self % error = STATUS_PRINT_H elseif ( self % cla ( a )% act == action_print_vers ) then self % error = STATUS_PRINT_V endif self % cla ( a )% is_passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if ( arg > self % Na ) then ! has been passed too much CLAs ! place the error into a new positional dummy CLA call cla % assign_object ( self ) cla % is_passed = . true . cla % m_exclude = '' call self % add ( pref = pref , cla = cla ) call self % cla ( self % Na )% raise_error_switch_unknown ( pref = pref , switch = trim ( adjustl ( args ( arg )))) self % error = self % cla ( self % Na )% error return endif if (. not . self % cla ( arg )% is_positional ) then ! current argument (arg-th) is not positional... there is a problem! call self % cla ( arg )% raise_error_switch_unknown ( pref = pref , switch = trim ( adjustl ( args ( arg )))) self % error = self % cla ( arg )% error error_unknown_clas = self % error if (. not . ignore_unknown_clas ) return else ! positional CLA always stores a value self % cla ( arg )% val = trim ( adjustl ( args ( arg ))) self % cla ( arg )% is_passed = . true . endif endif enddo call self % check_m_exclusive ( pref = pref ) call self % sanitize_defaults endif endsubroutine parse function usage ( self , pref , no_header , markdown ) !< Get correct CLAsG usage. class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( in ) :: markdown !< Format things form markdown. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: markdownd !< Markdonw format, local variable. markdownd = . false . ; if ( present ( markdown )) markdownd = markdown prefd = '' ; if ( present ( pref )) prefd = pref usage = self % progname ; if ( self % group /= '' ) usage = self % progname // ' ' // self % group usage = prefd // self % help // ' ' // usage // self % signature () if ( self % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // self % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( self % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , self % Na if ( self % cla ( a )% is_required . and .(. not . self % cla ( a )% is_hidden )) usage = usage // new_line ( 'a' ) // & self % cla ( a )% usage ( pref = prefd , markdown = markdownd ) enddo endif if ( self % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , self % Na if (. not . self % cla ( a )% is_required . and .(. not . self % cla ( a )% is_hidden )) usage = usage // new_line ( 'a' ) // & self % cla ( a )% usage ( pref = prefd , markdown = markdownd ) enddo endif endfunction usage function signature ( self , bash_completion , plain ) !< Get CLAsG signature. class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. logical , optional , intent ( in ) :: bash_completion !< Return the signature for bash completion. logical , optional , intent ( in ) :: plain !< Return the signature as plain switches list. ! logical                                         :: plain_           !< Return the signature as plain switches list, local var. logical :: bash_completion_ !< Return the signature for bash completion, local variable. character ( len = :), allocatable :: signature !< Signature. ! logical                                         :: clas_choices     !< Flag to check if there are CLAs with choices. integer ( I4P ) :: a !, aa            !< Counter. signature = '' bash_completion_ = . false . ; if ( present ( bash_completion )) bash_completion_ = bash_completion ! plain_ = .false. ; if (present(plain)) plain_ = plain ! if (bash_completion_) then !   ! if (plain_) then !   !   do a=1, self%Na !   !     signature = signature//self%cla(a)%signature(bash_completion=bash_completion, plain=plain) !   !   enddo !   ! else !     clas_choices = .false. !     do a=1, self%Na !       if (self%cla(a)%has_choices()) then !         aa = a !         clas_choices = .true. !         exit !       endif !     enddo !     if (clas_choices) then !       signature = signature//new_line('a')//& !                   '    if [ \"$prev\" == \"'//self%cla(aa)%switch//'\" ] || [ \"$prev\" == \"'//self%cla(aa)%switch_ab//'\" ] ; then' !       signature = signature//new_line('a')//'       COMPREPLY=( $( compgen -W \"'//choices(self%cla(aa)%choices)//'\" -- $cur ) )' !       do a=aa+1, self%Na !         if (self%cla(a)%has_choices()) then !           signature = signature//new_line('a')//& !                       '    elif [ \"$prev\" == \"'//self%cla(a)%switch//'\" ] || [ \"$prev\" == \"'//self%cla(a)%switch_ab//'\" ] ; then' !           signature = signature//new_line('a')//'       COMPREPLY=( $( compgen -W \"'//choices(self%cla(a)%choices)//& !                       '\" -- $cur ) )' !         endif !       enddo !       signature = signature//new_line('a')//'    else'//new_line('a')//'      COMPREPLY=( $( compgen -W \"' !       do a=1, self%Na !         signature = signature//self%cla(a)%signature(bash_completion=bash_completion) !       enddo !       signature = signature//'\" -- $cur ) )'//new_line('a')//'    fi' !     else !       signature = signature//new_line('a')//'    COMPREPLY=( $( compgen -W \"' !       do a=1, self%Na !         signature = signature//self%cla(a)%signature(bash_completion=bash_completion) !       enddo !       signature = signature//'\" -- $cur ) )' !     endif !   ! endif ! else if ( bash_completion_ ) then do a = 1 , self % Na signature = signature // self % cla ( a )% signature ( bash_completion = bash_completion , plain = . true .) enddo signature = new_line ( 'a' ) // '    COMPREPLY=( $( compgen -W \"' // signature // '\" -- $cur ) )' endif do a = 1 , self % Na signature = signature // self % cla ( a )% signature ( bash_completion = bash_completion , plain = plain ) enddo ! endif !contains !  pure function choices(choices_c) !  !< Return space-separated choices list from a comma-separated one. !  character(len=*), intent(in)  :: choices_c !< Comma-separated list of choices. !  character(len=len(choices_c)) :: choices   !< Space-separated list of choices. !  integer(I4P)                  :: c         !< Counter. !  choices = choices_c !  do c=1, len(choices) !    if (choices(c:c)==',') choices(c:c) = ' ' !  enddo !  endfunction choices endfunction signature ! private methods subroutine errored ( self , error , pref , a1 , a2 ) !< Trig error occurrence and print meaningful message. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( in ) :: a1 !< First index CLAs group inconsistent. integer ( I4P ), optional , intent ( in ) :: a2 !< Second index CLAs group inconsistent. character ( len = :), allocatable :: prefd !< Prefixing string. self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref prefd = prefd // self % progname // ': ' // colorize ( 'error' , color_fg = self % error_color , style = self % error_style ) select case ( self % error ) case ( ERROR_CONSISTENCY ) if ( self % group /= '' ) then self % error_message = prefd // ': group (command) name: \"' // self % group // '\" consistency error:' else self % error_message = prefd // ': consistency error:' endif self % error_message = self % error_message // ' \"' // trim ( str ( a1 , . true .)) // & '-th\" option has the same switch or abbreviated switch of \"' // & trim ( str ( a2 , . true .)) // '-th\" option:' // new_line ( 'a' ) self % error_message = self % error_message // prefd // ' CLA(' // trim ( str ( a1 , . true .)) // ') switches = ' // self % cla ( a1 )% switch // ' ' // & self % cla ( a1 )% switch_ab // new_line ( 'a' ) self % error_message = self % error_message // prefd // ' CLA(' // trim ( str ( a2 , . true .)) // ') switches = ' // self % cla ( a2 )% switch // ' ' // & self % cla ( a2 )% switch_ab case ( ERROR_M_EXCLUDE ) self % error_message = prefd // ': the group \"' // self % group // '\" and \"' // self % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect call self % print_error_message endif endsubroutine errored subroutine check_m_exclusive ( self , pref ) !< Check if two mutually exclusive CLAs have been passed. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. if ( self % is_called ) then do a = 1 , self % Na if ( self % cla ( a )% is_passed ) then if ( self % cla ( a )% m_exclude /= '' ) then if ( self % is_passed ( switch = self % cla ( a )% m_exclude )) then call self % cla ( a )% raise_error_m_exclude ( pref = pref ) self % error = self % cla ( a )% error return endif endif endif enddo endif endsubroutine check_m_exclusive subroutine sanitize_defaults ( self ) !< Sanitize defaults values. !< !< It is necessary to *sanitize* the default values of non-passed, optional CLAs. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. integer ( I4P ) :: a !< Counter. if ( self % is_called ) then do a = 1 , self % Na call self % cla ( a )% sanitize_defaults enddo endif endsubroutine sanitize_defaults elemental subroutine clasg_assign_clasg ( lhs , rhs ) !< Assignment operator. class ( command_line_arguments_group ), intent ( INOUT ) :: lhs !< Left hand side. type ( command_line_arguments_group ), intent ( IN ) :: rhs !< Right hand side. ! object members call lhs % assign_object ( rhs ) ! command_line_arguments_group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % is_called = rhs % is_called endsubroutine clasg_assign_clasg elemental subroutine finalize ( self ) !< Free dynamic memory when finalizing. type ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. call self % free endsubroutine finalize endmodule flap_command_line_arguments_group_t","tags":"","loc":"sourcefile/flap_command_line_arguments_group_t.f90.html"},{"title":"flap.f90 – FLAP","text":"FLAP, Fortran command Line Arguments Parser for poor people This file depends on sourcefile~~flap.f90~~EfferentGraph sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~flap.f90~~AfferentGraph sourcefile~flap.f90 flap.f90 sourcefile~flap_test_group.f90 flap_test_group.f90 sourcefile~flap_test_group.f90->sourcefile~flap.f90 sourcefile~flap_test_string.f90 flap_test_string.f90 sourcefile~flap_test_string.f90->sourcefile~flap.f90 sourcefile~flap_test_hidden.f90 flap_test_hidden.f90 sourcefile~flap_test_hidden.f90->sourcefile~flap.f90 sourcefile~flap_test_ansi_color_style.f90 flap_test_ansi_color_style.f90 sourcefile~flap_test_ansi_color_style.f90->sourcefile~flap.f90 sourcefile~flap_test_ignore_unknown_clas.f90 flap_test_ignore_unknown_clas.f90 sourcefile~flap_test_ignore_unknown_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_duplicated_clas.f90 flap_test_duplicated_clas.f90 sourcefile~flap_test_duplicated_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_nargs_insufficient.f90 flap_test_nargs_insufficient.f90 sourcefile~flap_test_nargs_insufficient.f90->sourcefile~flap.f90 sourcefile~flap_test_minimal.f90 flap_test_minimal.f90 sourcefile~flap_test_minimal.f90->sourcefile~flap.f90 sourcefile~flap_test_group_examples.f90 flap_test_group_examples.f90 sourcefile~flap_test_group_examples.f90->sourcefile~flap.f90 sourcefile~flap_test_value_missing.f90 flap_test_value_missing.f90 sourcefile~flap_test_value_missing.f90->sourcefile~flap.f90 sourcefile~flap_test_save_usage_to_markdown.f90 flap_test_save_usage_to_markdown.f90 sourcefile~flap_test_save_usage_to_markdown.f90->sourcefile~flap.f90 sourcefile~flap_test_save_man_page.f90 flap_test_save_man_page.f90 sourcefile~flap_test_save_man_page.f90->sourcefile~flap.f90 sourcefile~flap_test_save_bash_completion.f90 flap_test_save_bash_completion.f90 sourcefile~flap_test_save_bash_completion.f90->sourcefile~flap.f90 sourcefile~flap_test_choices_logical.f90 flap_test_choices_logical.f90 sourcefile~flap_test_choices_logical.f90->sourcefile~flap.f90 sourcefile~flap_test_basic.f90 flap_test_basic.f90 sourcefile~flap_test_basic.f90->sourcefile~flap.f90 sourcefile~flap_test_nested.f90 flap_test_nested.f90 sourcefile~flap_test_nested.f90->sourcefile~flap.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules flap Source Code flap.f90 Source Code !< FLAP, Fortran command Line Arguments Parser for poor people module flap !< FLAP, Fortran command Line Arguments Parser for poor people !<{!README-FLAP.md!} use flap_command_line_argument_t , only : command_line_argument use flap_command_line_arguments_group_t , only : command_line_arguments_group use flap_command_line_interface_t , only : command_line_interface , ERROR_UNKNOWN_CLAS_IGNORED implicit none private public :: command_line_argument public :: command_line_arguments_group public :: command_line_interface public :: ERROR_UNKNOWN_CLAS_IGNORED endmodule flap","tags":"","loc":"sourcefile/flap.f90.html"},{"title":"flap_command_line_interface_t.F90 – FLAP","text":"Command Line Interface (CLI) class. This file depends on sourcefile~~flap_command_line_interface_t.f90~~EfferentGraph sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_interface_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~face.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~flap_command_line_interface_t.f90~~AfferentGraph sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_test_group.f90 flap_test_group.f90 sourcefile~flap_test_group.f90->sourcefile~flap.f90 sourcefile~flap_test_string.f90 flap_test_string.f90 sourcefile~flap_test_string.f90->sourcefile~flap.f90 sourcefile~flap_test_hidden.f90 flap_test_hidden.f90 sourcefile~flap_test_hidden.f90->sourcefile~flap.f90 sourcefile~flap_test_ansi_color_style.f90 flap_test_ansi_color_style.f90 sourcefile~flap_test_ansi_color_style.f90->sourcefile~flap.f90 sourcefile~flap_test_ignore_unknown_clas.f90 flap_test_ignore_unknown_clas.f90 sourcefile~flap_test_ignore_unknown_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_duplicated_clas.f90 flap_test_duplicated_clas.f90 sourcefile~flap_test_duplicated_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_nargs_insufficient.f90 flap_test_nargs_insufficient.f90 sourcefile~flap_test_nargs_insufficient.f90->sourcefile~flap.f90 sourcefile~flap_test_minimal.f90 flap_test_minimal.f90 sourcefile~flap_test_minimal.f90->sourcefile~flap.f90 sourcefile~flap_test_group_examples.f90 flap_test_group_examples.f90 sourcefile~flap_test_group_examples.f90->sourcefile~flap.f90 sourcefile~flap_test_value_missing.f90 flap_test_value_missing.f90 sourcefile~flap_test_value_missing.f90->sourcefile~flap.f90 sourcefile~flap_test_save_usage_to_markdown.f90 flap_test_save_usage_to_markdown.f90 sourcefile~flap_test_save_usage_to_markdown.f90->sourcefile~flap.f90 sourcefile~flap_test_save_man_page.f90 flap_test_save_man_page.f90 sourcefile~flap_test_save_man_page.f90->sourcefile~flap.f90 sourcefile~flap_test_save_bash_completion.f90 flap_test_save_bash_completion.f90 sourcefile~flap_test_save_bash_completion.f90->sourcefile~flap.f90 sourcefile~flap_test_choices_logical.f90 flap_test_choices_logical.f90 sourcefile~flap_test_choices_logical.f90->sourcefile~flap.f90 sourcefile~flap_test_basic.f90 flap_test_basic.f90 sourcefile~flap_test_basic.f90->sourcefile~flap.f90 sourcefile~flap_test_nested.f90 flap_test_nested.f90 sourcefile~flap_test_nested.f90->sourcefile~flap.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules flap_command_line_interface_t Source Code flap_command_line_interface_t.F90 Source Code !< Command Line Interface (CLI) class. module flap_command_line_interface_t !< Command Line Interface (CLI) class. use face , only : colorize use flap_command_line_argument_t , only : command_line_argument , ACTION_STORE , ERROR_UNKNOWN use flap_command_line_arguments_group_t , only : command_line_arguments_group , STATUS_PRINT_H , STATUS_PRINT_V use flap_object_t , only : object use flap_utils_m use penf implicit none private save type , extends ( object ), public :: command_line_interface !< Command Line Interface (CLI) class. private type ( command_line_arguments_group ), allocatable :: clasg (:) !< CLA list [1:Na]. #ifdef __GFORTRAN__ character ( 512 ), allocatable :: args (:) !< Actually passed command line arguments. #else character ( len = :), allocatable :: args (:) !< Actually passed command line arguments. #endif logical :: disable_hv = . false . !< Disable automatic 'help' and 'version' CLAs. logical :: is_parsed_ = . false . !< Parse status. logical :: ignore_unknown_clas = . false . !< Disable errors-raising for passed unknown CLAs. integer ( I4P ) :: error_unknown_clas = 0_I4P !< Error trapping flag for unknown CLAs. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: init !< Initialize CLI. procedure , public :: add_group !< Add CLAs group CLI. procedure , public :: add !< Add CLA to CLI. procedure , public :: is_passed !< Check if a CLA has been passed. procedure , public :: is_defined_group !< Check if a CLAs group has been defined. procedure , public :: is_defined !< Check if a CLA has been defined. procedure , public :: is_parsed !< Check if CLI has been parsed. procedure , public :: set_mutually_exclusive_groups !< Set two CLAs group as mutually exclusive. procedure , public :: run_command => is_called_group !< Check if a CLAs group has been run. procedure , public :: parse !< Parse Command Line Interfaces. generic , public :: get => & get_cla , & get_cla_list !< Get CLA value(s) from CLAs list parsed. generic , public :: get_varying => & #if defined _R16P get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char !< Get CLA value(s) from CLAs list parsed, varying size list. procedure , public :: usage !< Get CLI usage. procedure , public :: signature !< Get CLI signature. procedure , public :: print_usage !< Print correct usage of CLI. procedure , public :: save_bash_completion !< Save bash completion script (for named CLAs only). procedure , public :: save_man_page !< Save CLI usage as man page. procedure , public :: save_usage_to_markdown !< Save CLI usage as markdown. ! private methods procedure , private :: errored !< Trig error occurence and print meaningful message. procedure , private :: check !< Check data consistency. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs group have been called. procedure , private :: get_clasg_indexes !< Get CLAs groups indexes. generic , private :: get_args => & get_args_from_string , & get_args_from_invocation !< Get CLAs. procedure , private :: get_args_from_string !< Get CLAs from string. procedure , private :: get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_cla !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R16P !< Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: cli_assign_cli !< CLI assignment overloading. generic , private :: assignment ( = ) => cli_assign_cli !< CLI assignment overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_interface integer ( I4P ), parameter , public :: MAX_VAL_LEN = 1000 !< Maximum number of characters of CLA value. ! errors codes integer ( I4P ), parameter , public :: ERROR_MISSING_CLA = 1000 !< CLA not found in CLI. integer ( I4P ), parameter , public :: ERROR_MISSING_GROUP = 1001 !< Group not found in CLI. integer ( I4P ), parameter , public :: ERROR_MISSING_SELECTION_CLA = 1002 !< CLA selection in CLI failing. integer ( I4P ), parameter , public :: ERROR_TOO_FEW_CLAS = 1003 !< Insufficient arguments for CLI. integer ( I4P ), parameter , public :: ERROR_UNKNOWN_CLAS_IGNORED = 1004 !< Unknown CLAs passed, but ignored. contains ! public methods elemental subroutine free ( self ) !< Free dynamic memory. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ) :: g !< Counter. ! object members call self % free_object ! command_line_interface members if ( allocated ( self % clasg )) then do g = 0 , size ( self % clasg , dim = 1 ) - 1 call self % clasg ( g )% free enddo deallocate ( self % clasg ) endif if ( allocated ( self % args )) deallocate ( self % args ) if ( allocated ( self % examples )) deallocate ( self % examples ) self % disable_hv = . false . self % is_parsed_ = . false . self % ignore_unknown_clas = . false . self % error_unknown_clas = 0_I4P endsubroutine free subroutine init ( self , progname , version , help , description , license , authors , examples , epilog , disable_hv , & usage_lun , error_lun , version_lun , error_color , error_style , ignore_unknown_clas ) !< Initialize CLI. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: progname !< Program name. character ( * ), optional , intent ( in ) :: version !< Program version. character ( * ), optional , intent ( in ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( in ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( in ) :: license !< License description. character ( * ), optional , intent ( in ) :: authors !< Authors list. character ( * ), optional , intent ( in ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( in ) :: epilog !< Epilog message. logical , optional , intent ( in ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. integer ( I4P ), optional , intent ( in ) :: usage_lun !< Unit number to print usage/help. integer ( I4P ), optional , intent ( in ) :: version_lun !< Unit number to print version/license info. integer ( I4P ), optional , intent ( in ) :: error_lun !< Unit number to print error info. character ( * ), optional , intent ( in ) :: error_color !< ANSI color of error messages. character ( * ), optional , intent ( in ) :: error_style !< ANSI style of error messages. logical , optional , intent ( in ) :: ignore_unknown_clas !< Disable errors-raising for passed unknown CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. call self % free if ( present ( progname )) then self % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then self % progname = prog_invocation else self % progname = 'program' endif endif self % version = 'unknown' ; if ( present ( version )) self % version = version self % help = 'usage: ' ; if ( present ( help )) self % help = help self % description = '' ; if ( present ( description )) self % description = description self % license = '' ; if ( present ( license )) self % license = license self % authors = '' ; if ( present ( authors )) self % authors = authors call self % set_examples ( examples ) self % epilog = '' ; if ( present ( epilog )) self % epilog = epilog if ( present ( disable_hv )) self % disable_hv = disable_hv ! default set by self%free if ( present ( usage_lun )) self % usage_lun = usage_lun ! default set by self%free if ( present ( version_lun )) self % version_lun = version_lun ! default set by self%free if ( present ( error_lun )) self % error_lun = error_lun ! default set by self%free self % error_color = '' ; if ( present ( error_color )) self % error_color = error_color self % error_style = '' ; if ( present ( error_style )) self % error_style = error_style if ( present ( ignore_unknown_clas )) self % ignore_unknown_clas = ignore_unknown_clas ! default set by self%free ! initialize only the first default group allocate ( self % clasg ( 0 : 0 )) call self % clasg ( 0 )% assign_object ( self ) self % clasg ( 0 )% group = '' endsubroutine init subroutine add_group ( self , help , description , exclude , examples , group ) !< Add CLAs group to CLI. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: help !< Help message. character ( * ), optional , intent ( in ) :: description !< Detailed description. character ( * ), optional , intent ( in ) :: exclude !< Group name of the mutually exclusive group. character ( * ), optional , intent ( in ) :: examples ( 1 :) !< Examples of correct usage of the group. character ( * ), intent ( in ) :: group !< Name of the grouped CLAs. type ( command_line_arguments_group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. integer ( I4P ) :: gi !< Group index if (. not . self % is_defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( self % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) !    clasg_list_new(0:Ng-1) = self%clasg(0:Ng-1) ! Not working on Intel Fortran 15.0.2 do gi = 0 , Ng - 1 clasg_list_new ( gi ) = self % clasg ( gi ) enddo call clasg_list_new ( Ng )% assign_object ( self ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded call clasg_list_new ( Ng )% set_examples ( examples ) deallocate ( self % clasg ) allocate ( self % clasg ( 0 : Ng )) self % clasg = clasg_list_new deallocate ( clasg_list_new ) endif endsubroutine add_group subroutine set_mutually_exclusive_groups ( self , group1 , group2 ) !< Set two CLAs group ad mutually exclusive. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), intent ( in ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( in ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 !< Counter. integer ( I4P ) :: g2 !< Counter. if ( self % is_defined_group ( group = group1 , g = g1 ). and . self % is_defined_group ( group = group2 , g = g2 )) then self % clasg ( g1 )% m_exclude = group2 self % clasg ( g2 )% m_exclude = group1 endif endsubroutine set_mutually_exclusive_groups subroutine add ( self , pref , group , group_index , switch , switch_ab , help , help_markdown , help_color , help_style , & required , positional , position , hidden , act , def , nargs , choices , exclude , envvar , error ) !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( in ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( in ) :: switch !< Switch name. character ( * ), optional , intent ( in ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( in ) :: help !< Help message describing the CLA. character ( * ), optional , intent ( in ) :: help_color !< ANSI color of help messages. character ( * ), optional , intent ( in ) :: help_style !< ANSI style of help messages. character ( * ), optional , intent ( in ) :: help_markdown !< Longer help message, markdown formatted. logical , optional , intent ( in ) :: required !< Flag for set required argument. logical , optional , intent ( in ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical , optional , intent ( in ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( in ) :: act !< CLA value action. character ( * ), optional , intent ( in ) :: def !< Default value. character ( * ), optional , intent ( in ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( in ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( in ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( in ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. type ( command_line_argument ) :: cla !< CLA data. integer ( I4P ) :: g !< Counter. ! initialize CLA call cla % assign_object ( self ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % help_color = '' ; if ( present ( help_color )) cla % help_color = help_color cla % help_style = '' ; if ( present ( help_style )) cla % help_style = help_style cla % help_markdown = '' ; if ( present ( help_markdown )) cla % help_markdown = help_markdown cla % is_required = . false . ; if ( present ( required )) cla % is_required = required cla % is_positional = . false . ; if ( present ( positional )) cla % is_positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % is_hidden = . false . ; if ( present ( hidden )) cla % is_hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( def )) cla % val = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar call cla % check ( pref = pref ) ; self % error = cla % error if ( self % error /= 0 ) then if ( present ( error )) error = self % error return endif ! add CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call self % clasg ( 0 )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( 0 )% error elseif ( present ( group )) then if ( self % is_defined_group ( group = group , g = g )) then call self % clasg ( g )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( g )% error else call self % add_group ( group = group ) call self % clasg ( size ( self % clasg , dim = 1 ) - 1 )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( size ( self % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( self % clasg , dim = 1 ) - 1 ) then call self % clasg ( group_index )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( group_index )% error endif endif if ( present ( error )) error = self % error endsubroutine add subroutine check ( self , pref , error ) !< Check data consistency. class ( command_line_interface ), intent ( INOUT ) :: self !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. do g = 0 , size ( self % clasg , dim = 1 ) - 1 ! check group consistency call self % clasg ( g )% check ( pref = pref ) self % error = self % clasg ( g )% error if ( present ( error )) error = self % error if ( self % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( self % clasg ( g )% m_exclude /= '' ) then if ( self % is_defined_group ( group = self % clasg ( g )% m_exclude , g = gg )) self % clasg ( gg )% m_exclude = self % clasg ( g )% group endif endif enddo endsubroutine check subroutine check_m_exclusive ( self , pref ) !< Check if two mutually exclusive CLAs group have been called. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. do g = 1 , size ( self % clasg , dim = 1 ) - 1 if ( self % clasg ( g )% is_called . and .( self % clasg ( g )% m_exclude /= '' )) then if ( self % is_defined_group ( group = self % clasg ( g )% m_exclude , g = gg )) then if ( self % clasg ( gg )% is_called ) then call self % clasg ( g )% raise_error_m_exclude ( pref = pref ) self % error = self % clasg ( g )% error exit endif endif endif enddo endsubroutine check_m_exclusive function is_passed ( self , group , switch , position ) !< Check if a CLA has been passed. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical :: is_passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. is_passed = . false . if (. not . present ( group )) then if ( present ( switch )) then is_passed = self % clasg ( 0 )% is_passed ( switch = switch ) elseif ( present ( position )) then is_passed = self % clasg ( 0 )% is_passed ( position = position ) endif else if ( self % is_defined_group ( group = group , g = g )) then if ( present ( switch )) then is_passed = self % clasg ( g )% is_passed ( switch = switch ) elseif ( present ( position )) then is_passed = self % clasg ( g )% is_passed ( position = position ) endif endif endif endfunction is_passed function is_defined_group ( self , group , g ) result ( defined ) !< Check if a CLAs group has been defined. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( out ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg !< Counter. integer ( I4P ) :: ggg !< Counter. defined = . false . do gg = 0 , size ( self % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( self % clasg ( gg )% group )) defined = ( self % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg endfunction is_defined_group function is_called_group ( self , group ) result ( called ) !< Check if a CLAs group has been run. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. called = . false . if ( self % is_defined_group ( group = group , g = g )) called = self % clasg ( g )% is_called endfunction is_called_group function is_defined ( self , switch , group ) !< Check if a CLA has been defined. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: switch !< Switch name. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLAs. logical :: is_defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. is_defined = . false . if (. not . present ( group )) then is_defined = self % clasg ( 0 )% is_defined ( switch = switch ) else if ( self % is_defined_group ( group = group , g = g )) is_defined = self % clasg ( g )% is_defined ( switch = switch ) endif endfunction is_defined elemental function is_parsed ( self ) !< Check if CLI has been parsed. class ( command_line_interface ), intent ( in ) :: self !< CLI data. logical :: is_parsed !< Parsed status. is_parsed = self % is_parsed_ endfunction is_parsed subroutine parse ( self , pref , args , error ) !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. if ( present ( error )) error = 0 if ( self % is_parsed_ ) return ! add help and version switches if not done by user if (. not . self % disable_hv ) then do g = 0 , size ( self % clasg , dim = 1 ) - 1 if (. not .( self % is_defined ( group = self % clasg ( g )% group , switch = '--help' ). and .& self % is_defined ( group = self % clasg ( g )% group , switch = '-h' ))) & call self % add ( pref = pref , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( self % is_defined ( group = self % clasg ( g )% group , switch = '--version' ). and . & self % is_defined ( group = self % clasg ( g )% group , switch = '-v' ))) & call self % add ( pref = pref , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( self % clasg , dim = 1 ) - 1 if (. not . self % is_defined ( group = self % clasg ( g )% group , switch = '--' )) & call self % add ( pref = pref , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parse passed CLAs grouping in indexes if ( present ( args )) then call self % get_args ( args = args , ai = ai ) else call self % get_args ( ai = ai ) endif ! check CLI consistency call self % check ( pref = pref ) if ( self % error > 0 ) then if ((( self % error == ERROR_UNKNOWN ). and .(. not . self % ignore_unknown_clas )). or .( self % error /= ERROR_UNKNOWN )) then if ( present ( error )) error = self % error return else self % error_unknown_clas = ERROR_UNKNOWN_CLAS_IGNORED endif endif ! parse CLI do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) then call self % clasg ( g )% parse ( args = self % args ( ai ( g , 1 ): ai ( g , 2 )), ignore_unknown_clas = self % ignore_unknown_clas , & pref = pref , error_unknown_clas = self % error_unknown_clas ) else call self % clasg ( g )% sanitize_defaults endif self % error = self % clasg ( g )% error if ( self % error < 0 ) exit if ( self % error > 0 ) then if ((( self % error == ERROR_UNKNOWN ). and .(. not . self % ignore_unknown_clas )). or .( self % error /= ERROR_UNKNOWN )) then if ( present ( error )) error = self % error exit else self % error_unknown_clas = ERROR_UNKNOWN_CLAS_IGNORED endif endif enddo if ( self % error > 0 ) then if ((( self % error == ERROR_UNKNOWN ). and .(. not . self % ignore_unknown_clas )). or .( self % error /= ERROR_UNKNOWN )) then if ( present ( error )) error = self % error return else self % error_unknown_clas = ERROR_UNKNOWN_CLAS_IGNORED endif endif ! trap the special cases of version/help printing if ( self % error == STATUS_PRINT_V ) then call self % print_version ( pref = pref ) stop elseif ( self % error == STATUS_PRINT_H ) then do g = 0 , size ( ai , dim = 1 ) - 1 if ( self % clasg ( g )% error == STATUS_PRINT_H ) then write ( self % usage_lun , '(A)' ) self % usage ( pref = pref , g = g ) stop endif enddo endif ! check if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call self % clasg ( g )% is_required_passed ( pref = pref ) self % error = self % clasg ( g )% error if ( self % error > 0 ) then if ((( self % error == ERROR_UNKNOWN ). and .(. not . self % ignore_unknown_clas )). or .( self % error /= ERROR_UNKNOWN )) then if ( present ( error )) error = self % error exit else self % error_unknown_clas = ERROR_UNKNOWN_CLAS_IGNORED endif endif enddo if ( self % error > 0 ) then if ((( self % error == ERROR_UNKNOWN ). and .(. not . self % ignore_unknown_clas )). or .( self % error /= ERROR_UNKNOWN )) then if ( present ( error )) error = self % error return else self % error_unknown_clas = ERROR_UNKNOWN_CLAS_IGNORED endif endif ! check mutually exclusive interaction call self % check_m_exclusive ( pref = pref ) self % is_parsed_ = . true . ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine parse subroutine get_clasg_indexes ( self , ai ) !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. allocate ( ai ( 0 : size ( self % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( self % args )) then Na = size ( self % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( self % is_defined_group ( group = trim ( self % args ( a )), g = g )) then found = . true . self % clasg ( g )% is_called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( self % is_defined_group ( group = trim ( self % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 self % clasg ( 0 )% is_called = . true . elseif ( all ( ai == 0 )) then self % clasg ( 0 )% is_called = . true . endif else self % clasg ( 0 )% is_called = . true . endif endsubroutine get_clasg_indexes subroutine get_args_from_string ( self , args , ai ) !< Get CLAs from string. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), intent ( in ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif ! prepare CLI arguments list if ( allocated ( self % args )) deallocate ( self % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate CLI arguments list #ifdef __GFORTRAN__ allocate ( self % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: self % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 self % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call self % get_clasg_indexes ( ai = ai ) contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. character ( * ), intent ( in ) :: argsin !< Arguments string. character ( * ), intent ( in ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t !< Counter. integer ( I4P ) :: tt !< Counter. call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) endfunction sanitize_args endsubroutine get_args_from_string subroutine get_args_from_invocation ( self , ai ) !< Get CLAs from CLI invocation. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. if ( allocated ( self % args )) deallocate ( self % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( self % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: self % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) self % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call self % get_clasg_indexes ( ai = ai ) endsubroutine get_args_from_invocation subroutine get_cla ( self , val , pref , args , group , switch , position , error ) !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( self % error == 0. or . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) then if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( position )% error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( self % error == 0. and .(. not . self % clasg ( g )% is_called )) then ! TODO warn (if liked) for non invoked group querying endif if ( present ( error )) error = self % error endsubroutine get_cla subroutine get_cla_list ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. class ( * ), intent ( inout ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list subroutine get_cla_list_varying_R16P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R16P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_R16P subroutine get_cla_list_varying_R8P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_R8P subroutine get_cla_list_varying_R4P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_R4P subroutine get_cla_list_varying_I8P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I8P subroutine get_cla_list_varying_I4P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I4P subroutine get_cla_list_varying_I2P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I2P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I2P subroutine get_cla_list_varying_I1P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I1P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I1P subroutine get_cla_list_varying_logical ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. logical , allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_logical subroutine get_cla_list_varying_char ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error > 0. and . self % error_unknown_clas /= ERROR_UNKNOWN_CLAS_IGNORED ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif ! check if the only error found is for unknown passed CLAs and if it is ignored by the user if ( self % error == ERROR_UNKNOWN . and . self % error_unknown_clas == ERROR_UNKNOWN_CLAS_IGNORED ) self % error = ERROR_UNKNOWN_CLAS_IGNORED if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_char function usage ( self , g , pref , no_header , no_examples , no_epilog , markdown ) result ( usaged ) !< Print correct usage of CLI. class ( command_line_interface ), intent ( in ) :: self !< CLI data. integer ( I4P ), intent ( in ) :: g !< Group index. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( in ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( in ) :: no_epilog !< Avoid insert epilogue to usage. logical , optional , intent ( in ) :: markdown !< Format things with markdown character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. logical :: markdownd !< Format for markdown. logical :: grouped_examples !< Will show examples of group usage. integer ( I4P ) :: gi !< Counter. no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog markdownd = . false . ; if ( present ( markdown )) markdownd = markdown prefd = '' ; if ( present ( pref )) prefd = pref grouped_examples = . false . if ( g > 0 ) then ! usage of a specific command usaged = self % clasg ( g )% usage ( pref = prefd , no_header = no_headerd , markdown = markdownd ) if ( allocated ( self % clasg ( g )% examples ). and .(. not . no_examplesd )) then usaged = usaged // print_examples ( prefd , self % clasg ( g )% examples ) grouped_examples = . true . endif else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // self % help // self % progname // ' ' // self % signature () if ( self % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // self % description endif if ( self % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // self % clasg ( 0 )% usage ( pref = prefd , no_header = . true ., markdown = markdownd ) if ( size ( self % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( self % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // self % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // self % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( self % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // self % progname // ' ' // self % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( self % examples ). and .(. not . no_examplesd ). and .(. not . grouped_examples )) then usaged = usaged // print_examples ( prefd , self % examples ) endif if ( self % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // self % epilog contains function print_examples ( prefd , examples ) result ( exampled ) !< Print examples of the correct usage. character ( * ), intent ( in ) :: prefd !< Prefixing string. character ( * ), intent ( in ) :: examples ( 1 :) !< Examples to be printed. character ( len = :), allocatable :: exampled !< Examples string. integer ( I4P ) :: e !< Counter. exampled = new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( examples , dim = 1 ) exampled = exampled // new_line ( 'a' ) // prefd // '   ' // trim ( examples ( e )) enddo endfunction print_examples endfunction usage function signature ( self , bash_completion ) !< Get signature. class ( command_line_interface ), intent ( in ) :: self !< CLI data. logical , optional , intent ( in ) :: bash_completion !< Return the signature for bash completion. logical :: bash_completion_ !< Return the signature for bash completion, local variable. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: g !< Counter. bash_completion_ = . false . ; if ( present ( bash_completion )) bash_completion_ = bash_completion if ( bash_completion_ ) then signature = signature // new_line ( 'a' ) // '    COMPREPLY=( )' signature = signature // new_line ( 'a' ) // '    COMPREPLY+=( $( compgen -W \"' // & self % clasg ( 0 )% signature ( bash_completion = bash_completion , plain = . true .) // '\" -- $cur ) )' if ( size ( self % clasg , dim = 1 ) > 1 ) then do g = 1 , size ( self % clasg , dim = 1 ) - 1 signature = signature // new_line ( 'a' ) // '    COMPREPLY+=( $( compgen -W \"' // self % clasg ( g )% group // '\" -- $cur ) )' enddo endif else signature = self % clasg ( 0 )% signature () if ( size ( self % clasg , dim = 1 ) > 1 ) then signature = signature // ' {' // self % clasg ( 1 )% group do g = 2 , size ( self % clasg , dim = 1 ) - 1 signature = signature // ',' // self % clasg ( g )% group enddo signature = signature // '} ...' endif endif endfunction signature subroutine print_usage ( self , pref ) !< Print correct usage. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. write ( self % usage_lun , '(A)' ) self % usage ( pref = pref , g = 0 ) endsubroutine print_usage subroutine save_bash_completion ( self , bash_file , error ) !< Save bash completion script (for named CLAs only). class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: bash_file !< Output file name of bash completion script. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. character ( len = :), allocatable :: script !< Script text. integer ( I4P ) :: g !< CLAs groups counter. integer ( I4P ) :: u !< Unit file handler. script = '#/usr/bin/env bash' if ( size ( self % clasg , dim = 1 ) > 1 ) then script = script // new_line ( 'a' ) // '_completion()' script = script // new_line ( 'a' ) // '{' script = script // new_line ( 'a' ) // '  cur=${COMP_WORDS[COMP_CWORD]}' script = script // new_line ( 'a' ) // '  prev=${COMP_WORDS[COMP_CWORD - 1]}' ! script = script//new_line('a')//'  if [[ $prev == \"--help\" || $prev == \"-h\" || $prev == \"--version\" || $prev == \"-v\" ]] ; then' ! script = script//new_line('a')//'    COMPREPLY=()' ! script = script//new_line('a')//'  else' script = script // new_line ( 'a' ) // '  groups=(' do g = 1 , size ( self % clasg , dim = 1 ) - 1 script = script // ' \"' // self % clasg ( g )% group // '\"' enddo script = script // ' )' ! script = script//new_line('a')//'    base_clas=('//& !          self%clasg(0)%signature(bash_completion=.true., plain=.true.)//' )' ! do g=1,size(self%clasg,dim=1)-1 !   script = script//new_line('a')//'    '//self%clasg(g)%group//'_clas=('//& !            self%clasg(g)%signature(bash_completion=.true., plain=.true.)//' )' ! enddo script = script // new_line ( 'a' ) // '  for g in ${groups[@]}; do' script = script // new_line ( 'a' ) // '    if [ \"$prev\" == \"$g\" ] ; then' script = script // new_line ( 'a' ) // '      group=$prev ' script = script // new_line ( 'a' ) // '    fi' script = script // new_line ( 'a' ) // '  done' ! script = script//new_line('a')//'  fi' script = script // new_line ( 'a' ) // '  if [ \"$group\" == \"' // self % clasg ( 1 )% group // '\" ] ; then' script = script // self % clasg ( 1 )% signature ( bash_completion = . true .) do g = 2 , size ( self % clasg , dim = 1 ) - 1 script = script // new_line ( 'a' ) // '  elif [ \"$group\" == \"' // self % clasg ( g )% group // '\" ] ; then' script = script // self % clasg ( g )% signature ( bash_completion = . true .) enddo script = script // new_line ( 'a' ) // '  else' script = script // '    ' // self % signature ( bash_completion = . true .) script = script // new_line ( 'a' ) // '  fi' script = script // new_line ( 'a' ) // '  return 0' script = script // new_line ( 'a' ) // '}' script = script // new_line ( 'a' ) // 'complete -F _completion ' // basename ( self % progname ) else script = script // new_line ( 'a' ) // 'complete -W \"' // self % signature ( bash_completion = . true .) // '\" ' // basename ( self % progname ) endif open ( newunit = u , file = trim ( adjustl ( bash_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) script else write ( u , \"(A)\" ) script endif close ( u ) contains pure function basename ( progname ) character ( len =* ), intent ( in ) :: progname !< Program name. character ( len = :), allocatable :: basename !< Program name without full PATH. integer ( I4P ) :: pos !< Counter. basename = progname pos = index ( basename , '/' , back = . true .) if ( pos > 0 ) then basename = basename ( pos + 1 :) else pos = index ( basename , '\\', back=.true.) if (pos>0) basename = basename(pos+1:) endif endfunction basename endsubroutine save_bash_completion subroutine save_man_page(self, man_file, error) !< Save CLI usage as man page. class(command_line_interface), intent(in)  :: self               !< CLI data. character(*),                  intent(in)  :: man_file           !< Output file name for saving man page. integer(I4P), optional,        intent(out) :: error              !< Error trapping flag. character(len=:), allocatable              :: man                !< Man page. integer(I4P)                               :: idate(1:8)         !< Integer array for handling the date. integer(I4P)                               :: e                  !< Counter. integer(I4P)                               :: u                  !< Unit file handler. character(*), parameter                    :: month(12)=[\"Jan\",& \"Feb\",& \"Mar\",& \"Apr\",& \"May\",& \"Jun\",& \"Jul\",& \"Aug\",& \"Sep\",& \"Oct\",& \"Nov\",& \"Dec\"]  !< Months list. call date_and_time(values=idate) man = ' . TH '//self%progname//' \"1\" \"'//month(idate(2))//' '//trim(adjustl(strz(idate(1),4)))//'\" \"version '//self%version//& '\" \"'//self%progname//' Manual\" ' man = man//new_line(' a ')//' . SH NAME ' man = man//new_line(' a ')//self%progname//' - manual page for '//self%progname//' version '//self%version man = man//new_line(' a ')//' . SH SYNOPSIS ' man = man//new_line(' a ')//' . B '//self%progname//new_line(' a ')//trim(adjustl(self%signature())) if (self%description /= '') man = man//new_line(' a ')//' . SH DESCRIPTION '//new_line(' a ')//self%description if (self%clasg(0)%Na>0) then man = man//new_line(' a ')//' . SH OPTIONS ' man = man//new_line(' a ')//self%usage(no_header=.true.,no_examples=.true.,no_epilog=.true.,g=0) endif if (allocated(self%examples)) then man = man//new_line(' a ')//' . SH EXAMPLES ' man = man//new_line(' a ')//' . PP ' man = man//new_line(' a ')//' . nf ' man = man//new_line(' a ')//' . RS ' do e=1, size(self%examples,dim=1) man = man//new_line(' a ')//trim(self%examples(e)) enddo man = man//new_line(' a ')//' . RE ' man = man//new_line(' a ')//' . fi ' man = man//new_line(' a ')//' . PP ' endif if (self%authors /= '') man = man//new_line(' a ')//' . SH AUTHOR '//new_line(' a ')//self%authors if (self%license /= '') man = man//new_line(' a ')//' . SH COPYRIGHT '//new_line(' a ')//self%license open(newunit=u,file=trim(adjustl(man_file))) if (present(error)) then write(u, \"(A)\", iostat=error)man else write(u, \"(A)\")man endif close(u) endsubroutine save_man_page subroutine save_usage_to_markdown(self, markdown_file, error) !< Save CLI usage as markdown. class(command_line_interface), intent(in)  :: self               !< CLI data. character(*),                  intent(in)  :: markdown_file      !< Output file name for saving man page. integer(I4P), optional,        intent(out) :: error              !< Error trapping flag. character(len=:), allocatable              :: man                !< Man page. integer(I4P)                               :: idate(1:8)         !< Integer array for handling the date. integer(I4P)                               :: e                  !< Counter. integer(I4P)                               :: u                  !< Unit file handler. character(*), parameter                    :: month(12)=[\"Jan\",& \"Feb\",& \"Mar\",& \"Apr\",& \"May\",& \"Jun\",& \"Jul\",& \"Aug\",& \"Sep\",& \"Oct\",& \"Nov\",& \"Dec\"]  !< Months list. call date_and_time(values=idate) man = ' # '//self%progname//new_line(' a ') man = man//new_line(' a ')//' Manual page for ` '//self%progname//' ` version '//self%version//new_line(' a ') man = man//new_line(' a ')//' ` '//self%progname//' '//trim(adjustl(self%signature()))//' ` '//new_line(' a ') man = man//new_line(' a ')//month(idate(2))//' '//trim(adjustl(strz(idate(1),4)))//new_line(' a ') if (self%description /= '') man = man//new_line(' a ')//' ### Short description '//new_line(' a ')//new_line(' a ')//self%description if (self%clasg(0)%Na>0) then man = man//new_line(' a ')//new_line(' a ')//' ### Command line options : ' man = man//self%usage(no_header=.true.,no_examples=.true.,no_epilog=.true.,g=0,markdown=.true.) endif if (allocated(self%examples)) then man = man//new_line(' a ')//new_line(' a ')//' ### Examples ' do e=1, size(self%examples,dim=1) man = man//new_line(' a ') man = man//new_line(' a ')//' ` '//trim(self%examples(e))//' ` ' enddo endif open(newunit=u,file=trim(adjustl(markdown_file))) if (present(error)) then write(u, \"(A)\", iostat=error)man else write(u, \"(A)\")man endif close(u) endsubroutine save_usage_to_markdown ! private methods subroutine errored(self, error, pref, group, switch) !< Trig error occurrence and print meaningful message. class(command_line_interface), intent(inout) :: self   !< Object data. integer(I4P),                  intent(in)    :: error  !< Error occurred. character(*), optional,        intent(in)    :: pref   !< Prefixing string. character(*), optional,        intent(in)    :: group  !< Group name. character(*), optional,        intent(in)    :: switch !< CLA switch name. character(len=:), allocatable                :: prefd  !< Prefixing string. self%error = error if (self%error/=0) then prefd = '' ; if (present(pref)) prefd = pref prefd = prefd//self%progname//' : '//colorize(' error ', color_fg=self%error_color, style=self%error_style) select case(self%error) case(ERROR_MISSING_CLA) self%error_message = prefd//' : there is no option \"'//trim(adjustl(switch))//'\" !' case ( ERROR_MISSING_SELECTION_CLA ) self % error_message = prefd // ': to get an option value one of switch \"name\" or \"position\" must be provided!' case ( ERROR_MISSING_GROUP ) self % error_message = prefd // ': ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( ERROR_TOO_FEW_CLAS ) ! self%error_message = prefd//': too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,self%Na_required))//')' endselect write ( self % error_lun , '(A)' ) call self % print_error_message endif endsubroutine errored elemental subroutine cli_assign_cli ( lhs , rhs ) !< Assignment operator. class ( command_line_interface ), intent ( inout ) :: lhs !< Left hand side. type ( command_line_interface ), intent ( in ) :: rhs !< Right hand side. ! object members call lhs % assign_object ( rhs ) ! command_line_interface members if ( allocated ( rhs % clasg )) lhs % clasg = rhs % clasg if ( allocated ( rhs % examples )) lhs % examples = rhs % examples lhs % disable_hv = rhs % disable_hv endsubroutine cli_assign_cli elemental subroutine finalize ( self ) !< Free dynamic memory when finalizing. type ( command_line_interface ), intent ( inout ) :: self !< CLI data. call self % free endsubroutine finalize endmodule flap_command_line_interface_t","tags":"","loc":"sourcefile/flap_command_line_interface_t.f90.html"},{"title":"flap_command_line_argument_t.F90 – FLAP","text":"Command Line Argument (CLA) class. This file depends on sourcefile~~flap_command_line_argument_t.f90~~EfferentGraph sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~face.f90 face.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~face.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_object_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~flap_command_line_argument_t.f90~~AfferentGraph sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_test_group.f90 flap_test_group.f90 sourcefile~flap_test_group.f90->sourcefile~flap.f90 sourcefile~flap_test_string.f90 flap_test_string.f90 sourcefile~flap_test_string.f90->sourcefile~flap.f90 sourcefile~flap_test_hidden.f90 flap_test_hidden.f90 sourcefile~flap_test_hidden.f90->sourcefile~flap.f90 sourcefile~flap_test_ansi_color_style.f90 flap_test_ansi_color_style.f90 sourcefile~flap_test_ansi_color_style.f90->sourcefile~flap.f90 sourcefile~flap_test_ignore_unknown_clas.f90 flap_test_ignore_unknown_clas.f90 sourcefile~flap_test_ignore_unknown_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_duplicated_clas.f90 flap_test_duplicated_clas.f90 sourcefile~flap_test_duplicated_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_nargs_insufficient.f90 flap_test_nargs_insufficient.f90 sourcefile~flap_test_nargs_insufficient.f90->sourcefile~flap.f90 sourcefile~flap_test_minimal.f90 flap_test_minimal.f90 sourcefile~flap_test_minimal.f90->sourcefile~flap.f90 sourcefile~flap_test_group_examples.f90 flap_test_group_examples.f90 sourcefile~flap_test_group_examples.f90->sourcefile~flap.f90 sourcefile~flap_test_value_missing.f90 flap_test_value_missing.f90 sourcefile~flap_test_value_missing.f90->sourcefile~flap.f90 sourcefile~flap_test_save_usage_to_markdown.f90 flap_test_save_usage_to_markdown.f90 sourcefile~flap_test_save_usage_to_markdown.f90->sourcefile~flap.f90 sourcefile~flap_test_save_man_page.f90 flap_test_save_man_page.f90 sourcefile~flap_test_save_man_page.f90->sourcefile~flap.f90 sourcefile~flap_test_save_bash_completion.f90 flap_test_save_bash_completion.f90 sourcefile~flap_test_save_bash_completion.f90->sourcefile~flap.f90 sourcefile~flap_test_choices_logical.f90 flap_test_choices_logical.f90 sourcefile~flap_test_choices_logical.f90->sourcefile~flap.f90 sourcefile~flap_test_basic.f90 flap_test_basic.f90 sourcefile~flap_test_basic.f90->sourcefile~flap.f90 sourcefile~flap_test_nested.f90 flap_test_nested.f90 sourcefile~flap_test_nested.f90->sourcefile~flap.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules flap_command_line_argument_t Source Code flap_command_line_argument_t.F90 Source Code !< Command Line Argument (CLA) class. module flap_command_line_argument_t !< Command Line Argument (CLA) class. use face , only : colorize use flap_object_t , only : object use flap_utils_m use penf implicit none private save public :: command_line_argument public :: ACTION_STORE public :: ACTION_STORE_STAR public :: ACTION_STORE_TRUE public :: ACTION_STORE_FALSE public :: ACTION_PRINT_HELP public :: ACTION_PRINT_VERS public :: ARGS_SEP public :: ERROR_UNKNOWN type , extends ( object ) :: command_line_argument !< Command Line Argument (CLA) class. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value. private character ( len = :), allocatable , public :: switch !< Switch name. character ( len = :), allocatable , public :: switch_ab !< Abbreviated switch name. logical , public :: is_required = . false . !< Flag for set required argument. logical , public :: is_positional = . false . !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), public :: position = 0_I4P !< Position of positional CLA. logical , public :: is_passed = . false . !< Flag for checking if CLA has been passed to CLI. logical , public :: is_hidden = . false . !< Flag for hiding CLA, thus it does not compare into help. character ( len = :), allocatable , public :: act !< CLA value action. character ( len = :), allocatable , public :: def !< Default value. character ( len = :), allocatable , public :: nargs !< Number of arguments consumed by CLA. character ( len = :), allocatable , public :: choices !< List (comma separated) of allowable values for the argument. character ( len = :), allocatable , public :: val !< CLA value. character ( len = :), allocatable , public :: envvar !< Environment variable from which take value. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: check !< Check data consistency. procedure , public :: is_required_passed !< Check if required CLA is passed. procedure , public :: raise_error_m_exclude !< Raise error mutually exclusive CLAs passed. procedure , public :: raise_error_nargs_insufficient !< Raise error insufficient number of argument values passed. procedure , public :: raise_error_value_missing !< Raise error missing value. procedure , public :: raise_error_switch_unknown !< Raise error switch_unknown. procedure , public :: raise_error_duplicated_clas !< Raise error duplicated CLAs passed. generic , public :: get => & get_cla , & get_cla_list !< Get CLA value(s). generic , public :: get_varying => & #if defined _R16P get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char !< Get CLA value(s) from varying size list. procedure , public :: has_choices !< Return true if CLA has defined choices. procedure , public :: sanitize_defaults !< Sanitize default values. procedure , public :: signature !< Get signature. procedure , public :: usage !< Get correct usage. ! private methods procedure , private :: errored !< Trig error occurence and print meaningful message. procedure , private :: check_envvar_consistency !< Check data consistency for envvar CLA. procedure , private :: check_action_consistency !< Check CLA action consistency. procedure , private :: check_optional_consistency !< Check optional CLA consistency. procedure , private :: check_m_exclude_consistency !< Check mutually exclusion consistency. procedure , private :: check_named_consistency !< Check named CLA consistency. procedure , private :: check_positional_consistency !< Check positional CLA consistency. procedure , private :: check_choices !< Check if CLA value is in allowed choices. procedure , private :: check_list_size !< Check CLA multiple values list size consistency. procedure , private :: get_cla !< Get CLA (single) value. procedure , private :: get_cla_from_buffer !< Get CLA (single) value from a buffer. procedure , private :: get_cla_list !< Get CLA multiple values. procedure , private :: get_cla_list_from_buffer !< Get CLA (single) value from a buffer. procedure , private :: get_cla_list_varying_R16P !< Get CLA multiple values, varying size, R16P. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values, varying size, char. procedure , private :: cla_assign_cla !< Assignment operator. generic , private :: assignment ( = ) => cla_assign_cla !< Assignment operator overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_argument ! parameters character ( len =* ), parameter :: ACTION_STORE = 'STORE' !< Store value (if invoked a value must be passed). character ( len =* ), parameter :: ACTION_STORE_STAR = 'STORE*' !< Store value or revert on default if invoked alone. character ( len =* ), parameter :: ACTION_STORE_TRUE = 'STORE_TRUE' !< Store .true. without the necessity of a value. character ( len =* ), parameter :: ACTION_STORE_FALSE = 'STORE_FALSE' !< Store .false. without the necessity of a value. character ( len =* ), parameter :: ACTION_PRINT_HELP = 'PRINT_HELP' !< Print help message. character ( len =* ), parameter :: ACTION_PRINT_VERS = 'PRINT_VERSION' !< Print version. character ( len =* ), parameter :: ARGS_SEP = '||!||' !< Arguments separator for multiple valued (list) CLA. ! errors codes integer ( I4P ), parameter :: ERROR_OPTIONAL_NO_DEF = 1 !< Optional CLA without default value. integer ( I4P ), parameter :: ERROR_REQUIRED_M_EXCLUDE = 2 !< Required CLA cannot exclude others. integer ( I4P ), parameter :: ERROR_POSITIONAL_M_EXCLUDE = 3 !< Positional CLA cannot exclude others. integer ( I4P ), parameter :: ERROR_NAMED_NO_NAME = 4 !< Named CLA without switch name. integer ( I4P ), parameter :: ERROR_POSITIONAL_NO_POSITION = 5 !< Positional CLA without position. integer ( I4P ), parameter :: ERROR_POSITIONAL_NO_STORE = 6 !< Positional CLA without action_store. integer ( I4P ), parameter :: ERROR_NOT_IN_CHOICES = 7 !< CLA value out of a specified choices. integer ( I4P ), parameter :: ERROR_MISSING_REQUIRED = 8 !< Missing required CLA. integer ( I4P ), parameter :: ERROR_M_EXCLUDE = 9 !< Two mutually exclusive CLAs have been passed. integer ( I4P ), parameter :: ERROR_CASTING_LOGICAL = 10 !< Error casting CLA value to logical type. integer ( I4P ), parameter :: ERROR_CHOICES_LOGICAL = 11 !< Error adding choices check for CLA val of logical type. integer ( I4P ), parameter :: ERROR_NO_LIST = 12 !< Actual CLA is not list-values. integer ( I4P ), parameter :: ERROR_NARGS_INSUFFICIENT = 13 !< Multi-valued CLA with insufficient arguments. integer ( I4P ), parameter :: ERROR_VALUE_MISSING = 14 !< Missing value of CLA. integer ( I4P ), parameter :: ERROR_UNKNOWN = 15 !< Unknown CLA (switch name). integer ( I4P ), parameter :: ERROR_ENVVAR_POSITIONAL = 16 !< Envvar not allowed for positional CLA. integer ( I4P ), parameter :: ERROR_ENVVAR_NOT_STORE = 17 !< Envvar not allowed action different from store; integer ( I4P ), parameter :: ERROR_ENVVAR_NARGS = 18 !< Envvar not allowed for list-values CLA. integer ( I4P ), parameter :: ERROR_STORE_STAR_POSITIONAL = 19 !< Action store* not allowed for positional CLA. integer ( I4P ), parameter :: ERROR_STORE_STAR_NARGS = 20 !< Action store* not allowed for list-values CLA. integer ( I4P ), parameter :: ERROR_STORE_STAR_ENVVAR = 21 !< Action store* not allowed for environment variable CLA. integer ( I4P ), parameter :: ERROR_ACTION_UNKNOWN = 22 !< Unknown CLA (switch name). integer ( I4P ), parameter :: ERROR_DUPLICATED_CLAS = 23 !< Duplicated CLAs passed, passed multiple instance of the same CLA. contains ! public methods elemental subroutine free ( self ) !< Free dynamic memory. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. ! object members call self % free_object ! command_line_argument members if ( allocated ( self % switch )) deallocate ( self % switch ) if ( allocated ( self % switch_ab )) deallocate ( self % switch_ab ) if ( allocated ( self % act )) deallocate ( self % act ) if ( allocated ( self % def )) deallocate ( self % def ) if ( allocated ( self % nargs )) deallocate ( self % nargs ) if ( allocated ( self % choices )) deallocate ( self % choices ) if ( allocated ( self % val )) deallocate ( self % val ) if ( allocated ( self % envvar )) deallocate ( self % envvar ) self % is_required = . false . self % is_positional = . false . self % position = 0_I4P self % is_passed = . false . self % is_hidden = . false . endsubroutine free subroutine check ( self , pref ) !< Check data consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % check_envvar_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_action_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_optional_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_m_exclude_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_named_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_positional_consistency ( pref = pref ) endsubroutine check function is_required_passed ( self , pref ) result ( is_ok ) !< Check if required CLA is passed. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical :: is_ok !< Check result. is_ok = . true . if (((. not . self % is_passed ). and . self % is_required ). or .((. not . self % is_passed ). and .(. not . allocated ( self % def )))) then call self % errored ( pref = pref , error = ERROR_MISSING_REQUIRED ) is_ok = . false . endif endfunction is_required_passed subroutine raise_error_m_exclude ( self , pref ) !< Raise error mutually exclusive CLAs passed. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_M_EXCLUDE ) endsubroutine raise_error_m_exclude subroutine raise_error_nargs_insufficient ( self , pref ) !< Raise error insufficient number of argument values passed. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endsubroutine raise_error_nargs_insufficient subroutine raise_error_value_missing ( self , pref ) !< Raise error missing value. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_VALUE_MISSING ) endsubroutine raise_error_value_missing subroutine raise_error_switch_unknown ( self , switch , pref ) !< Raise error switch_unknown. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_UNKNOWN , switch = switch ) endsubroutine raise_error_switch_unknown subroutine raise_error_duplicated_clas ( self , switch , pref ) !< Raise error duplicated CLAs passed. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_DUPLICATED_CLAS , switch = switch ) endsubroutine raise_error_duplicated_clas subroutine sanitize_defaults ( self ) !< Sanitize defaults values. !< !< It is necessary to *sanitize* the default values of non-passed, optional CLA. class ( command_line_argument ), intent ( inout ) :: self !< CLAsG data. if (. not . self % is_passed ) then if ( allocated ( self % def )) then ! strip leading and trailing white spaces self % def = wstrip ( self % def ) if ( allocated ( self % nargs )) then ! replace white space separator with FLAP ARGS_SEP self % def = unique ( string = self % def , substring = ' ' ) self % def = replace_all ( string = self % def , substring = ' ' , restring = ARGS_SEP ) endif endif endif endsubroutine sanitize_defaults function usage ( self , pref , markdown ) !< Get correct usage. class ( command_line_argument ), intent ( in ) :: self !< CLAs group data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: markdown !< Format for markdown character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: switch_ !< Switch name, local variable. character ( len = :), allocatable :: switch_ab_ !< Abbreviated switch name, local variable. integer ( I4P ) :: a !< Counter. logical :: markdownd !< Format for markdown integer :: indent !< how many spaces to indent markdownd = . false . ; if ( present ( markdown )) markdownd = markdown indent = 4 switch_ = colorize ( trim ( adjustl ( self % switch )), color_fg = self % help_color , style = self % help_style ) switch_ab_ = colorize ( trim ( adjustl ( self % switch_ab )), color_fg = self % help_color , style = self % help_style ) if (. not . self % is_hidden ) then if ( self % act == action_store ) then if (. not . self % is_positional ) then if ( allocated ( self % nargs )) then usage = '' select case ( self % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( self % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str ( a , . true .)) enddo endselect if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // usage // '`, `' // trim ( adjustl ( self % switch_ab )) // usage // '`' else usage = '   ' // switch_ // usage // ', ' // switch_ab_ // usage endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // usage // '`' else usage = '   ' // switch_ // usage endif endif else if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // ' value`, `' // trim ( adjustl ( self % switch_ab )) // ' value' // '`' else usage = '   ' // switch_ // ' value, ' // switch_ab_ // ' value' endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // ' value`' else usage = '   ' // switch_ // ' value' endif endif endif else usage = '  value' endif if ( allocated ( self % choices )) then usage = usage // ', value in: `' // self % choices // '`' endif elseif ( self % act == action_store_star ) then usage = '  [value]' if ( allocated ( self % choices )) then usage = usage // ', value in: (' // self % choices // ')' endif else if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // '`, `' // trim ( adjustl ( self % switch_ab )) // '`' else usage = '   ' // switch_ // ', ' // switch_ab_ endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // '`' else usage = '   ' // switch_ endif endif endif prefd = '' ; if ( present ( pref )) prefd = pref usage = prefd // usage if ( self % is_positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // trim ( str ( self % position , . true .)) // & '-th argument' if ( allocated ( self % envvar )) then if ( self % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( self % envvar )) // '\"' endif endif if (. not . self % is_required ) then if ( self % def /= '' ) then if ( markdownd ) then ! two spaces make a line break in markdown. usage = usage // '  ' // new_line ( 'a' ) // prefd // repeat ( ' ' , 4 ) // 'default value ' // trim ( replace_all ( self % def , ARGS_SEP , ' ' )) else usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // 'default value ' // trim ( replace_all ( self % def , ARGS_SEP , ' ' )) endif endif endif if ( self % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // 'mutually exclude \"' // self % m_exclude // '\"' if ( markdownd ) then usage = usage // '  ' // new_line ( 'a' ) // prefd // repeat ( ' ' , 4 ) // trim ( adjustl ( self % help )) if ( self % help_markdown /= '' ) then usage = usage // trim ( adjustl ( self % help_markdown )) endif else usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // trim ( adjustl ( self % help )) endif else usage = '' endif endfunction usage function signature ( self , bash_completion , plain ) !< Get signature. class ( command_line_argument ), intent ( in ) :: self !< CLA data. logical , optional , intent ( in ) :: bash_completion !< Return the signature for bash completion. logical , optional , intent ( in ) :: plain !< Return the signature as plain switches list. logical :: plain_ !< Return the signature as plain switches list, local var. logical :: bash_completion_ !< Return the signature for bash completion, local variable. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. bash_completion_ = . false . ; if ( present ( bash_completion )) bash_completion_ = bash_completion plain_ = . false . ; if ( present ( plain )) plain_ = plain if (. not . self % is_hidden ) then if ( bash_completion_ ) then if (. not . self % is_positional ) then if ( plain_ ) then if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then signature = ' ' // trim ( adjustl ( self % switch )) // ' ' // trim ( adjustl ( self % switch_ab )) else signature = ' ' // trim ( adjustl ( self % switch )) endif else signature = new_line ( 'a' ) // '    if [ \"$prev\" == \"' // self % switch // '\" ] || [ \"$prev\" == \"' // self % switch_ab // '\" ] ; then' if ( self % has_choices ()) then signature = signature // new_line ( 'a' ) // '       COMPREPLY=( $( compgen -W \"' // choices ( self % choices ) // '\" -- $cur ) )' elseif (( self % act == action_store ). or .( self % act == action_store_star )) then signature = signature // new_line ( 'a' ) // '       COMPREPLY=( )' endif signature = signature // new_line ( 'a' ) // '       return 0' signature = signature // new_line ( 'a' ) // '    fi' endif ! if (trim(adjustl(self%switch))/=trim(adjustl(self%switch_ab))) then ! if (plain_) then !   signature = ' \"'//trim(adjustl(self%switch))//'\" \"'//trim(adjustl(self%switch_ab))//'\"' ! else ! signature = ' '//trim(adjustl(self%switch))//' '//trim(adjustl(self%switch_ab)) ! endif ! else ! if (plain_) then !   signature = ' \"'//trim(adjustl(self%switch))//'\"' ! else ! signature = ' '//trim(adjustl(self%switch)) ! endif ! endif endif else if ( self % act == action_store ) then if (. not . self % is_positional ) then if ( allocated ( self % nargs )) then select case ( self % nargs ) case ( '+' ) signature = ' value#1 [value#2 value#3...]' case ( '*' ) signature = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( self % nargs )), knd = 1_I4P ) signature = '' do a = 1 , nargs signature = signature // ' value#' // trim ( str ( a , . true .)) enddo endselect else signature = ' value' endif if ( self % is_required ) then signature = ' ' // trim ( adjustl ( self % switch )) // signature else signature = ' [' // trim ( adjustl ( self % switch )) // signature // ']' endif else if ( self % is_required ) then signature = ' value' else signature = ' [value]' endif endif elseif ( self % act == action_store_star ) then signature = ' [value]' else if ( self % is_required ) then signature = ' ' // trim ( adjustl ( self % switch )) else signature = ' [' // trim ( adjustl ( self % switch )) // ']' endif endif endif else signature = '' endif contains pure function choices ( choices_c ) !< Return space-separated choices list from a comma-separated one. character ( len =* ), intent ( in ) :: choices_c !< Comma-separated list of choices. character ( len = len ( choices_c )) :: choices !< Space-separated list of choices. integer ( I4P ) :: c !< Counter. choices = choices_c do c = 1 , len ( choices ) if ( choices ( c : c ) == ',' ) choices ( c : c ) = ' ' enddo endfunction choices endfunction signature pure function has_choices ( self ) !< Return true if CLA has choices. class ( command_line_argument ), intent ( in ) :: self !< CLA data. logical :: has_choices !< Check result. has_choices = allocated ( self % choices ) endfunction has_choices ! private methods subroutine errored ( self , error , pref , switch , val_str , log_value ) !< Trig error occurence and print meaningful message. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: val_str !< Value string. character ( * ), optional , intent ( in ) :: log_value !< Logical value to be casted. character ( len = :), allocatable :: prefd !< Prefixing string. self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref prefd = prefd // self % progname // ': ' // colorize ( 'error' , color_fg = self % error_color , style = self % error_style ) select case ( self % error ) case ( ERROR_OPTIONAL_NO_DEF ) if ( self % is_positional ) then self % error_message = prefd // ': \"' // trim ( str ( n = self % position )) // '-th\" positional option has not a default value!' else self % error_message = prefd // ': named option \"' // self % switch // '\" has not a default value!' endif case ( ERROR_REQUIRED_M_EXCLUDE ) self % error_message = prefd // ': named option \"' // self % switch // '\" cannot exclude others' // & ', it being required, only optional ones can!' case ( ERROR_POSITIONAL_M_EXCLUDE ) self % error_message = prefd // ': \"' // trim ( str ( n = self % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( ERROR_NAMED_NO_NAME ) self % error_message = prefd // ': a non positional optiona must have a switch name!' case ( ERROR_POSITIONAL_NO_POSITION ) self % error_message = prefd // ': a positional option must have a position number different from 0!' case ( ERROR_POSITIONAL_NO_STORE ) self % error_message = prefd // ': a positional option must have action set to \"' // action_store // '\"!' case ( ERROR_M_EXCLUDE ) self % error_message = prefd // ': the options \"' // self % switch // '\" and \"' // self % m_exclude // & '\" are mutually exclusive, but both have been passed!' case ( ERROR_NOT_IN_CHOICES ) if ( self % is_positional ) then self % error_message = prefd // ': value of \"' // trim ( str ( n = self % position )) // & '-th\" positional option must be chosen in:' else self % error_message = prefd // ': value of named option \"' // self % switch // '\" must be chosen in: ' endif self % error_message = self % error_message // '(' // self % choices // ')' self % error_message = self % error_message // ' but \"' // trim ( val_str ) // '\" has been passed!' case ( ERROR_MISSING_REQUIRED ) if (. not . self % is_positional ) then self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" is required!' else self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option is required!' endif case ( ERROR_CASTING_LOGICAL ) self % error_message = prefd // ': cannot convert \"' // log_value // '\" of option \"' // self % switch // '\" to logical type!' case ( ERROR_CHOICES_LOGICAL ) self % error_message = prefd // ': cannot use \"choices\" value check for option \"' // self % switch // & '\" it being of logical type! The choices are limited to \".true.\" or \".false.\" by definition!' case ( ERROR_NO_LIST ) if (. not . self % is_positional ) then self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" has not \"nargs\" value but an array has been passed to \"get\" method!' else self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( ERROR_NARGS_INSUFFICIENT ) if (. not . self % is_positional ) then if ( self % nargs == '+' ) then self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" requires at least 1 argument but no one remains!' else self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" requires ' // & trim ( adjustl ( self % nargs )) // ' arguments but no enough ones remain!' endif else if ( self % nargs == '+' ) then self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // & '-th\" positional option requires at least 1 argument but no one remains' else self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option requires ' // & trim ( adjustl ( self % nargs )) // ' arguments but no enough ones remain!' endif endif case ( ERROR_VALUE_MISSING ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" needs a value that is not passed!' case ( ERROR_UNKNOWN ) self % error_message = prefd // ': switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( ERROR_ENVVAR_POSITIONAL ) self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( ERROR_ENVVAR_NOT_STORE ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( ERROR_ENVVAR_NARGS ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( ERROR_STORE_STAR_POSITIONAL ) self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( ERROR_STORE_STAR_NARGS ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( ERROR_STORE_STAR_ENVVAR ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( ERROR_ACTION_UNKNOWN ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" has unknown \"' // self % act // '\" action!' case ( ERROR_DUPLICATED_CLAS ) self % error_message = prefd // ': switch \"' // trim ( adjustl ( switch )) // '\" has been passed more than once!' endselect call self % print_error_message endif endsubroutine errored subroutine check_envvar_consistency ( self , pref ) !< Check data consistency for envvar CLA. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if ( allocated ( self % envvar )) then if ( self % is_positional ) then call self % errored ( pref = pref , error = ERROR_ENVVAR_POSITIONAL ) return endif if (. not . allocated ( self % act )) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NOT_STORE ) return else if ( self % act /= action_store ) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NOT_STORE ) return endif endif if ( allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NARGS ) return endif endif endsubroutine check_envvar_consistency subroutine check_action_consistency ( self , pref ) !< Check CLA action consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if ( allocated ( self % act )) then if ( self % act == ACTION_STORE_STAR . and . self % is_positional ) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_POSITIONAL ) return endif if ( self % act == ACTION_STORE_STAR . and . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_NARGS ) return endif if ( self % act == ACTION_STORE_STAR . and . allocated ( self % envvar )) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_ENVVAR ) return endif if ( self % act /= ACTION_STORE . and . & self % act /= ACTION_STORE_STAR . and . & self % act /= ACTION_STORE_TRUE . and . & self % act /= ACTION_STORE_FALSE . and .& self % act /= ACTION_PRINT_HELP . and . & self % act /= ACTION_PRINT_VERS ) then call self % errored ( pref = pref , error = ERROR_ACTION_UNKNOWN ) return endif endif endsubroutine check_action_consistency subroutine check_optional_consistency ( self , pref ) !< Check optional CLA consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if ((. not . self % is_required ). and .(. not . allocated ( self % def ))) call self % errored ( pref = pref , error = ERROR_OPTIONAL_NO_DEF ) endsubroutine check_optional_consistency subroutine check_m_exclude_consistency ( self , pref ) !< Check mutually exclusion consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if (( self % is_required ). and .( self % m_exclude /= '' )) then call self % errored ( pref = pref , error = ERROR_REQUIRED_M_EXCLUDE ) return endif if (( self % is_positional ). and .( self % m_exclude /= '' )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_M_EXCLUDE ) return endif endsubroutine check_m_exclude_consistency subroutine check_named_consistency ( self , pref ) !< Check named CLA consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if ((. not . self % is_positional ). and .(. not . allocated ( self % switch ))) call self % errored ( pref = pref , error = ERROR_NAMED_NO_NAME ) endsubroutine check_named_consistency subroutine check_positional_consistency ( self , pref ) !< Check positional CLA consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if (( self % is_positional ). and .( self % position == 0_I4P )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_NO_POSITION ) return elseif (( self % is_positional ). and .( self % act /= action_store )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_NO_STORE ) endif endsubroutine check_positional_consistency subroutine check_choices ( self , val , pref ) !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. class ( * ), intent ( in ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( len ( self % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. val_in = . false . val_str = '' tmp = self % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #if defined _R16P type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo type is ( logical ) call self % errored ( pref = pref , error = ERROR_CHOICES_LOGICAL ) endselect if (. not . val_in . and .( self % error == 0 )) then call self % errored ( pref = pref , error = ERROR_NOT_IN_CHOICES , val_str = val_str ) endif endsubroutine check_choices function check_list_size ( self , Nv , val , pref ) result ( is_ok ) !< Check CLA multiple values list size consistency. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I4P ), intent ( in ) :: Nv !< Number of values. character ( * ), intent ( in ) :: val !< First value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical :: is_ok !< Check result. is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( self % nargs == '+' ) then call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endif endif endif endfunction check_list_size subroutine get_cla ( self , val , pref ) !< Get CLA (single) value. implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. if (. not . self % is_required_passed ( pref = pref )) return if ( self % act == action_store . or . self % act == action_store_star ) then if ( self % is_passed . and . allocated ( self % val )) then call self % get_cla_from_buffer ( buffer = self % val , val = val , pref = pref ) elseif ( allocated ( self % def )) then ! using default value call self % get_cla_from_buffer ( buffer = self % def , val = val , pref = pref ) endif if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val , pref = pref ) elseif ( self % act == action_store_true ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( self % def )) then select type ( val ) type is ( logical ) read ( self % def , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = self % def ) endselect endif elseif ( self % act == action_store_false ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( self % def )) then select type ( val ) type is ( logical ) read ( self % def , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = self % def ) endselect endif endif endsubroutine get_cla subroutine get_cla_from_buffer ( self , buffer , val , pref ) !< Get CLA (single) value from parsed value. implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), intent ( in ) :: buffer !< Buffer containing values (parsed or default CLA value). class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. select type ( val ) #if defined _R16P type is ( real ( R16P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I1P ) type is ( logical ) read ( buffer , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = buffer ) type is ( character ( * )) val = buffer endselect endsubroutine get_cla_from_buffer subroutine get_cla_list ( self , pref , val ) !< Get CLA multiple values. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. class ( * ), intent ( inout ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call self % get_cla_list_from_buffer ( buffer = self % val , val = val , pref = pref ) else ! using default value call self % get_cla_list_from_buffer ( buffer = self % def , val = val , pref = pref ) endif elseif ( self % act == action_store_true ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = self % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( self % act == action_store_false ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = self % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif endsubroutine get_cla_list subroutine get_cla_list_from_buffer ( self , buffer , val , pref ) !< Get CLA multiple values from a buffer. implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), intent ( in ) :: buffer !< Buffer containing values (parsed or default CLA value). class ( * ), intent ( inout ) :: val ( 1 :) !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( buffer )), allocatable :: vals (:) !< String array of values based on buffer value. integer ( I4P ) :: v !< Values counter. call tokenize ( strin = buffer , delimiter = args_sep , toks = vals , Nt = Nv ) select type ( val ) #if defined _R16P type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R16P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R8P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R4P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I8P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I4P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I2P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I1P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( vals ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = vals ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = vals ( v ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo endselect endsubroutine get_cla_list_from_buffer subroutine get_cla_list_varying_R16P ( self , val , pref ) !< Get CLA (multiple) value with varying size, real(R16P). class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R16P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( self % nargs == '+' ) then call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_R16P subroutine get_cla_list_varying_R8P ( self , val , pref ) !< Get CLA (multiple) value with varying size, real(R8P). class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_R8P subroutine get_cla_list_varying_R4P ( self , val , pref ) !< Get CLA (multiple) value with varying size, real(R4P). class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_R4P subroutine get_cla_list_varying_I8P ( self , val , pref ) !< Get CLA (multiple) value with varying size, integer(I8P). class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_I8P subroutine get_cla_list_varying_I4P ( self , val , pref ) !< Get CLA (multiple) value with varying size, integer(I4P). class ( command_line_argument ), intent ( INOUT ) :: self !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_I4P subroutine get_cla_list_varying_I2P ( self , val , pref ) !< Get CLA (multiple) value with varying size, integer(I2P). class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I2P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_I2P subroutine get_cla_list_varying_I1P ( self , val , pref ) !< Get CLA (multiple) value with varying size, integer(I1P). class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I1P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( self % error /= 0 ) exit enddo endif endif endsubroutine get_cla_list_varying_I1P subroutine get_cla_list_varying_logical ( self , val , pref ) !< Get CLA (multiple) value with varying size, logical. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. logical , allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = valsD ( v )) exit endif enddo endif endif endsubroutine get_cla_list_varying_logical subroutine get_cla_list_varying_char ( self , val , pref ) !< Get CLA (multiple) value with varying size, character. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif endsubroutine get_cla_list_varying_char elemental subroutine cla_assign_cla ( lhs , rhs ) !< Assignment operator. class ( command_line_argument ), intent ( inout ) :: lhs !< Left hand side. type ( command_line_argument ), intent ( in ) :: rhs !< Rigth hand side. ! object members call lhs % assign_object ( rhs ) ! command_line_argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % is_required = rhs % is_required lhs % is_positional = rhs % is_positional lhs % position = rhs % position lhs % is_passed = rhs % is_passed lhs % is_hidden = rhs % is_hidden endsubroutine cla_assign_cla elemental subroutine finalize ( self ) !< Free dynamic memory when finalizing. type ( command_line_argument ), intent ( inout ) :: self !< CLA data. call self % free endsubroutine finalize endmodule flap_command_line_argument_t","tags":"","loc":"sourcefile/flap_command_line_argument_t.f90.html"},{"title":"flap_utils_m.f90 – FLAP","text":"FLAP utils. Files dependent on this one sourcefile~~flap_utils_m.f90~~AfferentGraph sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_test_group.f90 flap_test_group.f90 sourcefile~flap_test_group.f90->sourcefile~flap.f90 sourcefile~flap_test_string.f90 flap_test_string.f90 sourcefile~flap_test_string.f90->sourcefile~flap.f90 sourcefile~flap_test_hidden.f90 flap_test_hidden.f90 sourcefile~flap_test_hidden.f90->sourcefile~flap.f90 sourcefile~flap_test_ansi_color_style.f90 flap_test_ansi_color_style.f90 sourcefile~flap_test_ansi_color_style.f90->sourcefile~flap.f90 sourcefile~flap_test_ignore_unknown_clas.f90 flap_test_ignore_unknown_clas.f90 sourcefile~flap_test_ignore_unknown_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_duplicated_clas.f90 flap_test_duplicated_clas.f90 sourcefile~flap_test_duplicated_clas.f90->sourcefile~flap.f90 sourcefile~flap_test_nargs_insufficient.f90 flap_test_nargs_insufficient.f90 sourcefile~flap_test_nargs_insufficient.f90->sourcefile~flap.f90 sourcefile~flap_test_minimal.f90 flap_test_minimal.f90 sourcefile~flap_test_minimal.f90->sourcefile~flap.f90 sourcefile~flap_test_group_examples.f90 flap_test_group_examples.f90 sourcefile~flap_test_group_examples.f90->sourcefile~flap.f90 sourcefile~flap_test_value_missing.f90 flap_test_value_missing.f90 sourcefile~flap_test_value_missing.f90->sourcefile~flap.f90 sourcefile~flap_test_save_usage_to_markdown.f90 flap_test_save_usage_to_markdown.f90 sourcefile~flap_test_save_usage_to_markdown.f90->sourcefile~flap.f90 sourcefile~flap_test_save_man_page.f90 flap_test_save_man_page.f90 sourcefile~flap_test_save_man_page.f90->sourcefile~flap.f90 sourcefile~flap_test_save_bash_completion.f90 flap_test_save_bash_completion.f90 sourcefile~flap_test_save_bash_completion.f90->sourcefile~flap.f90 sourcefile~flap_test_choices_logical.f90 flap_test_choices_logical.f90 sourcefile~flap_test_choices_logical.f90->sourcefile~flap.f90 sourcefile~flap_test_basic.f90 flap_test_basic.f90 sourcefile~flap_test_basic.f90->sourcefile~flap.f90 sourcefile~flap_test_nested.f90 flap_test_nested.f90 sourcefile~flap_test_nested.f90->sourcefile~flap.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules flap_utils_m Source Code flap_utils_m.f90 Source Code !< FLAP utils. module flap_utils_m !< FLAP utils. use penf implicit none private public :: count public :: replace public :: replace_all public :: tokenize public :: unique public :: upper_case public :: wstrip interface count !< Overload intrinsic function count for counting substring occurences into strings. module procedure count_substring endinterface contains elemental function count_substring ( string , substring ) result ( No ) !< Count the number of occurences of a substring into a string. character ( * ), intent ( in ) :: string !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. No = 0 if ( len ( substring ) > len ( string )) return c1 = 1 do c2 = index ( string = string ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo endfunction count_substring pure function replace ( string , substring , restring ) result ( newstring ) !< Replace substring (only first occurrence) into a string. character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len =* ), intent ( in ) :: substring !< Substring to be replaced. character ( len =* ), intent ( in ) :: restring !< String to be inserted. character ( len = :), allocatable :: newstring !< New modified string. integer ( I4P ) :: pos !< Position from which replace the substring. pos = index ( string = string , substring = substring ) newstring = string if ( pos > 0 ) then if ( pos == 1 ) then newstring = restring // string ( len ( substring ) + 1 :) else newstring = string ( 1 : pos - 1 ) // restring // string ( pos + len ( substring ):) endif endif endfunction replace pure function replace_all ( string , substring , restring ) result ( newstring ) !< Replace substring (all occurrences) into a string. !< !< @note Leading and trailing white spaces are stripped out. character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len =* ), intent ( in ) :: substring !< Substring to be replaced. character ( len =* ), intent ( in ) :: restring !< String to be inserted. character ( len = :), allocatable :: newstring !< New modified string. newstring = wstrip ( string ) do if ( index ( newstring , substring ) > 0 ) then newstring = replace ( string = newstring , substring = substring , restring = restring ) else exit endif enddo endfunction replace_all pure subroutine tokenize ( strin , delimiter , toks , Nt ) !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to input string. character ( len =* ), intent ( in ) :: strin !< String to be tokenized. character ( len =* ), intent ( in ) :: delimiter !< Delimiter of tokens. character ( len = len ( strin )), intent ( out ), allocatable :: toks (:) !< Tokens. integer ( I4P ), intent ( out ), optional :: Nt !< Number of tokens. character ( len = len ( strin )) :: strsub !< Temporary string. integer ( I4P ) :: dlen !< Delimiter length. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: n !< Counter. integer ( I4P ) :: t !< Counter. ! initialization if ( allocated ( toks )) deallocate ( toks ) strsub = strin dlen = len ( delimiter ) if ( dlen > len ( strin )) then allocate ( toks ( 1 : 1 )) ; toks ( 1 ) = strin ; if ( present ( Nt )) Nt = 1 ; return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenization do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n endsubroutine tokenize elemental function unique ( string , substring ) result ( uniq ) !< Reduce to one (unique) multiple (sequential) occurrences of a characters substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. character ( len =* ), intent ( in ) :: string !< String to be parsed. character ( len =* ), intent ( in ) :: substring !< Substring which multiple occurences must be reduced to one. character ( len = len ( string )) :: uniq !< String parsed. integer ( I4P ) :: Lsub !< Lenght of substring. integer ( I4P ) :: c1 !< Counter. integer ( I4P ) :: c2 !< Counter. uniq = string Lsub = len ( substring ) if ( Lsub > len ( string )) return c1 = 1 Loop1 : do if ( c1 >= len_trim ( uniq )) exit Loop1 if ( uniq ( c1 : c1 + Lsub - 1 ) == substring . and . uniq ( c1 + Lsub : c1 + 2 * Lsub - 1 ) == substring ) then c2 = c1 + Lsub Loop2 : do if ( c2 >= len_trim ( uniq )) exit Loop2 if ( uniq ( c2 : c2 + Lsub - 1 ) == substring ) then c2 = c2 + Lsub else exit Loop2 endif enddo Loop2 uniq = uniq ( 1 : c1 ) // uniq ( c2 :) else c1 = c1 + Lsub endif enddo Loop1 endfunction unique elemental function upper_case ( string ) !< Convert the lower case characters of a string to upper case one. character ( len =* ), intent ( in ) :: string !< String to be converted. character ( len = len ( string )) :: upper_case !< Converted string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. character ( len = 26 ), parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( len = 26 ), parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. upper_case = string do n1 = 1 , len ( string ) n2 = index ( lower_alphabet , string ( n1 : n1 )) if ( n2 > 0 ) upper_case ( n1 : n1 ) = upper_alphabet ( n2 : n2 ) enddo endfunction upper_case pure function wstrip ( string ) result ( newstring ) !< Strip out leading and trailing white spaces from a string. character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len = :), allocatable :: newstring !< New modified string. allocate ( newstring , source = trim ( adjustl ( string ))) endfunction wstrip endmodule flap_utils_m","tags":"","loc":"sourcefile/flap_utils_m.f90.html"}]}