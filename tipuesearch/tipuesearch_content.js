var tipuesearch = {"pages":[{"text":"BeFoR64 BeFoR64 BeFoR64, Base64 encoding/decoding library for FoRtran poor people BeFoR64 is a pure Fortran (KISS) library for base64 encoding/decoding for modern (2003+) Fortran projects; BeFoR64 is Fortran 2003+ standard compliant; BeFoR64 is a Free, Open Source Project. Table of Contents What is BeFoR64? Main features Copyrights Documentation A Taste of BeFoR64 Issues Compiler Support -brightgreen.svg) -brightgreen.svg) What is BeFoR64? Modern Fortran standards (2003+) have introduced better support for strings manipulations. Exploiting such new Fortran capabilities, BeFoR64 provides an easy to use module library for encoding and decoding Fortran types (binary internal representation) in ascii- base64 -encoded string. Go to Top Main features User-friendly methods for encoding/decoding in base64: encode real/integer scalar variables; decode real/integer scalar variables; encode real/integer array variables; decode real/integer array variables; encode character scalar variables; decode character scalar variables; encode character array variables; decode character array variables; encode unlimited polymorphic scalar variables; decode unlimited polymorphic scalar variables; encode unlimited polymorphic array variables; decode unlimited polymorphic array variables; user-friendly methods for packing heterogeneous data: pack integer/integer (different kinds) scalars; pack integer/integer (different kinds) arrays; pack real/real (different kinds) scalars; pack real/real (different kinds) arrays; pack integer/real scalars; pack integer/real arrays; errors trapping mechanism. Any feature request is welcome. Go to Top Copyrights BeFoR64 is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to BeFoR64 is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the BeFoR64 documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of BeFoR64 Let us assume our goal is encoding a binary integer. It is as simple as USE Lib_Base64 ... character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = 1 2._R8P , code = code64 ) print \"(A)\" , code64 But you are not limited to a simple integer scalar, you can encode real, integer, characters scalar or arrays, and by means of the auxiliary Lib_Pack library also mixed types. See the wiki . Go to Top ChangeLog Change Log Unreleased Full Changelog Closed issues: Pure/Elemental with unlimited polymorphic #8 v1.0.3 (2015-06-08) Full Changelog Closed issues: Unlimited polymorphic encoding/decoding #5 Characters encoding/decoding #4 Wiki Exploiting #3 Documentation improvement #2 v1.0.2 (2015-02-12) Full Changelog v1.0.1 (2015-02-03) Full Changelog Closed issues: Decoders implementing #1 v1.0.0 (2015-02-02) Full Changelog v0.1.1 (2015-01-29) Full Changelog v0.0.1 (2015-01-27) * *This Change Log was automatically generated by github_changelog_generator Developer Info Stefano Zaghi","tags":"home","loc":"index.html","title":" BeFoR64 "},{"text":"Procedures Procedure Location Procedure Type Description autotest Lib_Base64 Subroutine Procedure for autotesting the library functionalities. b64_decode Lib_Base64 Interface Procedure for decoding numbers (integer and real) from base64. b64_decode_I1 Lib_Base64 Subroutine Procedure for decoding a base64 code into a scalar number (I1P). b64_decode_I1_a Lib_Base64 Subroutine Procedure for decoding a base64 code into an array numbers (I1P). b64_decode_I2 Lib_Base64 Subroutine Procedure for decoding a base64 code into a scalar number (I2P). b64_decode_I2_a Lib_Base64 Subroutine Procedure for decoding a base64 code into an array numbers (I2P). b64_decode_I4 Lib_Base64 Subroutine Procedure for decoding a base64 code into a scalar number (I4P). b64_decode_I4_a Lib_Base64 Subroutine Procedure for decoding a base64 code into an array numbers (I4P). b64_decode_I8 Lib_Base64 Subroutine Procedure for decoding a base64 code into a scalar number (I8P). b64_decode_I8_a Lib_Base64 Subroutine Procedure for decoding a base64 code into an array numbers (I8P). b64_decode_R16 Lib_Base64 Subroutine Procedure for decoding a base64 code into a scalar number (R16P). b64_decode_R16_a Lib_Base64 Subroutine Procedure for decoding a base64 code into an array numbers (R16P). b64_decode_R4 Lib_Base64 Subroutine Procedure for decoding a base64 code into a scalar number (R4P). b64_decode_R4_a Lib_Base64 Subroutine Procedure for decoding a base64 code into an array numbers (R4P). b64_decode_R8 Lib_Base64 Subroutine Procedure for decoding a base64 code into a scalar number (R8P). b64_decode_R8_a Lib_Base64 Subroutine Procedure for decoding a base64 code into an array numbers (R8P). b64_decode_string Lib_Base64 Subroutine Procedure for decoding a base64 code into a scalar string. b64_decode_string_a Lib_Base64 Subroutine Procedure for decoding a base64 code into an array of strings. b64_decode_up Lib_Base64 Subroutine Procedure for decoding an unlimited polymorphic scalar from base64. b64_decode_up Lib_Base64 Interface Procedure for decoding unlimited polymorphic variable from base64. b64_decode_up_a Lib_Base64 Subroutine Procedure for decoding an unlimited polymorphic array from base64. b64_encode Lib_Base64 Interface Procedure for encoding numbers (integer and real) to base64. b64_encode_I1 Lib_Base64 Subroutine Procedure for encoding scalar number to base64 (I1P). b64_encode_I1_a Lib_Base64 Subroutine Procedure for encoding array numbers to base64 (I1P). b64_encode_I2 Lib_Base64 Subroutine Procedure for encoding scalar number to base64 (I2P). b64_encode_I2_a Lib_Base64 Subroutine Procedure for encoding array numbers to base64 (I2P). b64_encode_I4 Lib_Base64 Subroutine Procedure for encoding scalar number to base64 (I4P). b64_encode_I4_a Lib_Base64 Subroutine Procedure for encoding array numbers to base64 (I4P). b64_encode_I8 Lib_Base64 Subroutine Procedure for encoding scalar number to base64 (I8P). b64_encode_I8_a Lib_Base64 Subroutine Procedure for encoding array numbers to base64 (I8P). b64_encode_R16 Lib_Base64 Subroutine Procedure for encoding scalar number to base64 (R16P). b64_encode_R16_a Lib_Base64 Subroutine Procedure for encoding array numbers to base64 (R16P). b64_encode_R4 Lib_Base64 Subroutine Procedure for encoding scalar number to base64 (R4P). b64_encode_R4_a Lib_Base64 Subroutine Procedure for encoding array numbers to base64 (R4P). b64_encode_R8 Lib_Base64 Subroutine Procedure for encoding scalar number to base64 (R8P). b64_encode_R8_a Lib_Base64 Subroutine Procedure for encoding array numbers to base64 (R8P). b64_encode_string Lib_Base64 Subroutine Procedure for encoding scalar string to base64. b64_encode_string_a Lib_Base64 Subroutine Procedure for encoding array string to base64. b64_encode_up Lib_Base64 Subroutine Procedure for encoding an unlimited polymorphic scalar to base64. b64_encode_up Lib_Base64 Interface Procedure for encoding unlimited polymorphic variable to base64. b64_encode_up_a Lib_Base64 Subroutine Procedure for encoding an unlimited polymorphic array to base64. b64_init Lib_Base64 Subroutine Procedure for initializing the BeFoR64 library. bctoi_I1P IR_Precision Function Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. bctoi_I2P IR_Precision Function Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. bctoi_I4P IR_Precision Function Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. bctoi_I8P IR_Precision Function Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. bcton IR_Precision Interface Procedure for converting bit-string to number, real or initeger, (bit-string to number type casting). bctor_R4P IR_Precision Function Procedure for converting bit-string to real. This function achieves casting of bit-string to real. bctor_R8P IR_Precision Function Procedure for converting bit-string to real. This function achieves casting of bit-string to real. bit_size IR_Precision Interface Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. bit_size_chr IR_Precision Function Procedure for computing the number of bits of a character variable. bit_size_R16P IR_Precision Function Procedure for computing the number of bits of a real variable. bit_size_R4P IR_Precision Function Procedure for computing the number of bits of a real variable. bit_size_R8P IR_Precision Function Procedure for computing the number of bits of a real variable. bstr IR_Precision Interface Procedure for converting number, real and integer, to bit-string (number to bit-string type casting). bstr_I1P IR_Precision Function Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. bstr_I2P IR_Precision Function Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. bstr_I4P IR_Precision Function Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. bstr_I8P IR_Precision Function Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. bstr_R16P IR_Precision Function Procedure for converting real to string of bits. This function achieves casting of real to bit-string. bstr_R4P IR_Precision Function Procedure for converting real to string of bits. This function achieves casting of real to bit-string. bstr_R8P IR_Precision Function Procedure for converting real to string of bits. This function achieves casting of real to bit-string. byte_size IR_Precision Interface Overloading of the byte_size function for computing the number of bytes. byte_size_chr IR_Precision Function Procedure for computing the number of bytes of a character variable. byte_size_I1P IR_Precision Function Procedure for computing the number of bytes of an integer variable. byte_size_I2P IR_Precision Function Procedure for computing the number of bytes of an integer variable. byte_size_I4P IR_Precision Function Procedure for computing the number of bytes of an integer variable. byte_size_I8P IR_Precision Function Procedure for computing the number of bytes of an integer variable. byte_size_R16P IR_Precision Function Procedure for computing the number of bytes of a real variable. byte_size_R4P IR_Precision Function Procedure for computing the number of bytes of a real variable. byte_size_R8P IR_Precision Function Procedure for computing the number of bytes of a real variable. check_endian IR_Precision Subroutine Subroutine for checking the type of bit ordering (big or little endian) of the running architecture. ctoi_I1P IR_Precision Function Procedure for converting string to integer. This function achieves casting of string to integer. ctoi_I2P IR_Precision Function Procedure for converting string to integer. This function achieves casting of string to integer. ctoi_I4P IR_Precision Function Procedure for converting string to integer. This function achieves casting of string to integer. ctoi_I8P IR_Precision Function Procedure for converting string to integer. This function achieves casting of string to integer. cton IR_Precision Interface Procedure for converting string to number, real or initeger, (string to number type casting). ctor_R16P IR_Precision Function Procedure for converting string to real. This function achieves casting of string to real. ctor_R4P IR_Precision Function Procedure for converting string to real. This function achieves casting of string to real. ctor_R8P IR_Precision Function Procedure for converting string to real. This function achieves casting of string to real. decode_bits Lib_Base64 Subroutine Procedure for decoding a base64 string into a sequence of bits stream. digit IR_Precision Interface Procedure for computing the number of digits in decimal base of the input integer. digit_I1 IR_Precision Function Procedure for computing the number of digits in decimal base of the input integer. digit_I2 IR_Precision Function Procedure for computing the number of digits in decimal base of the input integer. digit_I4 IR_Precision Function Procedure for computing the number of digits in decimal base of the input integer. digit_I8 IR_Precision Function Procedure for computing the number of digits in decimal base of the input integer. encode_bits Lib_Base64 Subroutine Procedure for encoding a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). IR_init IR_Precision Subroutine Procedure for initilizing module's variables that are not initialized into the definition specification. IR_Print IR_Precision Subroutine Procedure for printing to the standard output the kind definition of reals and integers and the utility variables. is_little_endian IR_Precision Function Procedure for checking if the type of the bit ordering of the running architecture is little endian. pack_data Lib_Pack_Data Interface Procedure for packing different kinds of data into single I1P array. pack_data_I1_I2 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I1_I4 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I1_I8 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I1_R4 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I1_R8 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I2_I1 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I2_I4 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I2_I8 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I2_R4 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I2_R8 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I4_I1 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I4_I2 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I4_I8 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I4_R4 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I4_R8 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I8_I1 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I8_I2 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I8_I4 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I8_R4 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_I8_R8 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_R4_I1 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_R4_I2 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_R4_I4 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_R4_I8 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_R4_R8 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_R8_I1 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_R8_I2 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_R8_I4 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_R8_I8 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. pack_data_R8_R4 Lib_Pack_Data Subroutine Procedure for packing different kinds of data into single I1P array. str IR_Precision Interface Procedure for converting number, real and integer, to string (number to string type casting). str_a_I1P IR_Precision Function Procedure for converting integer (array) to string. This function achieves casting of integer to string. str_a_I2P IR_Precision Function Procedure for converting integer (array) to string. This function achieves casting of integer to string. str_a_I4P IR_Precision Function Procedure for converting integer (array) to string. This function achieves casting of integer to string. str_a_I8P IR_Precision Function Procedure for converting integer (array) to string. This function achieves casting of integer to string. str_a_R16P IR_Precision Function Procedure for converting real (array) to string. This function achieves casting of real to string. str_a_R4P IR_Precision Function Procedure for converting real (array) to string. This function achieves casting of real to string. str_a_R8P IR_Precision Function Procedure for converting real (array) to string. This function achieves casting of real to string. str_bol IR_Precision Function Procedure for converting logical to string. This function achieves casting of logical to string. str_I1P IR_Precision Function Procedure for converting integer to string. This function achieves casting of integer to string. str_I2P IR_Precision Function Procedure for converting integer to string. This function achieves casting of integer to string. str_I4P IR_Precision Function Procedure for converting integer to string. This function achieves casting of integer to string. str_I8P IR_Precision Function Procedure for converting integer to string. This function achieves casting of integer to string. str_R16P IR_Precision Function Procedure for converting real to string. This function achieves casting of real to string. str_R4P IR_Precision Function Procedure for converting real to string. This function achieves casting of real to string. str_R8P IR_Precision Function Procedure for converting real to string. This function achieves casting of real to string. strf_I1P IR_Precision Function Procedure for converting integer to string. This function achieves casting of integer to string. strf_I2P IR_Precision Function Procedure for converting integer to string. This function achieves casting of integer to string. strf_I4P IR_Precision Function Procedure for converting integer to string. This function achieves casting of integer to string. strf_I8P IR_Precision Function Procedure for converting integer to string. This function achieves casting of integer to string. strf_R16P IR_Precision Function Procedure for converting real to string. This function achieves casting of real to string. strf_R4P IR_Precision Function Procedure for converting real to string. This function achieves casting of real to string. strf_R8P IR_Precision Function Procedure for converting real to string. This function achieves casting of real to string. strz IR_Precision Interface Procedure for converting number, integer, to string, prefixing with the right number of zeros (number to string type\n casting with zero padding). strz_I1P IR_Precision Function Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. strz_I2P IR_Precision Function Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. strz_I4P IR_Precision Function Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. strz_I8P IR_Precision Function Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string.","tags":"list procedures","loc":"lists/procedures.html","title":"\nAll Procedures – BeFoR64\n"},{"text":"Source Files File Description IR_Precision.f90 Pure Fortran (2003+) library for ensuring codes portability Lib_Base64.f90 BeFoR64, Base64 encoding/decoding library for FoRtran poor men Lib_Pack_Data.f90 KISS library for packing heterogeneous data into single (homogeneous) packed one Test_Driver.f90 Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men","tags":"list files","loc":"lists/files.html","title":"\nAll Files – BeFoR64\n"},{"text":"Modules Module Source File Description IR_Precision IR_Precision.f90 Pure Fortran (2003+) library for ensuring codes portability Lib_Base64 Lib_Base64.f90 BeFoR64, Base64 encoding/decoding library for FoRtran poor men Lib_Pack_Data Lib_Pack_Data.f90 KISS library for packing heterogeneous data into single (homogeneous) packed one","tags":"list modules","loc":"lists/modules.html","title":"\nAll Modules – BeFoR64\n"},{"text":"Lib_Pack_Data.f90 Source File Source File Lib_Pack_Data.f90 Modules Lib_Pack_Data All Source Files IR_Precision.f90 Lib_Base64.f90 Lib_Pack_Data.f90 Test_Driver.f90 KISS library for packing heterogeneous data into single (homogeneous) packed one !< KISS library for packing heterogeneous data into single (homogeneous) packed one module Lib_Pack_Data !----------------------------------------------------------------------------------------------------------------------------------- !< KISS library for packing heterogeneous data into single (homogeneous) packed one !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: pack_data !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface pack_data !< Procedure for packing different kinds of data into single I1P array. !< !< This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. !< @note This procedure exploits the `transfer` builtin function, that from the standard (2003+) is defined as !< `TRANSFER(SOURCE, MOLD [, SIZE])`. Data object having a physical representation identical to that of `SOURCE` but with the type !< and type parameters of `MOLD`. The result is of the same type and type parameters as `MOLD`. !< If `MOLD` is an array and `SIZE` is absent, the result is an array and of rank one. Its size is as small as possible such !< that its physical representation is not shorter than that of `SOURCE`. !< !< Presently, the following combinations are available: !< !<* [ ] Arrays-Arrays: !<    * [X] real(any)-real(any); !<    * [X] real(any)-integer(any); !<    * [X] integer(any)-integer(any); !<    * [X] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !<* [ ] Scalars-Scalars: !<    * [ ] real(any)-real(any); !<    * [ ] real(any)-integer(any); !<    * [ ] integer(any)-integer(any); !<    * [ ] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !< !<### Examples of usage !< !<#### Packing two real arrays, one with kind R8P and one with R4P !<```fortran !<real(R8P)::                 array_r8(1:12) !<real(R4P)::                 array_r4(-1:5) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r8,a2=array_r4,packed=rpack) !<``` !<#### Packing two arrays, one real with kind R4P and one integer with I4P !<```fortran !<real(R4P)::                 array_r4(2) !<integer(I4P)::              array_i4(0:2) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r4,a2=array_i4,packed=rpack) !<``` module procedure pack_data_R8_R4 , pack_data_R8_I8 , pack_data_R8_I4 , pack_data_R8_I2 , pack_data_R8_I1 , & pack_data_R4_R8 , pack_data_R4_I8 , pack_data_R4_I4 , pack_data_R4_I2 , pack_data_R4_I1 , & pack_data_I8_R8 , pack_data_I8_R4 , pack_data_I8_I4 , pack_data_I8_I2 , pack_data_I8_I1 , & pack_data_I4_R8 , pack_data_I4_R4 , pack_data_I4_I8 , pack_data_I4_I2 , pack_data_I4_I1 , & pack_data_I2_R8 , pack_data_I2_R4 , pack_data_I2_I8 , pack_data_I2_I4 , pack_data_I2_I1 , & pack_data_I1_R8 , pack_data_I1_R4 , pack_data_I1_I8 , pack_data_I1_I4 , pack_data_I1_I2 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_R4 pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I8 pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I4 pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I2 pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I1 pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_R8 pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I8 pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I4 pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I2 pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I1 pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R8 pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R4 pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I4 pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I2 pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I1 pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R8 pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R4 pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I8 pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I2 pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I1 pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R8 pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R4 pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I8 pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I4 pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I1 pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R8 pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R4 pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I8 pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I4 !> @brief Subroutine for packing different kinds of data into single I1P array. pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I2 endmodule Lib_Pack_Data © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"sourcefile/lib_pack_data.f90.html","title":"Lib_Pack_Data.f90 – BeFoR64"},{"text":"IR_Precision.f90 Source File Source File IR_Precision.f90 Modules IR_Precision All Source Files IR_Precision.f90 Lib_Base64.f90 Lib_Pack_Data.f90 Test_Driver.f90 Pure Fortran (2003+) library for ensuring codes portability !< Pure Fortran (2003+) library for ensuring codes portability module IR_Precision !----------------------------------------------------------------------------------------------------------------------------------- !< Pure Fortran (2003+) library for ensuring codes portability !<{!README-IR_Precision.md!} !< !<### ChangeLog !< !<{!ChangeLog-IR_Precision.md!} !----------------------------------------------------------------------------------------------------------------------------------- USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT ! Standard output/error logical units. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: endianL , endianB , endian public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: NRknd , RPl , FRl public :: NIknd , RIl , FIl public :: check_endian public :: bit_size , byte_size public :: str , strz , cton , bstr , bcton public :: digit public :: ir_initialized , IR_Init public :: IR_Print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: ir_initialized = . false . !< Flag for chcecking the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). ! The following are the portable kind parameters available. ! Real precision definitions: #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. ! Integer precision definitions: integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. ! Format parameters useful for writing in a well-ascii-format numeric variables. ! Real output formats: character ( 10 ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P variable. character ( 10 ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P variable. character ( 9 ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P variable. character ( 10 ), parameter :: FR_P = FR8P !< Output format for kind=R_P variable. ! Real number of digits of output formats: integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. ! Integer output formats: character ( 5 ), parameter :: FI8P = '(I20)' !< Output format                     for kind=I8P variable. character ( 8 ), parameter :: FI8PZP = '(I20.19)' !< Output format with zero prefixing for kind=I8P variable. character ( 5 ), parameter :: FI4P = '(I11)' !< Output format                     for kind=I4P variable. character ( 8 ), parameter :: FI4PZP = '(I11.10)' !< Output format with zero prefixing for kind=I4P variable. character ( 4 ), parameter :: FI2P = '(I6)' !< Output format                     for kind=I2P variable. character ( 6 ), parameter :: FI2PZP = '(I6.5)' !< Output format with zero prefixing for kind=I2P variable. character ( 4 ), parameter :: FI1P = '(I4)' !< Output format                     for kind=I1P variable. character ( 6 ), parameter :: FI1PZP = '(I4.3)' !< Output format with zero prefixing for kind=I1P variable. character ( 5 ), parameter :: FI_P = FI4P !< Output format                     for kind=I_P variable. character ( 8 ), parameter :: FI_PZP = FI4PZP !< Output format with zero prefixing for kind=I_P variable. ! Integer number of digits of output formats: integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. ! List of kinds integer , parameter :: NRknd = 4 !< Number of defined real kinds. integer , parameter :: RPl ( 1 : NRknd ) = [ R16P , R8P , R4P , R_P ] !< List of defined real kinds. character ( 10 ), parameter :: FRl ( 1 : NRknd ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of defined real kinds output format. integer , parameter :: NIknd = 5 !< Number of defined integer kinds. integer , parameter :: RIl ( 1 : NIknd ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of defined integer kinds. character ( 5 ), parameter :: FIl ( 1 : NIknd ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of defined integer kinds output format. ! Useful parameters for handling numbers ranges. ! Real min and max values: real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P variable. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P variable. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P variable. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P variable. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P variable. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P variable. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P variable. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P variable. ! Real number of bits/bytes integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P variable. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P variable. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P variable. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P variable. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P variable. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P variable. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P variable. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P variable. ! Real smallest values: real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest (module) representable value of kind=R16P variable. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest (module) representable value of kind=R8P variable. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest (module) representable value of kind=R4P variable. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest (module) representable value of kind=R_P variable. ! Integer min and max values: integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P variable. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P variable. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P variable. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P variable. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P variable. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P variable. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P variable. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P variable. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P variable. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P variable. ! Integer number of bits/bytes: integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P variable. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P variable. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P variable. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P variable. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P variable. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P variable. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P variable. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P variable. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P variable. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P variable. ! Smallest real representable difference by the running calculator. real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P variable. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P variable. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P variable. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P variable. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16p , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface interface byte_size !< Overloading of the *byte_size* function for computing the number of bytes. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface interface str !< Procedure for converting number, real and integer, to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P ,& #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P ,& #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface interface strz !< Procedure for converting number, integer, to string, prefixing with the right number of zeros (number to string type !< casting with zero padding). module procedure strz_I8P , & strz_I4P , & strz_I2P , & strz_I1P endinterface interface cton !< Procedure for converting string to number, real or initeger, (string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface interface bstr !< Procedure for converting number, real and integer, to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P ,& #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface interface bcton !< Procedure for converting bit-string to number, real or initeger, (bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface interface digit !< Procedure for computing the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for checking if the type of the bit ordering of the running architecture is little endian. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Subroutine for checking the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_endian elemental function bit_size_R16P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R16P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( c ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: c !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( c , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R16P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( c ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: c !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( c ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( IN ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R16P ), intent ( IN ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting logical to string. This function achieves casting of logical to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R16P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R8P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R4P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I8P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I4P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I2P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I1P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P elemental function strz_I8P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R16P ), intent ( IN ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R8P ), intent ( IN ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R4P ), intent ( IN ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I8P ), intent ( IN ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I4P ), intent ( IN ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I2P ), intent ( IN ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I1P ), intent ( IN ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to real. This function achieves casting of bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. real ( R8P ), intent ( IN ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to real. This function achieves casting of bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. real ( R4P ), intent ( IN ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I8P ), intent ( IN ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I4P ), intent ( IN ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I2P ), intent ( IN ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I1P ), intent ( IN ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine IR_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for initilizing module's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! checking the bit ordering architecture call check_endian ! computing the bits/bytes sizes of real variables BIR8P = bit_size ( r = MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( r = MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( r = MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( r = MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif ir_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine IR_init subroutine IR_Print ( pref , iostat , iomsg , unit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for printing to the standard output the kind definition of reals and integers and the utility variables. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . ir_initialized ) call IR_init prefd = '' ; if ( present ( pref )) prefd = pref ! printing informations if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str (. true ., ZeroR16 ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str (. true ., ZeroR8 ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str (. true ., ZeroR4 ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine IR_Print endmodule IR_Precision © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"sourcefile/ir_precision.f90.html","title":"IR_Precision.f90 – BeFoR64"},{"text":"Test_Driver.f90 Source File Source File Test_Driver.f90 Programs Test_Driver All Source Files IR_Precision.f90 Lib_Base64.f90 Lib_Pack_Data.f90 Test_Driver.f90 Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men !< Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men program Test_Driver !----------------------------------------------------------------------------------------------------------------------------------- !< Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men !< !<### Usage !<```bash !< ./Test_Driver !<``` !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Base64 , only : autotest ! Autotesting procedure. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Testing BeFoR64' call autotest stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"sourcefile/test_driver.f90.html","title":"Test_Driver.f90 – BeFoR64"},{"text":"Lib_Base64.f90 Source File Source File Lib_Base64.f90 Modules Lib_Base64 All Source Files IR_Precision.f90 Lib_Base64.f90 Lib_Pack_Data.f90 Test_Driver.f90 BeFoR64, Base64 encoding/decoding library for FoRtran poor men !< BeFoR64, Base64 encoding/decoding library for FoRtran poor men module Lib_Base64 !----------------------------------------------------------------------------------------------------------------------------------- !< BeFoR64, Base64 encoding/decoding library for FoRtran poor men !<{!README-BeFoR64.md!} !< !<### ChangeLog !< !<{!ChangeLog-BeFoR64.md!} !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Pack_Data ! Library for packing heterogeneous data into single (homogeneous) packed one. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: b64_encode , b64_encode_up public :: b64_decode , b64_decode_up public :: pack_data public :: b64_initialized , b64_init public :: autotest !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: b64_initialized = . false . !< Flag for chcecking the initialization of the library. character ( 64 ) :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" !< Base64 alphabet. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface b64_encode !< Procedure for encoding numbers (integer and real) to base64. !< !< This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both !< scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef r16p b64_encode_R16 , b64_encode_R16_a , & #endif b64_encode_R8 , b64_encode_R8_a , & b64_encode_R4 , b64_encode_R4_a , & b64_encode_I8 , b64_encode_I8_a , & b64_encode_I4 , b64_encode_I4_a , & b64_encode_I2 , b64_encode_I2_a , & b64_encode_I1 , b64_encode_I1_a , & b64_encode_string , b64_encode_string_a endinterface interface b64_encode_up !< Procedure for encoding unlimited polymorphic variable to base64. !< !< This is an interface for encoding both scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_encode_up , b64_encode_up_a endinterface interface b64_decode !< Procedure for decoding numbers (integer and real) from base64. !< !< This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both !< scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```fortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode(code='AAAAAAAA8D8=',n=decoded) !<``` !< !<#### Array decoding !<```fortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',n=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef r16p b64_decode_R16 , b64_decode_R16_a , & #endif b64_decode_R8 , b64_decode_R8_a , & b64_decode_R4 , b64_decode_R4_a , & b64_decode_I8 , b64_decode_I8_a , & b64_decode_I4 , b64_decode_I4_a , & b64_decode_I2 , b64_decode_I2_a , & b64_decode_I1 , b64_decode_I1_a , & b64_decode_string , b64_decode_string_a endinterface interface b64_decode_up !< Procedure for decoding unlimited polymorphic variable from base64. !< !< This is an interface for decoding both scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```fortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode_up(code='AAAAAAAA8D8=',up=decoded) !<``` !< !<#### Array decoding !<```fortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode_up(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',up=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_decode_up , b64_decode_up_a endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine b64_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for initializing the BeFoR64 library. !< !< @note This procedure **must** be called before encoding/decoding anything! !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . ir_initialized ) call IR_Init b64_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_init pure subroutine encode_bits ( bits , padd , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). !< !< The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) !<``` !< +--first octet--+-second octet--+--third octet--+ !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0| !< +-----------+---+-------+-------+---+-----------+ !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0| !< +--1.index--+--2.index--+--3.index--+--4.index--+ !<``` !< @note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. !< !< @note The number of paddings must be computed outside this procedure, into the calling scope. !< !< @warning This procedure is the backend of encoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: bits ( 1 :) !< Bits to be encoded. integer ( I4P ), intent ( IN ) :: padd !< Number of padding characters ('='). character ( * ), intent ( OUT ) :: code !< Characters code. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) c = 1_I8P do e = 1_I8P , Nb , 3_I8P ! loop over array elements: 3 bytes (24 bits) scanning sixb = 0_I1P call mvbits ( bits ( e ), 2 , 6 , sixb ( 1 ), 0 ) call mvbits ( bits ( e ), 0 , 2 , sixb ( 2 ), 4 ) if ( e + 1 <= Nb ) then call mvbits ( bits ( e + 1 ), 4 , 4 , sixb ( 2 ), 0 ) call mvbits ( bits ( e + 1 ), 0 , 4 , sixb ( 3 ), 2 ) endif if ( e + 2 <= Nb ) then call mvbits ( bits ( e + 2 ), 6 , 2 , sixb ( 3 ), 0 ) call mvbits ( bits ( e + 2 ), 0 , 6 , sixb ( 4 ), 0 ) endif sixb = sixb + 1_I1P code ( c : c ) = base64 ( sixb ( 1 ): sixb ( 1 )) code ( c + 1 : c + 1 ) = base64 ( sixb ( 2 ): sixb ( 2 )) code ( c + 2 : c + 2 ) = base64 ( sixb ( 3 ): sixb ( 3 )) code ( c + 3 : c + 3 ) = base64 ( sixb ( 4 ): sixb ( 4 )) c = c + 4_I8P enddo if ( padd > 0 ) code ( len ( code ) - padd + 1 :) = repeat ( '=' , padd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine encode_bits pure subroutine decode_bits ( code , bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 string into a sequence of bits stream. !< !< The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code !< `QUJD` the decoding process must do !<``` !< +-b64 char--+-b64 char--+-b64 char--+-b64 char--+ !< |      Q    |      U    |      J    |      D    | !< +-b64 index-+-b64 index-+-b64 index-+-b64 index-+ !< !      16   |      20   |      9    |      3    | !< +-6 bits----+-6 bits----+-6 bits----+-6 bits----+ !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1| !< +-----------+---+-------+-------+---+-----------+ !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1| !< +-----8 bits----+-----8 bits----+-----8 bits----+ !<``` !< @note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. !< !< @warning This procedure is the backend of decoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Characters code. integer ( I1P ), intent ( OUT ) :: bits ( 1 :) !< Bits decoded. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) e = 1_I8P do c = 1_I8P , len ( code ), 4_I8P ! loop over code characters: 3 bytes (24 bits) scanning sixb = 0_I1P sixb ( 1 ) = index ( base64 , code ( c : c )) - 1 sixb ( 2 ) = index ( base64 , code ( c + 1 : c + 1 )) - 1 sixb ( 3 ) = index ( base64 , code ( c + 2 : c + 2 )) - 1 sixb ( 4 ) = index ( base64 , code ( c + 3 : c + 3 )) - 1 call mvbits ( sixb ( 1 ), 0 , 6 , bits ( e ), 2 ) ; call mvbits ( sixb ( 2 ), 4 , 2 , bits ( e ), 0 ) if ( e + 1 <= Nb ) then call mvbits ( sixb ( 2 ), 0 , 4 , bits ( e + 1 ), 4 ) ; call mvbits ( sixb ( 3 ), 2 , 4 , bits ( e + 1 ), 0 ) endif if ( e + 2 <= Nb ) then call mvbits ( sixb ( 3 ), 0 , 2 , bits ( e + 2 ), 6 ) ; call mvbits ( sixb ( 4 ), 0 , 6 , bits ( e + 2 ), 0 ) endif e = e + 3_I8P enddo ! padding handling ! if (code(len(code)-1:len(code))=='==') then !   bits(size(bits)-1:) = 0_I1P ! elseif (code(len(code):len(code))=='=') then !   bits(size(bits)) = 0_I1P ! endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine decode_bits subroutine b64_encode_up ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding an unlimited polymorphic scalar to base64. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( * ), intent ( IN ) :: up !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded scalar. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8 ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4 ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8 ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4 ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2 ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1 ( n = up , code = code ) type is ( character ( * )) call b64_encode_string ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up pure subroutine b64_encode_up_a ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding an unlimited polymorphic array to base64. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( * ), intent ( IN ) :: up ( 1 :) !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8_a ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4_a ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8_a ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4_a ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2_a ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1_a ( n = up , code = code ) type is ( character ( * )) call b64_encode_string_a ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up_a subroutine b64_decode_up ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding an unlimited polymorphic scalar from base64. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded scalar. class ( * ), intent ( OUT ) :: up !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8 ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4 ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8 ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4 ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2 ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1 ( code = code , n = up ) type is ( character ( * )) call b64_decode_string ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up subroutine b64_decode_up_a ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding an unlimited polymorphic array from base64. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded array. class ( * ), intent ( OUT ) :: up ( 1 :) !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8_a ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4_a ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8_a ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4_a ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2_a ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1_a ( code = code , n = up ) type is ( character ( * )) call b64_decode_string_a ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up_a pure subroutine b64_encode_R16 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding scalar number to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R16P ), intent ( IN ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR16P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16 pure subroutine b64_encode_R8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding scalar number to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR8P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8 pure subroutine b64_encode_R4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding scalar number to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR4P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4 pure subroutine b64_encode_I8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding scalar number to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8 pure subroutine b64_encode_I4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding scalar number to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI4P ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4 pure subroutine b64_encode_I2 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding scalar number to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI2P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2 pure subroutine b64_encode_I1 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding scalar number to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI1P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1 pure subroutine b64_encode_string ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding scalar string to base64. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: s !< String to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string pure subroutine b64_encode_R16_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding array numbers to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R16P ), intent ( IN ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR16P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16_a pure subroutine b64_encode_R8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding array numbers to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8_a pure subroutine b64_encode_R4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding array numbers to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4_a pure subroutine b64_encode_I8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding array numbers to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8_a pure subroutine b64_encode_I4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding array numbers to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4_a pure subroutine b64_encode_I2_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding array numbers to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI2P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2_a pure subroutine b64_encode_I1_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding array numbers to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI1P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1_a pure subroutine b64_encode_string_a ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for encoding array string to base64. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: s ( 1 :) !< String to be encoded. character ( len = :), allocatable , intent ( OUT ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ( 1 )) * size ( s , dim = 1 ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string_a elemental subroutine b64_decode_R16 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into a scalar number (R16P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded scalar. real ( R16P ), intent ( OUT ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16 elemental subroutine b64_decode_R8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into a scalar number (R8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded scalar. real ( R8P ), intent ( OUT ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8 elemental subroutine b64_decode_R4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into a scalar number (R4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded scalar. real ( R4P ), intent ( OUT ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4 elemental subroutine b64_decode_I8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into a scalar number (I8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded scalar. integer ( I8P ), intent ( OUT ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8 elemental subroutine b64_decode_I4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into a scalar number (I4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded scalar. integer ( I4P ), intent ( OUT ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4 elemental subroutine b64_decode_I2 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into a scalar number (I2P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded scalar. integer ( I2P ), intent ( OUT ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2 elemental subroutine b64_decode_I1 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into a scalar number (I1P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded scalar. integer ( I1P ), intent ( OUT ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1 elemental subroutine b64_decode_string ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into a scalar string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded scalar. character ( * ), intent ( OUT ) :: s !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string pure subroutine b64_decode_R16_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into an array numbers (R16P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded array. real ( R16P ), intent ( OUT ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16_a pure subroutine b64_decode_R8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into an array numbers (R8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded array. real ( R8P ), intent ( OUT ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8_a pure subroutine b64_decode_R4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into an array numbers (R4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded array. real ( R4P ), intent ( OUT ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4_a pure subroutine b64_decode_I8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into an array numbers (I8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded array. integer ( I8P ), intent ( OUT ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8_a pure subroutine b64_decode_I4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into an array numbers (I4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded array. integer ( I4P ), intent ( OUT ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4_a pure subroutine b64_decode_I2_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into an array numbers (I2P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded array. integer ( I2P ), intent ( OUT ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2_a pure subroutine b64_decode_I1_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into an array numbers (I1P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded array. integer ( I1P ), intent ( OUT ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1_a pure subroutine b64_decode_string_a ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for decoding a base64 code into an array of strings. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: code !< Encoded scalar. character ( * ), intent ( OUT ) :: s ( 1 :) !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ( 1 )) * size ( s , dim = 1 ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string_a subroutine autotest () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for autotesting the library functionalities. !< !< @note Into the *src* directory there is a small python script (*validation.py*) that can be used to validate the library !< correctness by a comparison with other widely used tools such as the python builtin module *struct*. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: code64 !< Base64 code. logical :: ok !< Flag for checking the result of encoding/decoding. #ifdef r16p real ( R16P ) :: scalar_R16 !< Decoded scalar. #endif real ( R8P ) :: scalar_R8 !< Decoded scalar. real ( R4P ) :: scalar_R4 !< Decoded scalar. integer ( I8P ) :: scalar_I8 !< Decoded scalar. integer ( I4P ) :: scalar_I4 !< Decoded scalar. integer ( I2P ) :: scalar_I2 !< Decoded scalar. integer ( I1P ) :: scalar_I1 !< Decoded scalar. real ( R8P ) :: array_R8 ( 1 : 2 ) !< Decoded array. real ( R4P ) :: array_R4 ( 1 : 2 ) !< Decoded array. integer ( I8P ) :: array_I8 ( 1 : 4 ) !< Decoded array. integer ( I4P ) :: array_I4 ( 1 : 2 ) !< Decoded array. integer ( I2P ) :: array_I2 ( 1 : 2 ) !< Decoded array. integer ( I1P ) :: array_I1 ( 1 : 2 ) !< Decoded array. character ( 5 ) :: array_s ( 1 : 2 ) !< Decoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call b64_Init print \"(A)\" , 'Encoders' print \"(A)\" , 'Scalars' #ifdef r16p call b64_encode ( n = 13 4.231_R16P , code = code64 ) ok = code64 == 'CKwcWmTHYEA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 13 4.231_R16P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'CKwcWmTHYEA=' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = 1._R8P , code = code64 ) ok = code64 == 'AAAAAAAA8D8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 1._R8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 0._R4P , code = code64 ) ok = code64 == 'AAAAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 0._R4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 23_I8P , code = code64 ) ok = code64 == 'FwAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 23_I8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 2023_I4P , code = code64 ) ok = code64 == '5wcAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 2023_I4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n =- 203_I2P , code = code64 ) ok = code64 == 'Nf8=' print \"(A)\" , '+ Code of ' // trim ( str ( n =- 203_I2P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 120_I1P , code = code64 ) ok = code64 == 'eA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 120_I1P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = 'hello' , code = code64 ) ok = code64 == 'aGVsbG8=' print \"(A)\" , '+ Code of hello: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG8=' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' #ifdef r16p call b64_encode ( n = [ 12 1._R16P , 2.32_R16P ], code = code64 ) ok = code64 == 'AAAAAABAXkCPwvUoXI8CQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 12 1._R16P , 2.32_R16P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAABAXkCPwvUoXI8CQA==' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = [ 1._R8P , 2._R8P ], code = code64 ) ok = code64 == 'AAAAAAAA8D8AAAAAAAAAQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8AAAAAAAAAQA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) ok = code64 == 'AAAAAOF6AMI=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAOF6AMI=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], code = code64 ) ok = code64 == 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 2023_I4P , - 24_I4P ], code = code64 ) ok = code64 == '5wcAAOj///8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAOj///8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ - 203_I2P , - 10_I2P ], code = code64 ) ok = code64 == 'Nf/2/w==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf/2/w==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 120_I1P , - 1_I1P ], code = code64 ) ok = code64 == 'eP8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eP8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = [ 'hello' , 'world' ], code = code64 ) ok = code64 == 'aGVsbG93b3JsZA==' print \"(A)\" , '+ Code of [hello,world]: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG93b3JsZA==' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Decoders' print \"(A)\" , 'Scalars' call b64_decode ( code = 'AAAAAAAA8D8=' , n = scalar_R8 ) ok = str ( n = scalar_R8 ) == str ( n = 1._R8P ) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8=' // ': \"' // trim ( str ( n = scalar_R8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 1._R8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAA==' , n = scalar_R4 ) ok = str ( n = scalar_R4 ) == str ( n = 0._R4P ) print \"(A)\" , '+ Decode of ' // 'AAAAAA==' // ': \"' // trim ( str ( n = scalar_R4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 0._R4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'FwAAAAAAAAA=' , n = scalar_I8 ) ok = str ( n = scalar_I8 ) == str ( n = 23_I8P ) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAAA=' // ': \"' // trim ( str ( n = scalar_I8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 23_I8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAA==' , n = scalar_I4 ) ok = str ( n = scalar_I4 ) == str ( n = 2023_I4P ) print \"(A)\" , '+ Decode of ' // '5wcAAA==' // ': \"' // trim ( str ( n = scalar_I4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 2023_I4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf8=' , n = scalar_I2 ) ok = str ( n = scalar_I2 ) == str ( n =- 203_I2P ) print \"(A)\" , '+ Decode of ' // 'Nf8=' // ': \"' // trim ( str ( n = scalar_I2 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n =- 203_I2P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eA==' , n = scalar_I1 ) ok = str ( n = scalar_I1 ) == str ( n = 120_I1P ) print \"(A)\" , '+ Decode of ' // 'eA==' // ': \"' // trim ( str ( n = scalar_I1 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 120_I1P )) // '\", Is it correct?' , ok if (. not . ok ) stop code64 = repeat ( ' ' , 5 ) call b64_decode ( code = 'aGVsbG8=' , s = code64 ) ok = 'hello' == code64 print \"(A)\" , '+ Decode of ' // 'aGVsbG8=' // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected value: \"hello\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' call b64_decode ( code = 'AAAAAAAA8D8AAAAAAAAAQA==' , n = array_R8 ) ok = str ( n = array_R8 ) == str ( n = [ 1._R8P , 2._R8P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8AAAAAAAAAQA==' // ': \"' // trim ( str ( n = array_R8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAOF6AMI=' , n = array_R4 ) ok = str ( n = array_R4 ) == str ( n = [ 0._R4P , - 3 2.12_R4P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAOF6AMI=' // ': \"' // trim ( str ( n = array_R4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop ! ok = test_decode_array(code=, input=) ; if (.not.ok) stop call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = array_I8 ) ok = str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // ': \"' // & trim ( str ( n = array_I8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // & '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAOj///8=' , n = array_I4 ) ok = str ( n = array_I4 ) == str ( n = [ 2023_I4P , - 24_I4P ]) print \"(A)\" , '+ Decode of ' // '5wcAAOj///8=' // ': \"' // trim ( str ( n = array_I4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf/2/w==' , n = array_I2 ) ok = str ( n = array_I2 ) == str ( n = [ - 203_I2P , - 10_I2P ]) print \"(A)\" , '+ Decode of ' // 'Nf/2/w==' // ': \"' // trim ( str ( n = array_I2 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eP8=' , n = array_I1 ) ok = str ( n = array_I1 ) == str ( n = [ 120_I1P , - 1_I1P ]) print \"(A)\" , '+ Decode of ' // 'eP8=' // ': \"' // trim ( str ( n = array_I1 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'aGVsbG93b3JsZA==' , s = array_s ) ok = array_s ( 1 ) // array_s ( 2 ) == 'helloworld' print \"(A)\" , '+ Decode of ' // 'aGVsbG93b3JsZA==' // ': \"' // array_s ( 1 ) // array_s ( 2 ) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"helloworld\", Is it correct?' , ok if (. not . ok ) stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine autotest endmodule Lib_Base64 © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"sourcefile/lib_base64.f90.html","title":"Lib_Base64.f90 – BeFoR64"},{"text":"pack_data_R8_R4 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_R8_R4 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_R8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_r8_r4.html","title":"pack_data_R8_R4 – BeFoR64"},{"text":"pack_data_R8_I8 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_R8_I8 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_R8_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_r8_i8.html","title":"pack_data_R8_I8 – BeFoR64"},{"text":"pack_data_R8_I4 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_R8_I4 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_R8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_r8_i4.html","title":"pack_data_R8_I4 – BeFoR64"},{"text":"pack_data_R8_I2 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_R8_I2 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_R8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_r8_i2.html","title":"pack_data_R8_I2 – BeFoR64"},{"text":"pack_data_R8_I1 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_R8_I1 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_R8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_r8_i1.html","title":"pack_data_R8_I1 – BeFoR64"},{"text":"pack_data_R4_R8 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_R4_R8 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_R4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_r4_r8.html","title":"pack_data_R4_R8 – BeFoR64"},{"text":"pack_data_R4_I8 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_R4_I8 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_R4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_r4_i8.html","title":"pack_data_R4_I8 – BeFoR64"},{"text":"pack_data_R4_I4 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_R4_I4 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_R4_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_r4_i4.html","title":"pack_data_R4_I4 – BeFoR64"},{"text":"pack_data_R4_I2 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_R4_I2 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_R4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_r4_i2.html","title":"pack_data_R4_I2 – BeFoR64"},{"text":"pack_data_R4_I1 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_R4_I1 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_R4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_r4_i1.html","title":"pack_data_R4_I1 – BeFoR64"},{"text":"pack_data_I8_R8 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I8_R8 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I8_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i8_r8.html","title":"pack_data_I8_R8 – BeFoR64"},{"text":"pack_data_I8_R4 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I8_R4 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i8_r4.html","title":"pack_data_I8_R4 – BeFoR64"},{"text":"pack_data_I8_I4 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I8_I4 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i8_i4.html","title":"pack_data_I8_I4 – BeFoR64"},{"text":"pack_data_I8_I2 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I8_I2 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i8_i2.html","title":"pack_data_I8_I2 – BeFoR64"},{"text":"pack_data_I8_I1 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I8_I1 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i8_i1.html","title":"pack_data_I8_I1 – BeFoR64"},{"text":"pack_data_I4_R8 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I4_R8 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i4_r8.html","title":"pack_data_I4_R8 – BeFoR64"},{"text":"pack_data_I4_R4 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I4_R4 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I4_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i4_r4.html","title":"pack_data_I4_R4 – BeFoR64"},{"text":"pack_data_I4_I8 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I4_I8 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i4_i8.html","title":"pack_data_I4_I8 – BeFoR64"},{"text":"pack_data_I4_I2 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I4_I2 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i4_i2.html","title":"pack_data_I4_I2 – BeFoR64"},{"text":"pack_data_I4_I1 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I4_I1 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i4_i1.html","title":"pack_data_I4_I1 – BeFoR64"},{"text":"pack_data_I2_R8 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I2_R8 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I2_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i2_r8.html","title":"pack_data_I2_R8 – BeFoR64"},{"text":"pack_data_I2_R4 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I2_R4 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I2_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i2_r4.html","title":"pack_data_I2_R4 – BeFoR64"},{"text":"pack_data_I2_I8 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I2_I8 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I2_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i2_i8.html","title":"pack_data_I2_I8 – BeFoR64"},{"text":"pack_data_I2_I4 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I2_I4 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I2_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i2_i4.html","title":"pack_data_I2_I4 – BeFoR64"},{"text":"pack_data_I2_I1 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I2_I1 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I2_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i2_i1.html","title":"pack_data_I2_I1 – BeFoR64"},{"text":"pack_data_I1_R8 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I1_R8 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I1_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i1_r8.html","title":"pack_data_I1_R8 – BeFoR64"},{"text":"pack_data_I1_R4 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I1_R4 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I1_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i1_r4.html","title":"pack_data_I1_R4 – BeFoR64"},{"text":"pack_data_I1_I8 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I1_I8 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I1_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i1_i8.html","title":"pack_data_I1_I8 – BeFoR64"},{"text":"pack_data_I1_I4 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I1_I4 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I1_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i1_i4.html","title":"pack_data_I1_I4 – BeFoR64"},{"text":"pack_data_I1_I2 Subroutine Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data_I1_I2 Variables p1 p2 np All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine pack_data_I1_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/pack_data_i1_i2.html","title":"pack_data_I1_I2 – BeFoR64"},{"text":"pack_data Interface Source File Lib_Pack_Data.f90 Lib_Pack_Data pack_data Module Procedures pack_data_R8_R4 pack_data_R8_I8 pack_data_R8_I4 pack_data_R8_I2 pack_data_R8_I1 pack_data_R4_R8 pack_data_R4_I8 pack_data_R4_I4 pack_data_R4_I2 pack_data_R4_I1 pack_data_I8_R8 pack_data_I8_R4 pack_data_I8_I4 pack_data_I8_I2 pack_data_I8_I1 pack_data_I4_R8 pack_data_I4_R4 pack_data_I4_I8 pack_data_I4_I2 pack_data_I4_I1 pack_data_I2_R8 pack_data_I2_R4 pack_data_I2_I8 pack_data_I2_I4 pack_data_I2_I1 pack_data_I1_R8 pack_data_I1_R4 pack_data_I1_I8 pack_data_I1_I4 pack_data_I1_I2 All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface pack_data Procedure for packing different kinds of data into single I1P array. This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. Note This procedure exploits the transfer builtin function, that from the standard (2003+) is defined as TRANSFER(SOURCE, MOLD [, SIZE]) . Data object having a physical representation identical to that of SOURCE but with the type\n and type parameters of MOLD . The result is of the same type and type parameters as MOLD .\n If MOLD is an array and SIZE is absent, the result is an array and of rank one. Its size is as small as possible such\n that its physical representation is not shorter than that of SOURCE . Presently, the following combinations are available: Arrays-Arrays: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Scalars-Scalars: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Examples of usage Packing two real arrays, one with kind R8P and one with R4P real ( R8P ) :: array_r8 ( 1 : 12 ) real ( R4P ) :: array_r4 ( - 1 : 5 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r8 , a2 = array_r4 , packed = rpack ) Packing two arrays, one real with kind R4P and one integer with I4P real ( R4P ) :: array_r4 ( 2 ) integer ( I4P ) :: array_i4 ( 0 : 2 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r4 , a2 = array_i4 , packed = rpack ) Module Procedures private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/pack_data.html","title":"pack_data – BeFoR64"},{"text":"is_little_endian Function Source File IR_Precision.f90 IR_Precision is_little_endian Variables int1 All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure function is_little_endian() Arguments None Return Value logical Logical output: true is the running architecture uses little endian ordering, false otherwise. Description Procedure for checking if the type of the bit ordering of the running architecture is little endian. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: int1 (1:4) One byte integer array for casting 4 bytes integer. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/is_little_endian.html","title":"is_little_endian – BeFoR64"},{"text":"bit_size_R16P Function Source File IR_Precision.f90 IR_Precision bit_size_R16P Variables mold All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bit_size_R16P(r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bit_size_r16p.html","title":"bit_size_R16P – BeFoR64"},{"text":"bit_size_R8P Function Source File IR_Precision.f90 IR_Precision bit_size_R8P Variables mold All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bit_size_R8P(r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bit_size_r8p.html","title":"bit_size_R8P – BeFoR64"},{"text":"bit_size_R4P Function Source File IR_Precision.f90 IR_Precision bit_size_R4P Variables mold All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bit_size_R4P(r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bit_size_r4p.html","title":"bit_size_R4P – BeFoR64"},{"text":"bit_size_chr Function Source File IR_Precision.f90 IR_Precision bit_size_chr Variables mold All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bit_size_chr(c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Procedure for computing the number of bits of a character variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bit_size_chr.html","title":"bit_size_chr – BeFoR64"},{"text":"byte_size_I8P Function Source File IR_Precision.f90 IR_Precision byte_size_I8P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function byte_size_I8P(i) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/byte_size_i8p.html","title":"byte_size_I8P – BeFoR64"},{"text":"byte_size_I4P Function Source File IR_Precision.f90 IR_Precision byte_size_I4P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function byte_size_I4P(i) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/byte_size_i4p.html","title":"byte_size_I4P – BeFoR64"},{"text":"byte_size_I2P Function Source File IR_Precision.f90 IR_Precision byte_size_I2P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function byte_size_I2P(i) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/byte_size_i2p.html","title":"byte_size_I2P – BeFoR64"},{"text":"byte_size_I1P Function Source File IR_Precision.f90 IR_Precision byte_size_I1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function byte_size_I1P(i) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/byte_size_i1p.html","title":"byte_size_I1P – BeFoR64"},{"text":"byte_size_R16P Function Source File IR_Precision.f90 IR_Precision byte_size_R16P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function byte_size_R16P(r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/byte_size_r16p.html","title":"byte_size_R16P – BeFoR64"},{"text":"byte_size_R8P Function Source File IR_Precision.f90 IR_Precision byte_size_R8P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function byte_size_R8P(r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/byte_size_r8p.html","title":"byte_size_R8P – BeFoR64"},{"text":"byte_size_R4P Function Source File IR_Precision.f90 IR_Precision byte_size_R4P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function byte_size_R4P(r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/byte_size_r4p.html","title":"byte_size_R4P – BeFoR64"},{"text":"byte_size_chr Function Source File IR_Precision.f90 IR_Precision byte_size_chr All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function byte_size_chr(c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Procedure for computing the number of bytes of a character variable. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/byte_size_chr.html","title":"byte_size_chr – BeFoR64"},{"text":"strf_R16P Function Source File IR_Precision.f90 IR_Precision strf_R16P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function strf_R16P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/strf_r16p.html","title":"strf_R16P – BeFoR64"},{"text":"strf_R8P Function Source File IR_Precision.f90 IR_Precision strf_R8P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function strf_R8P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/strf_r8p.html","title":"strf_R8P – BeFoR64"},{"text":"strf_R4P Function Source File IR_Precision.f90 IR_Precision strf_R4P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function strf_R4P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/strf_r4p.html","title":"strf_R4P – BeFoR64"},{"text":"strf_I8P Function Source File IR_Precision.f90 IR_Precision strf_I8P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function strf_I8P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/strf_i8p.html","title":"strf_I8P – BeFoR64"},{"text":"strf_I4P Function Source File IR_Precision.f90 IR_Precision strf_I4P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function strf_I4P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/strf_i4p.html","title":"strf_I4P – BeFoR64"},{"text":"strf_I2P Function Source File IR_Precision.f90 IR_Precision strf_I2P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function strf_I2P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/strf_i2p.html","title":"strf_I2P – BeFoR64"},{"text":"strf_I1P Function Source File IR_Precision.f90 IR_Precision strf_I1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function strf_I1P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/strf_i1p.html","title":"strf_I1P – BeFoR64"},{"text":"str_R16P Function Source File IR_Precision.f90 IR_Precision str_R16P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function str_R16P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_r16p.html","title":"str_R16P – BeFoR64"},{"text":"str_R8P Function Source File IR_Precision.f90 IR_Precision str_R8P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function str_R8P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_r8p.html","title":"str_R8P – BeFoR64"},{"text":"str_R4P Function Source File IR_Precision.f90 IR_Precision str_R4P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function str_R4P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_r4p.html","title":"str_R4P – BeFoR64"},{"text":"str_I8P Function Source File IR_Precision.f90 IR_Precision str_I8P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function str_I8P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_i8p.html","title":"str_I8P – BeFoR64"},{"text":"str_I4P Function Source File IR_Precision.f90 IR_Precision str_I4P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function str_I4P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_i4p.html","title":"str_I4P – BeFoR64"},{"text":"str_I2P Function Source File IR_Precision.f90 IR_Precision str_I2P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function str_I2P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_i2p.html","title":"str_I2P – BeFoR64"},{"text":"str_I1P Function Source File IR_Precision.f90 IR_Precision str_I1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function str_I1P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_i1p.html","title":"str_I1P – BeFoR64"},{"text":"str_bol Function Source File IR_Precision.f90 IR_Precision str_bol All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function str_bol(n) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Procedure for converting logical to string. This function achieves casting of logical to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_bol.html","title":"str_bol – BeFoR64"},{"text":"str_a_R16P Function Source File IR_Precision.f90 IR_Precision str_a_R16P Variables strn i All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure function str_a_R16P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R16P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. Variables Type Visibility Attributes Name Initial character(len=DR16P), public :: strn String containing of element of input array number. integer, public :: i Counter. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_a_r16p.html","title":"str_a_R16P – BeFoR64"},{"text":"str_a_R8P Function Source File IR_Precision.f90 IR_Precision str_a_R8P Variables strn i All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure function str_a_R8P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R8P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. Variables Type Visibility Attributes Name Initial character(len=DR8P), public :: strn String containing of element of input array number. integer, public :: i Counter. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_a_r8p.html","title":"str_a_R8P – BeFoR64"},{"text":"str_a_R4P Function Source File IR_Precision.f90 IR_Precision str_a_R4P Variables strn i All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure function str_a_R4P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R4P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. Variables Type Visibility Attributes Name Initial character(len=DR4P), public :: strn String containing of element of input array number. integer, public :: i Counter. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_a_r4p.html","title":"str_a_R4P – BeFoR64"},{"text":"str_a_I8P Function Source File IR_Precision.f90 IR_Precision str_a_I8P Variables strn i All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure function str_a_I8P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: strn String containing of element of input array number. integer, public :: i Counter. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_a_i8p.html","title":"str_a_I8P – BeFoR64"},{"text":"str_a_I4P Function Source File IR_Precision.f90 IR_Precision str_a_I4P Variables strn i All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure function str_a_I4P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: strn String containing of element of input array number. integer, public :: i Counter. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_a_i4p.html","title":"str_a_I4P – BeFoR64"},{"text":"str_a_I2P Function Source File IR_Precision.f90 IR_Precision str_a_I2P Variables strn i All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure function str_a_I2P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: strn String containing of element of input array number. integer, public :: i Counter. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_a_i2p.html","title":"str_a_I2P – BeFoR64"},{"text":"str_a_I1P Function Source File IR_Precision.f90 IR_Precision str_a_I1P Variables strn i All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure function str_a_I1P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: strn String containing of element of input array number. integer, public :: i Counter. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/str_a_i1p.html","title":"str_a_I1P – BeFoR64"},{"text":"strz_I8P Function Source File IR_Precision.f90 IR_Precision strz_I8P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function strz_I8P(nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/strz_i8p.html","title":"strz_I8P – BeFoR64"},{"text":"strz_I4P Function Source File IR_Precision.f90 IR_Precision strz_I4P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function strz_I4P(nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/strz_i4p.html","title":"strz_I4P – BeFoR64"},{"text":"strz_I2P Function Source File IR_Precision.f90 IR_Precision strz_I2P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function strz_I2P(nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/strz_i2p.html","title":"strz_I2P – BeFoR64"},{"text":"strz_I1P Function Source File IR_Precision.f90 IR_Precision strz_I1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function strz_I1P(nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/strz_i1p.html","title":"strz_I1P – BeFoR64"},{"text":"ctor_R16P Function Source File IR_Precision.f90 IR_Precision ctor_R16P Variables err prefd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private  function ctor_R16P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/ctor_r16p.html","title":"ctor_R16P – BeFoR64"},{"text":"ctor_R8P Function Source File IR_Precision.f90 IR_Precision ctor_R8P Variables err prefd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private  function ctor_R8P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/ctor_r8p.html","title":"ctor_R8P – BeFoR64"},{"text":"ctor_R4P Function Source File IR_Precision.f90 IR_Precision ctor_R4P Variables err prefd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private  function ctor_R4P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/ctor_r4p.html","title":"ctor_R4P – BeFoR64"},{"text":"ctoi_I8P Function Source File IR_Precision.f90 IR_Precision ctoi_I8P Variables err prefd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private  function ctoi_I8P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/ctoi_i8p.html","title":"ctoi_I8P – BeFoR64"},{"text":"ctoi_I4P Function Source File IR_Precision.f90 IR_Precision ctoi_I4P Variables err prefd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private  function ctoi_I4P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/ctoi_i4p.html","title":"ctoi_I4P – BeFoR64"},{"text":"ctoi_I2P Function Source File IR_Precision.f90 IR_Precision ctoi_I2P Variables err prefd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private  function ctoi_I2P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/ctoi_i2p.html","title":"ctoi_I2P – BeFoR64"},{"text":"ctoi_I1P Function Source File IR_Precision.f90 IR_Precision ctoi_I1P Variables err prefd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private  function ctoi_I1P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/ctoi_i1p.html","title":"ctoi_I1P – BeFoR64"},{"text":"bstr_R16P Function Source File IR_Precision.f90 IR_Precision bstr_R16P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bstr_R16P(n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bstr_r16p.html","title":"bstr_R16P – BeFoR64"},{"text":"bstr_R8P Function Source File IR_Precision.f90 IR_Precision bstr_R8P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bstr_R8P(n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bstr_r8p.html","title":"bstr_R8P – BeFoR64"},{"text":"bstr_R4P Function Source File IR_Precision.f90 IR_Precision bstr_R4P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bstr_R4P(n) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bstr_r4p.html","title":"bstr_R4P – BeFoR64"},{"text":"bstr_I8P Function Source File IR_Precision.f90 IR_Precision bstr_I8P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bstr_I8P(n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bstr_i8p.html","title":"bstr_I8P – BeFoR64"},{"text":"bstr_I4P Function Source File IR_Precision.f90 IR_Precision bstr_I4P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bstr_I4P(n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bstr_i4p.html","title":"bstr_I4P – BeFoR64"},{"text":"bstr_I2P Function Source File IR_Precision.f90 IR_Precision bstr_I2P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bstr_I2P(n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bstr_i2p.html","title":"bstr_I2P – BeFoR64"},{"text":"bstr_I1P Function Source File IR_Precision.f90 IR_Precision bstr_I1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bstr_I1P(n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bstr_i1p.html","title":"bstr_I1P – BeFoR64"},{"text":"bctor_R8P Function Source File IR_Precision.f90 IR_Precision bctor_R8P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bctor_R8P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bctor_r8p.html","title":"bctor_R8P – BeFoR64"},{"text":"bctor_R4P Function Source File IR_Precision.f90 IR_Precision bctor_R4P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bctor_R4P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bctor_r4p.html","title":"bctor_R4P – BeFoR64"},{"text":"bctoi_I8P Function Source File IR_Precision.f90 IR_Precision bctoi_I8P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bctoi_I8P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bctoi_i8p.html","title":"bctoi_I8P – BeFoR64"},{"text":"bctoi_I4P Function Source File IR_Precision.f90 IR_Precision bctoi_I4P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bctoi_I4P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bctoi_i4p.html","title":"bctoi_I4P – BeFoR64"},{"text":"bctoi_I2P Function Source File IR_Precision.f90 IR_Precision bctoi_I2P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bctoi_I2P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bctoi_i2p.html","title":"bctoi_I2P – BeFoR64"},{"text":"bctoi_I1P Function Source File IR_Precision.f90 IR_Precision bctoi_I1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function bctoi_I1P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/bctoi_i1p.html","title":"bctoi_I1P – BeFoR64"},{"text":"digit_I8 Function Source File IR_Precision.f90 IR_Precision digit_I8 Variables str All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function digit_I8(n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: str Returned string containing input number plus padding zeros. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/digit_i8.html","title":"digit_I8 – BeFoR64"},{"text":"digit_I4 Function Source File IR_Precision.f90 IR_Precision digit_I4 Variables str All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function digit_I4(n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: str Returned string containing input number plus padding zeros. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/digit_i4.html","title":"digit_I4 – BeFoR64"},{"text":"digit_I2 Function Source File IR_Precision.f90 IR_Precision digit_I2 Variables str All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function digit_I2(n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: str Returned string containing input number plus padding zeros. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/digit_i2.html","title":"digit_I2 – BeFoR64"},{"text":"digit_I1 Function Source File IR_Precision.f90 IR_Precision digit_I1 Variables str All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental function digit_I1(n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: str Returned string containing input number plus padding zeros. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/digit_i1.html","title":"digit_I1 – BeFoR64"},{"text":"check_endian Subroutine Source File IR_Precision.f90 IR_Precision check_endian All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public  subroutine check_endian() Arguments None Description Subroutine for checking the type of bit ordering (big or little endian) of the running architecture. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/check_endian.html","title":"check_endian – BeFoR64"},{"text":"IR_init Subroutine Source File IR_Precision.f90 IR_Precision IR_init All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public  subroutine IR_init() Arguments None Description Procedure for initilizing module's variables that are not initialized into the definition specification. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/ir_init.html","title":"IR_init – BeFoR64"},{"text":"IR_Print Subroutine Source File IR_Precision.f90 IR_Precision IR_Print Variables prefd iostatd iomsgd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public  subroutine IR_Print(pref, iostat, iomsg, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. integer(kind=I4P), intent(in) :: unit Logic unit. Description Procedure for printing to the standard output the kind definition of reals and integers and the utility variables. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/ir_print.html","title":"IR_Print – BeFoR64"},{"text":"bit_size Interface Source File IR_Precision.f90 IR_Precision bit_size Module Procedures bit_size_R16p bit_size_R8P bit_size_R4P bit_size_chr All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Module Procedures private elemental function bit_size_R16P (r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_R8P (r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_R4P (r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_chr (c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Procedure for computing the number of bits of a character variable. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/bit_size.html","title":"bit_size – BeFoR64"},{"text":"byte_size Interface Source File IR_Precision.f90 IR_Precision byte_size Module Procedures byte_size_I8P byte_size_I4P byte_size_I2P byte_size_I1P byte_size_R16p byte_size_R8P byte_size_R4P byte_size_chr All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface byte_size Overloading of the byte_size function for computing the number of bytes. Module Procedures private elemental function byte_size_I8P (i) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I4P (i) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I2P (i) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I1P (i) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_R16P (r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_R8P (r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_R4P (r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_chr (c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Procedure for computing the number of bytes of a character variable. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/byte_size.html","title":"byte_size – BeFoR64"},{"text":"str Interface Source File IR_Precision.f90 IR_Precision str Module Procedures strf_R16P str_R16P strf_R8P str_R8P strf_R4P str_R4P strf_I8P str_I8P strf_I4P str_I4P strf_I2P str_I2P strf_I1P str_I1P str_bol str_a_R16P str_a_R8P str_a_R4P str_a_I8P str_a_I4P str_a_I2P str_a_I1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface str Procedure for converting number, real and integer, to string (number to string type casting). Module Procedures private elemental function strf_R16P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R16P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_R8P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R8P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_R4P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R4P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_I8P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I8P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I4P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I4P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I2P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I2P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I1P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I1P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_bol (n) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Procedure for converting logical to string. This function achieves casting of logical to string. private pure function str_a_R16P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R16P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_R8P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R8P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_R4P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R4P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_I8P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I4P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I2P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I1P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/str.html","title":"str – BeFoR64"},{"text":"strz Interface Source File IR_Precision.f90 IR_Precision strz Module Procedures strz_I8P strz_I4P strz_I2P strz_I1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface strz Procedure for converting number, integer, to string, prefixing with the right number of zeros (number to string type\n casting with zero padding). Module Procedures private elemental function strz_I8P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I4P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I2P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I1P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/strz.html","title":"strz – BeFoR64"},{"text":"cton Interface Source File IR_Precision.f90 IR_Precision cton Module Procedures ctor_R16P ctor_R8P ctor_R4P ctoi_I8P ctoi_I4P ctoi_I2P ctoi_I1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface cton Procedure for converting string to number, real or initeger, (string to number type casting). Module Procedures private  function ctor_R16P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctor_R8P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctor_R4P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctoi_I8P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I4P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I2P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I1P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/cton.html","title":"cton – BeFoR64"},{"text":"bstr Interface Source File IR_Precision.f90 IR_Precision bstr Module Procedures bstr_R16P bstr_R8P bstr_R4P bstr_I8P bstr_I4P bstr_I2P bstr_I1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface bstr Procedure for converting number, real and integer, to bit-string (number to bit-string type casting). Module Procedures private elemental function bstr_R16P (n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_R8P (n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_R4P (n) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_I8P (n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I4P (n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I2P (n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I1P (n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/bstr.html","title":"bstr – BeFoR64"},{"text":"bcton Interface Source File IR_Precision.f90 IR_Precision bcton Module Procedures bctor_R16P bctor_R8P bctor_R4P bctoi_I8P bctoi_I4P bctoi_I2P bctoi_I1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface bcton Procedure for converting bit-string to number, real or initeger, (bit-string to number type casting). Module Procedures () Arguments None private elemental function bctor_R8P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. private elemental function bctor_R4P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. private elemental function bctoi_I8P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I4P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I2P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I1P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/bcton.html","title":"bcton – BeFoR64"},{"text":"digit Interface Source File IR_Precision.f90 IR_Precision digit Module Procedures digit_I8 digit_I4 digit_I2 digit_I1 All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface digit Procedure for computing the number of digits in decimal base of the input integer. Module Procedures private elemental function digit_I8 (n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/digit.html","title":"digit – BeFoR64"},{"text":"b64_init Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_init All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public  subroutine b64_init() Arguments None Description Procedure for initializing the BeFoR64 library. Note This procedure must be called before encoding/decoding anything! © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_init.html","title":"b64_init – BeFoR64"},{"text":"encode_bits Subroutine Source File Lib_Base64.f90 Lib_Base64 encode_bits Variables sixb c e Nb All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine encode_bits(bits, padd, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: bits (1:) Bits to be encoded. integer(kind=I4P), intent(in) :: padd Number of padding characters ('='). character(len=*), intent(out) :: code Characters code. Description Procedure for encoding a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) +--first octet--+-second octet--+--third octet--+\n |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|\n +-----------+---+-------+-------+---+-----------+\n |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|\n +--1.index--+--2.index--+--3.index--+--4.index--+ Note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. Note The number of paddings must be computed outside this procedure, into the calling scope. Warning This procedure is the backend of encoding, thus it must be never called outside the module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: sixb (1:4) 6 bits slices (stored into 8 bits integer) of 24 bits input. integer(kind=I8P), public :: c Counter. integer(kind=I8P), public :: e Counter. integer(kind=I8P), public :: Nb Length of bits array. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/encode_bits.html","title":"encode_bits – BeFoR64"},{"text":"decode_bits Subroutine Source File Lib_Base64.f90 Lib_Base64 decode_bits Variables sixb c e Nb All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine decode_bits(code, bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Characters code. integer(kind=I1P), intent(out) :: bits (1:) Bits decoded. Description Procedure for decoding a base64 string into a sequence of bits stream. The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code QUJD the decoding process must do +-b64 char--+-b64 char--+-b64 char--+-b64 char--+\n |      Q    |      U    |      J    |      D    |\n +-b64 index-+-b64 index-+-b64 index-+-b64 index-+\n !      16   |      20   |      9    |      3    |\n +-6 bits----+-6 bits----+-6 bits----+-6 bits----+\n |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1|\n +-----------+---+-------+-------+---+-----------+\n |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1|\n +-----8 bits----+-----8 bits----+-----8 bits----+ Note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. Warning This procedure is the backend of decoding, thus it must be never called outside the module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: sixb (1:4) 6 bits slices (stored into 8 bits integer) of 24 bits input. integer(kind=I8P), public :: c Counter. integer(kind=I8P), public :: e Counter. integer(kind=I8P), public :: Nb Length of bits array. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/decode_bits.html","title":"decode_bits – BeFoR64"},{"text":"b64_encode_up Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_up All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public  subroutine b64_encode_up(up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding an unlimited polymorphic scalar to base64. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_up.html","title":"b64_encode_up – BeFoR64"},{"text":"b64_encode_up_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_up_a All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_up_a(up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding an unlimited polymorphic array to base64. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_up_a.html","title":"b64_encode_up_a – BeFoR64"},{"text":"b64_decode_up Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_up All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public  subroutine b64_decode_up(code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. Description Procedure for decoding an unlimited polymorphic scalar from base64. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_up.html","title":"b64_decode_up – BeFoR64"},{"text":"b64_decode_up_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_up_a All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private  subroutine b64_decode_up_a(code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Procedure for decoding an unlimited polymorphic array from base64. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_up_a.html","title":"b64_decode_up_a – BeFoR64"},{"text":"b64_encode_R16 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_R16 Variables nI1P padd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_R16(n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (R16P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_r16.html","title":"b64_encode_R16 – BeFoR64"},{"text":"b64_encode_R8 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_R8 Variables nI1P padd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_R8(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_r8.html","title":"b64_encode_R8 – BeFoR64"},{"text":"b64_encode_R4 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_R4 Variables nI1P padd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_R4(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (R4P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_r4.html","title":"b64_encode_R4 – BeFoR64"},{"text":"b64_encode_I8 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_I8 Variables nI1P padd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_I8(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (I8P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_i8.html","title":"b64_encode_I8 – BeFoR64"},{"text":"b64_encode_I4 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_I4 Variables nI1P padd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_I4(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (I4P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_i4.html","title":"b64_encode_I4 – BeFoR64"},{"text":"b64_encode_I2 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_I2 Variables nI1P padd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_I2(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (I2P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_i2.html","title":"b64_encode_I2 – BeFoR64"},{"text":"b64_encode_I1 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_I1 Variables nI1P padd All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_I1(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (I1P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_i1.html","title":"b64_encode_I1 – BeFoR64"},{"text":"b64_encode_string Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_string Variables nI1P padd BYCHS All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_string(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar string to base64. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I4P), public :: BYCHS Bytes of character string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_string.html","title":"b64_encode_string – BeFoR64"},{"text":"b64_encode_R16_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_R16_a Variables nI1P padd ns All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_R16_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (R16P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_r16_a.html","title":"b64_encode_R16_a – BeFoR64"},{"text":"b64_encode_R8_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_R8_a Variables nI1P padd ns All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_R8_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_r8_a.html","title":"b64_encode_R8_a – BeFoR64"},{"text":"b64_encode_R4_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_R4_a Variables nI1P padd ns All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_R4_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (R4P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_r4_a.html","title":"b64_encode_R4_a – BeFoR64"},{"text":"b64_encode_I8_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_I8_a Variables nI1P padd ns All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_I8_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (I8P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_i8_a.html","title":"b64_encode_I8_a – BeFoR64"},{"text":"b64_encode_I4_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_I4_a Variables nI1P padd ns All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_I4_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (I4P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_i4_a.html","title":"b64_encode_I4_a – BeFoR64"},{"text":"b64_encode_I2_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_I2_a Variables nI1P padd ns All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_I2_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (I2P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_i2_a.html","title":"b64_encode_I2_a – BeFoR64"},{"text":"b64_encode_I1_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_I1_a Variables nI1P padd ns All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_I1_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (I1P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_i1_a.html","title":"b64_encode_I1_a – BeFoR64"},{"text":"b64_encode_string_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_encode_string_a Variables nI1P padd BYCHS All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_encode_string_a(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding array string to base64. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I4P), public :: BYCHS Bytes of character string. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_encode_string_a.html","title":"b64_encode_string_a – BeFoR64"},{"text":"b64_decode_R16 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_R16 Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental subroutine b64_decode_R16(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (R16P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_r16.html","title":"b64_decode_R16 – BeFoR64"},{"text":"b64_decode_R8 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_R8 Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental subroutine b64_decode_R8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_r8.html","title":"b64_decode_R8 – BeFoR64"},{"text":"b64_decode_R4 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_R4 Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental subroutine b64_decode_R4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (R4P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_r4.html","title":"b64_decode_R4 – BeFoR64"},{"text":"b64_decode_I8 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_I8 Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental subroutine b64_decode_I8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (I8P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_i8.html","title":"b64_decode_I8 – BeFoR64"},{"text":"b64_decode_I4 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_I4 Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental subroutine b64_decode_I4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (I4P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_i4.html","title":"b64_decode_I4 – BeFoR64"},{"text":"b64_decode_I2 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_I2 Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental subroutine b64_decode_I2(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (I2P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_i2.html","title":"b64_decode_I2 – BeFoR64"},{"text":"b64_decode_I1 Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_I1 Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental subroutine b64_decode_I1(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (I1P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_i1.html","title":"b64_decode_I1 – BeFoR64"},{"text":"b64_decode_string Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_string Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private elemental subroutine b64_decode_string(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Procedure for decoding a base64 code into a scalar string. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_string.html","title":"b64_decode_string – BeFoR64"},{"text":"b64_decode_R16_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_R16_a Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_decode_R16_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (R16P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_r16_a.html","title":"b64_decode_R16_a – BeFoR64"},{"text":"b64_decode_R8_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_R8_a Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_decode_R8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_r8_a.html","title":"b64_decode_R8_a – BeFoR64"},{"text":"b64_decode_R4_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_R4_a Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_decode_R4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (R4P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_r4_a.html","title":"b64_decode_R4_a – BeFoR64"},{"text":"b64_decode_I8_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_I8_a Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_decode_I8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (I8P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_i8_a.html","title":"b64_decode_I8_a – BeFoR64"},{"text":"b64_decode_I4_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_I4_a Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_decode_I4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (I4P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_i4_a.html","title":"b64_decode_I4_a – BeFoR64"},{"text":"b64_decode_I2_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_I2_a Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_decode_I2_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (I2P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_i2_a.html","title":"b64_decode_I2_a – BeFoR64"},{"text":"b64_decode_I1_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_I1_a Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_decode_I1_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (I1P). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_i1_a.html","title":"b64_decode_I1_a – BeFoR64"},{"text":"b64_decode_string_a Subroutine Source File Lib_Base64.f90 Lib_Base64 b64_decode_string_a Variables nI1P All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P private pure subroutine b64_decode_string_a(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Procedure for decoding a base64 code into an array of strings. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/b64_decode_string_a.html","title":"b64_decode_string_a – BeFoR64"},{"text":"autotest Subroutine Source File Lib_Base64.f90 Lib_Base64 autotest Variables code64 ok scalar_R16 scalar_R8 scalar_R4 scalar_I8 scalar_I4 scalar_I2 scalar_I1 array_R8 array_R4 array_I8 array_I4 array_I2 array_I1 array_s All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public  subroutine autotest() Arguments None Description Procedure for autotesting the library functionalities. Note Into the src directory there is a small python script ( validation.py ) that can be used to validate the library\n correctness by a comparison with other widely used tools such as the python builtin module struct . Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: code64 Base64 code. logical, public :: ok Flag for checking the result of encoding/decoding. real(kind=R16P), public :: scalar_R16 Decoded scalar. real(kind=R8P), public :: scalar_R8 Decoded scalar. real(kind=R4P), public :: scalar_R4 Decoded scalar. integer(kind=I8P), public :: scalar_I8 Decoded scalar. integer(kind=I4P), public :: scalar_I4 Decoded scalar. integer(kind=I2P), public :: scalar_I2 Decoded scalar. integer(kind=I1P), public :: scalar_I1 Decoded scalar. real(kind=R8P), public :: array_R8 (1:2) Decoded array. real(kind=R4P), public :: array_R4 (1:2) Decoded array. integer(kind=I8P), public :: array_I8 (1:4) Decoded array. integer(kind=I4P), public :: array_I4 (1:2) Decoded array. integer(kind=I2P), public :: array_I2 (1:2) Decoded array. integer(kind=I1P), public :: array_I1 (1:2) Decoded array. character(len=5), public :: array_s (1:2) Decoded array. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"proc/autotest.html","title":"autotest – BeFoR64"},{"text":"b64_encode Interface Source File Lib_Base64.f90 Lib_Base64 b64_encode Module Procedures b64_encode_R16 b64_encode_R16_a b64_encode_R8 b64_encode_R8_a b64_encode_R4 b64_encode_R4_a b64_encode_I8 b64_encode_I8_a b64_encode_I4 b64_encode_I4_a b64_encode_I2 b64_encode_I2_a b64_encode_I1 b64_encode_I1_a b64_encode_string b64_encode_string_a All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface b64_encode Procedure for encoding numbers (integer and real) to base64. This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both\n scalar and array. Warning The encoded string is returned as varying length character string, character(len=:), allocatable:: string , thus the\n compiler must support such a Fortran (2003) feature. Note Before start to encode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = 1 2._R8P , code = code64 ) Array encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = [ 12_I4P , 1_I4P ], code = code64 ) Note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The encoding of array of strings is admitted only if each string of the array has the same length. Module Procedures private pure subroutine b64_encode_R16 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (R16P). private pure subroutine b64_encode_R16_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (R16P). private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (R8P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (R4P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (I8P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (I4P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (I2P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (I1P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar string to base64. private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding array string to base64. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/b64_encode.html","title":"b64_encode – BeFoR64"},{"text":"b64_encode_up Interface Source File Lib_Base64.f90 Lib_Base64 b64_encode_up Module Procedures b64_encode_up b64_encode_up_a All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface b64_encode_up Procedure for encoding unlimited polymorphic variable to base64. This is an interface for encoding both scalar and array. Warning The encoded string is returned as varying length character string, character(len=:), allocatable:: string , thus the\n compiler must support such a Fortran (2003) feature. Note Before start to encode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode_up ( up = 1 2._R8P , code = code64 ) Array encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode_up ( up = [ 12_I4P , 1_I4P ], code = code64 ) Note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The encoding of array of strings is admitted only if each string of the array has the same length. Module Procedures public  subroutine b64_encode_up (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding an unlimited polymorphic scalar to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding an unlimited polymorphic array to base64. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/b64_encode_up.html","title":"b64_encode_up – BeFoR64"},{"text":"b64_decode Interface Source File Lib_Base64.f90 Lib_Base64 b64_decode Module Procedures b64_decode_R16 b64_decode_R16_a b64_decode_R8 b64_decode_R8_a b64_decode_R4 b64_decode_R4_a b64_decode_I8 b64_decode_I8_a b64_decode_I4 b64_decode_I4_a b64_decode_I2 b64_decode_I2_a b64_decode_I1 b64_decode_I1_a b64_decode_string b64_decode_string_a All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface b64_decode Procedure for decoding numbers (integer and real) from base64. This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both\n scalar and array. Note Before start to decode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar decoding real ( R8P ) :: decoded ! scalar to be decoded ... call b64_decode ( code = 'AAAAAAAA8D8=' , n = decoded ) Array decoding integer ( I8P ) :: decoded ( 1 : 4 ) ! array to be decoded ... call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = decoded ) Note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The decoding of array of strings is admitted only if each string of the array has the same length. Module Procedures private elemental subroutine b64_decode_R16 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (R16P). private pure subroutine b64_decode_R16_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (R16P). private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (R8P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (R4P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (I8P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (I4P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (I2P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (I1P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Procedure for decoding a base64 code into a scalar string. private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Procedure for decoding a base64 code into an array of strings. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/b64_decode.html","title":"b64_decode – BeFoR64"},{"text":"b64_decode_up Interface Source File Lib_Base64.f90 Lib_Base64 b64_decode_up Module Procedures b64_decode_up b64_decode_up_a All Procedures autotest b64_decode b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up b64_decode_up_a b64_encode b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up b64_encode_up_a b64_init bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bcton bctor_R4P bctor_R8P bit_size bit_size_chr bit_size_R16P bit_size_R4P bit_size_R8P bstr bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P byte_size byte_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P check_endian ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P cton ctor_R16P ctor_R4P ctor_R8P decode_bits digit digit_I1 digit_I2 digit_I4 digit_I8 encode_bits IR_init IR_Print is_little_endian pack_data pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 str str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz strz_I1P strz_I2P strz_I4P strz_I8P public interface b64_decode_up Procedure for decoding unlimited polymorphic variable from base64. This is an interface for decoding both scalar and array. Note Before start to decode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar decoding real ( R8P ) :: decoded ! scalar to be decoded ... call b64_decode_up ( code = 'AAAAAAAA8D8=' , up = decoded ) Array decoding integer ( I8P ) :: decoded ( 1 : 4 ) ! array to be decoded ... call b64_decode_up ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , up = decoded ) Note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The decoding of array of strings is admitted only if each string of the array has the same length. Module Procedures public  subroutine b64_decode_up (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. Description Procedure for decoding an unlimited polymorphic scalar from base64. private  subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Procedure for decoding an unlimited polymorphic array from base64. © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"interface/b64_decode_up.html","title":"b64_decode_up – BeFoR64"},{"text":"Lib_Pack_Data Module Source File Lib_Pack_Data.f90 Lib_Pack_Data Interfaces pack_data Subroutines pack_data_R8_R4 pack_data_R8_I8 pack_data_R8_I4 pack_data_R8_I2 pack_data_R8_I1 pack_data_R4_R8 pack_data_R4_I8 pack_data_R4_I4 pack_data_R4_I2 pack_data_R4_I1 pack_data_I8_R8 pack_data_I8_R4 pack_data_I8_I4 pack_data_I8_I2 pack_data_I8_I1 pack_data_I4_R8 pack_data_I4_R4 pack_data_I4_I8 pack_data_I4_I2 pack_data_I4_I1 pack_data_I2_R8 pack_data_I2_R4 pack_data_I2_I8 pack_data_I2_I4 pack_data_I2_I1 pack_data_I1_R8 pack_data_I1_R4 pack_data_I1_I8 pack_data_I1_I4 pack_data_I1_I2 All Modules IR_Precision Lib_Base64 Lib_Pack_Data Uses: IR_Precision KISS library for packing heterogeneous data into single (homogeneous) packed one Interfaces public interface pack_data Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array.","tags":"","loc":"module/lib_pack_data.html","title":"Lib_Pack_Data – BeFoR64"},{"text":"IR_Precision Module Source File IR_Precision.f90 IR_Precision Variables ir_initialized endianL endianB endian R16P R16P R8P R4P R_P I8P I4P I2P I1P I_P FR16P FR8P FR4P FR_P DR16P DR8P DR4P DR_P FI8P FI8PZP FI4P FI4PZP FI2P FI2PZP FI1P FI1PZP FI_P FI_PZP DI8P DI4P DI2P DI1P DI_P NRknd RPl FRl NIknd RIl FIl MinR16P MaxR16P MinR8P MaxR8P MinR4P MaxR4P MinR_P MaxR_P BIR16P BIR8P BIR4P BIR_P BYR16P BYR8P BYR4P BYR_P smallR16P smallR8P smallR4P smallR_P MinI8P MinI4P MinI2P MinI1P MinI_P MaxI8P MaxI4P MaxI2P MaxI1P MaxI_P BII8P BII4P BII2P BII1P BII_P BYI8P BYI4P BYI2P BYI1P BYI_P ZeroR16 ZeroR8 ZeroR4 Zero Interfaces bit_size byte_size str strz cton bstr bcton digit Functions is_little_endian bit_size_R16P bit_size_R8P bit_size_R4P bit_size_chr byte_size_I8P byte_size_I4P byte_size_I2P byte_size_I1P byte_size_R16P byte_size_R8P byte_size_R4P byte_size_chr strf_R16P strf_R8P strf_R4P strf_I8P strf_I4P strf_I2P strf_I1P str_R16P str_R8P str_R4P str_I8P str_I4P str_I2P str_I1P str_bol str_a_R16P str_a_R8P str_a_R4P str_a_I8P str_a_I4P str_a_I2P str_a_I1P strz_I8P strz_I4P strz_I2P strz_I1P ctor_R16P ctor_R8P ctor_R4P ctoi_I8P ctoi_I4P ctoi_I2P ctoi_I1P bstr_R16P bstr_R8P bstr_R4P bstr_I8P bstr_I4P bstr_I2P bstr_I1P bctor_R8P bctor_R4P bctoi_I8P bctoi_I4P bctoi_I2P bctoi_I1P digit_I8 digit_I4 digit_I2 digit_I1 Subroutines check_endian IR_init IR_Print All Modules IR_Precision Lib_Base64 Lib_Pack_Data Pure Fortran (2003+) library for ensuring codes portability IR_Precision IR_Precision, Fortran (standard 2003+) module for achieving portable codes A KISS library for exploiting codes portability for modern (2003+) Fortran projects. IR_Precision is a pure Fortran (KISS) library for achieving portable codes for modern Fortran projects; IR_Precision provides many number-to-string and viceversa facilities; IR_Precision is Fortran 2003+ standard compliant; IR_Precision is a Free, Open Source Project. Issues Compiler Support What is IR_Precision? Fortran is the most popular programming language for scientific computing. With Fortran it is quite simple obtain fast code and manage large multidimensional array. Because Fortran permits the achievement of high performance it is also used on great range of different computer-architectures, and often on the fastest supercomputer in the world. Therefore Fortran programs must be portable : portability means that the code will give the same results on every different computer-architectures. One of the most important goal of the numeric code is to control the numeric error due to finite precision of numerical operations. Fortran uses the IEEE representations. Integers and reals (floating point) are represented with a finite precision. So when the code computes an operation it has a truncation error due to the truncation of the numerical finite representations. For numerical and more in general scientific applications this source of errors must be controlled. The programmer must know which is the precision associated to the code variables. Before the standard Fortran 90/95 there are not any way to select the precision of the numerical variables in a portable fashion. Modern Fortran standards (2003+) have introduced better support for codes portability. With the possibility to specify a kind parameter for variables, the standard Fortran 90+ makes available useful functions to select the kind precision in a portable parametric way. Using these functions the programmer can accurately control the precision of its own variables in a portable manner. IR_Precision module provides an effective KISS library to achieve portability and concurrently it provides many tools to handles parametrized numbers. Go to Top Main features The library provides portable kind-parameters and many useful procedures to deal with them: integer and reals parameters for 1,2,4,8,16 bytes-like representations; integer and real formats definitions for all parameters; integer and real minimum maximum representable numbers; number-to-string and string-to-number casting procedures; endianism procedures checking. Any feature request is welcome. Go to Top Copyrights IR_Precision is an open source project, it is distributed under the GPL v3 . Anyone is interest to use, to develop or to contribute to IR_Precision is welcome. Go to Top Documentation Besides this README file the IR_Precision documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of IR_Precision To be written. Go to Top ChangeLog Version v1.0.1 Stable release. Fully backward compatible. Introduce digit function. Version v1.0.0 First stable release. Variables Type Visibility Attributes Name Initial logical, public :: ir_initialized = .false. Flag for chcecking the initialization of some variables that must be initialized. integer, public, parameter :: endianL = 1 Little endian parameter. integer, public, parameter :: endianB = 0 Big endian parameter. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: R16P = selected_real_kind(33,4931) 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. integer, public, parameter :: R16P = selected_real_kind(15,307) Defined as R8P; 64 bits. integer, public, parameter :: R8P = selected_real_kind(15,307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6,37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision. character(len=10), public, parameter :: FR16P = '(E42.33E4)' Output format for kind=R16P variable. character(len=10), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P variable. character(len=9), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P variable. character(len=10), public, parameter :: FR_P = FR8P Output format for kind=R_P variable. integer, public, parameter :: DR16P = 42 Number of digits of output format FR16P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. character(len=5), public, parameter :: FI8P = '(I20)' Output format                     for kind=I8P variable. character(len=8), private, parameter :: FI8PZP = '(I20.19)' Output format with zero prefixing for kind=I8P variable. character(len=5), public, parameter :: FI4P = '(I11)' Output format                     for kind=I4P variable. character(len=8), private, parameter :: FI4PZP = '(I11.10)' Output format with zero prefixing for kind=I4P variable. character(len=4), public, parameter :: FI2P = '(I6)' Output format                     for kind=I2P variable. character(len=6), private, parameter :: FI2PZP = '(I6.5)' Output format with zero prefixing for kind=I2P variable. character(len=4), public, parameter :: FI1P = '(I4)' Output format                     for kind=I1P variable. character(len=6), private, parameter :: FI1PZP = '(I4.3)' Output format with zero prefixing for kind=I1P variable. character(len=5), public, parameter :: FI_P = FI4P Output format                     for kind=I_P variable. character(len=8), private, parameter :: FI_PZP = FI4PZP Output format with zero prefixing for kind=I_P variable. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: NRknd = 4 Number of defined real kinds. integer, public, parameter :: RPl (1:NRknd) = [R16P,R8P,R4P,R_P] List of defined real kinds. character(len=10), public, parameter :: FRl (1:NRknd) = [FR16P,FR8P,FR4P//' ',FR_P] List of defined real kinds output format. integer, public, parameter :: NIknd = 5 Number of defined integer kinds. integer, public, parameter :: RIl (1:NIknd) = [I8P,I4P,I2P,I1P,I_P] List of defined integer kinds. character(len=5), public, parameter :: FIl (1:NIknd) = [FI8P,FI4P,FI2P//' ',FI1P//' ',FI_P] List of defined integer kinds output format. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P variable. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P variable. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P variable. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P variable. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P variable. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P variable. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P variable. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P variable. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P variable. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P variable. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P variable. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P variable. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P variable. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P variable. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P variable. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P variable. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest (module) representable value of kind=R16P variable. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest (module) representable value of kind=R8P variable. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest (module) representable value of kind=R4P variable. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest (module) representable value of kind=R_P variable. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P variable. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P variable. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P variable. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P variable. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P variable. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P variable. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P variable. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P variable. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P variable. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P variable. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P variable. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P variable. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P variable. integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P variable. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P variable. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P variable. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P variable. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P variable. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P variable. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P variable. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P,1._R16P)-nearest(1._R16P,-1._R16P) Smallest representable difference of kind=R16P variable. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P,1._R8P)-nearest(1._R8P,-1._R8P) Smallest representable difference of kind=R8P variable. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P,1._R4P)-nearest(1._R4P,-1._R4P) Smallest representable difference of kind=R4P variable. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P variable. Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R16P (r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_R8P (r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_R4P (r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_chr (c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Procedure for computing the number of bits of a character variable. public interface byte_size Overloading of the byte_size function for computing the number of bytes. private elemental function byte_size_I8P (i) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I4P (i) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I2P (i) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I1P (i) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_R16P (r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_R8P (r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_R4P (r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_chr (c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Procedure for computing the number of bytes of a character variable. public interface str Procedure for converting number, real and integer, to string (number to string type casting). private elemental function strf_R16P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R16P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_R8P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R8P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_R4P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R4P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_I8P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I8P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I4P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I4P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I2P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I2P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I1P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I1P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_bol (n) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Procedure for converting logical to string. This function achieves casting of logical to string. private pure function str_a_R16P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R16P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_R8P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R8P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_R4P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R4P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_I8P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I4P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I2P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I1P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. public interface strz Procedure for converting number, integer, to string, prefixing with the right number of zeros (number to string type\n casting with zero padding). private elemental function strz_I8P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I4P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I2P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I1P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. public interface cton Procedure for converting string to number, real or initeger, (string to number type casting). private  function ctor_R16P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctor_R8P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctor_R4P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctoi_I8P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I4P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I2P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I1P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. public interface bstr Procedure for converting number, real and integer, to bit-string (number to bit-string type casting). private elemental function bstr_R16P (n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_R8P (n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_R4P (n) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_I8P (n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I4P (n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I2P (n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I1P (n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. public interface bcton Procedure for converting bit-string to number, real or initeger, (bit-string to number type casting). () Arguments None private elemental function bctor_R8P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. private elemental function bctor_R4P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. private elemental function bctoi_I8P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I4P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I2P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I1P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. public interface digit Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer.","tags":"","loc":"module/ir_precision.html","title":"IR_Precision – BeFoR64"},{"text":"Lib_Base64 Module Source File Lib_Base64.f90 Lib_Base64 Variables b64_initialized base64 Interfaces b64_encode b64_encode_up b64_decode b64_decode_up Subroutines b64_init encode_bits decode_bits b64_encode_up b64_encode_up_a b64_decode_up b64_decode_up_a b64_encode_R16 b64_encode_R8 b64_encode_R4 b64_encode_I8 b64_encode_I4 b64_encode_I2 b64_encode_I1 b64_encode_string b64_encode_R16_a b64_encode_R8_a b64_encode_R4_a b64_encode_I8_a b64_encode_I4_a b64_encode_I2_a b64_encode_I1_a b64_encode_string_a b64_decode_R16 b64_decode_R8 b64_decode_R4 b64_decode_I8 b64_decode_I4 b64_decode_I2 b64_decode_I1 b64_decode_string b64_decode_R16_a b64_decode_R8_a b64_decode_R4_a b64_decode_I8_a b64_decode_I4_a b64_decode_I2_a b64_decode_I1_a b64_decode_string_a autotest All Modules IR_Precision Lib_Base64 Lib_Pack_Data Uses: IR_Precision Lib_Pack_Data BeFoR64, Base64 encoding/decoding library for FoRtran poor men BeFoR64 BeFoR64, Base64 encoding/decoding library for FoRtran poor people BeFoR64 is a pure Fortran (KISS) library for base64 encoding/decoding for modern (2003+) Fortran projects; BeFoR64 is Fortran 2003+ standard compliant; BeFoR64 is a Free, Open Source Project. Table of Contents What is BeFoR64? Main features Copyrights Documentation A Taste of BeFoR64 Issues Compiler Support -brightgreen.svg) -brightgreen.svg) What is BeFoR64? Modern Fortran standards (2003+) have introduced better support for strings manipulations. Exploiting such new Fortran capabilities, BeFoR64 provides an easy to use module library for encoding and decoding Fortran types (binary internal representation) in ascii- base64 -encoded string. Go to Top Main features User-friendly methods for encoding/decoding in base64: encode real/integer scalar variables; decode real/integer scalar variables; encode real/integer array variables; decode real/integer array variables; encode character scalar variables; decode character scalar variables; encode character array variables; decode character array variables; encode unlimited polymorphic scalar variables; decode unlimited polymorphic scalar variables; encode unlimited polymorphic array variables; decode unlimited polymorphic array variables; user-friendly methods for packing heterogeneous data: pack integer/integer (different kinds) scalars; pack integer/integer (different kinds) arrays; pack real/real (different kinds) scalars; pack real/real (different kinds) arrays; pack integer/real scalars; pack integer/real arrays; errors trapping mechanism. Any feature request is welcome. Go to Top Copyrights BeFoR64 is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to BeFoR64 is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the BeFoR64 documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of BeFoR64 Let us assume our goal is encoding a binary integer. It is as simple as USE Lib_Base64 ... character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = 1 2._R8P , code = code64 ) print \"(A)\" , code64 But you are not limited to a simple integer scalar, you can encode real, integer, characters scalar or arrays, and by means of the auxiliary Lib_Pack library also mixed types. See the wiki . Go to Top ChangeLog Change Log Unreleased Full Changelog Closed issues: Pure/Elemental with unlimited polymorphic #8 v1.0.3 (2015-06-08) Full Changelog Closed issues: Unlimited polymorphic encoding/decoding #5 Characters encoding/decoding #4 Wiki Exploiting #3 Documentation improvement #2 v1.0.2 (2015-02-12) Full Changelog v1.0.1 (2015-02-03) Full Changelog Closed issues: Decoders implementing #1 v1.0.0 (2015-02-02) Full Changelog v0.1.1 (2015-01-29) Full Changelog v0.0.1 (2015-01-27) * *This Change Log was automatically generated by github_changelog_generator Variables Type Visibility Attributes Name Initial logical, public :: b64_initialized = .false. Flag for chcecking the initialization of the library. character(len=64), private :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" Base64 alphabet. Interfaces public interface b64_encode Procedure for encoding numbers (integer and real) to base64. private pure subroutine b64_encode_R16 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (R16P). private pure subroutine b64_encode_R16_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (R16P). private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (R8P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (R4P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (I8P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (I4P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (I2P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar number to base64 (I1P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding array numbers to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding scalar string to base64. private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding array string to base64. public interface b64_encode_up Procedure for encoding unlimited polymorphic variable to base64. public  subroutine b64_encode_up (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Procedure for encoding an unlimited polymorphic scalar to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Procedure for encoding an unlimited polymorphic array to base64. public interface b64_decode Procedure for decoding numbers (integer and real) from base64. private elemental subroutine b64_decode_R16 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (R16P). private pure subroutine b64_decode_R16_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (R16P). private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (R8P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (R4P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (I8P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (I4P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (I2P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Procedure for decoding a base64 code into a scalar number (I1P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Procedure for decoding a base64 code into an array numbers (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Procedure for decoding a base64 code into a scalar string. private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Procedure for decoding a base64 code into an array of strings. public interface b64_decode_up Procedure for decoding unlimited polymorphic variable from base64. public  subroutine b64_decode_up (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. Description Procedure for decoding an unlimited polymorphic scalar from base64. private  subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Procedure for decoding an unlimited polymorphic array from base64.","tags":"","loc":"module/lib_base64.html","title":"Lib_Base64 – BeFoR64"},{"text":"Test_Driver Program Source File Test_Driver.f90 Test_Driver All Programs Test_Driver Uses: IR_Precision Lib_Base64 Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men Usage ./Test_Driver © 2015 BeFoR64 was written by Stefano Zaghi. Documentation generated by FORD .","tags":"","loc":"program/test_driver.html","title":"Test_Driver – BeFoR64"}]}